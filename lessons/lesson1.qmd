---
title: "Pr√°ctica 1: Introducci√≥n a Processing"
format:
  html: 
    toc: true
    number-sections: true
navbar:
  background: primary
  search: true
  right:
    - icon: github
      href: https://github.com/fastai/course22
sidebar:
  style: "floating"
---

## Objetivos de la pr√°ctica

Los objetivos de esta pr√°ctica son los siguientes:

- Familiarizaci√≥n con el ordenador y los elementos b√°sicos de un sistema operativo.
- Familiarizaci√≥n con el entorno de desarrollo Processing.
- Familiarizaci√≥n con aspectos b√°sicos de programaci√≥n a trav√©s de programas en Processing.

::: {.callout-note}
## üéû Diapositivas
[**Diapositivas para la presentaci√≥n de la pr√°ctica en clase**](../slides/lesson1.html)
:::

---

## Processing

### Introducci√≥n

::: {layout="[75,25]"}
::: {.column}
Processing es un lenguaje de programaci√≥n y un entorno de desarrollo (*Integrated Development Environment*, IDE).

- **Basado en Java**
- **Producci√≥n de proyectos multimedia e interactivos**
- Creado por cient√≠ficos del MIT en 2001
- Distribuci√≥n gratuita y de c√≥digo abierto
:::
::: {.column}
![](../resources/lesson1/processing.svg)
:::
:::

La propia [p√°gina de Processing](https://processing.org/examples/) muestra numerosos ejemplos de proyectos realizados con este lenguaje. Tambi√©n hay muchos ejemplos en Youtube, en particular, en el canal de [The Coding Train](https://www.youtube.com/c/TheCodingTrain).

::: {layout="[50,50]"}
::: {.column}
![Visualizaci√≥n del [fractal de Mandelbrot](https://processing.org/examples/mandelbrot.html).](../resources/lesson1/processing-example.png){#fig-mandelbrot}
:::
::: {.column}
![Canal de Youtube [The Coding Train](https://www.youtube.com/c/TheCodingTrain).](../resources/lesson1/thecodetrain.gif){#fig-thecodetrain}
:::
:::

### El entorno de desarrollo

El entorno de desarrollo de Processing tiene un dise√±o minimalista que facilita su uso. La interfaz gr√°fica posee las siguientes partes:

- **Un men√∫ de opciones** (archivo, editar, sketch, depuraci√≥n, herramientas y ayuda).
- **Dos botones para ejecutar y detener el programa.**
- Un √°rea central para escribir el c√≥digo fuente (**editor**).
- Una ventana inferior donde se muestran dos pesta√±as:
  - **Consola**: Salida est√°ndar del programa.
  - **Errores**: Mensajes de error generados durante la ejecuci√≥n.
  
![Vista del entorno de desarrollo y ventana pop-up que redirige a ejemplos disponibles en su p√°gina web.](../resources/lesson1/ide.png){#fig-ide}

Al ejecutar un programa se abrir√° una **nueva ventana donde se mostrar√° el resultado de la ejecuci√≥n** .

::: {.callout-warning}
Cada ejercicio debe realizarse en un nuevo fichero, no en una nueva pesta√±a. Se recomienda guarda cada fichero a medida que se avanza en los ejercicios.
:::

---

## Dibujando figuras geom√©tricas

Las figuras geom√©tricas se dibujan en una ventana que est√° formada por una **matriz de p√≠xeles**. Cada p√≠xel es un peque√±o punto de luz que puede tener un color diferente. La combinaci√≥n de todos los p√≠xeles forma la imagen que vemos en la pantalla.

Por ejemplo, las dos animaciones siguientes muestran la diferencia entre una resoluci√≥n de pantalla alta y otra baja. En la animaci√≥n de la derecha, a medida que reducimos la resoluci√≥n, podemos observar los p√≠xeles individuales que componen la imagen.

::: {layout="[50,50]"}
::: {.column}
![Animaci√≥n con una resoluci√≥n de pantalla alta.](../resources/lesson1/animation_pixels.webm){#fig-highres}
:::

::: {.column}
![Animaci√≥n con una resoluci√≥n de pantalla baja, mostrando p√≠xeles.](../resources/lesson1/animation_pixels_lowerres.webm){#fig-lowres}
:::
:::

::: {layout="[70,30]"}
::: {.column}
Para dibujar cualquier figura geom√©trica, es necesario especificar una o varias posiciones en la ventana. Dichas posiciones se definen mediante un par de coordenadas **(x, y)**, donde **x** indica la **posici√≥n horizontal** e **y** la **posici√≥n vertical**. En *Processing*, el origen de coordenadas (0,0) se encuentra en la esquina superior izquierda de la ventana, como se muestra en la figura de la derecha.

::: {.callout-note}
## üß™ Ejercicio 1 - Sistema de coordenadas

Dibuja una l√≠nea que va desde la posici√≥n (10, 0) hasta la posici√≥n (40, 50).
```java
line(10, 0, 40, 50);
```
:::
:::
::: {.column}
![Ilustraci√≥n de una matriz de p√≠xeles, indicando las coordenadas de algunos de ellos.](../resources/lesson1/pixel-matrix.png){#fig-pixels}
:::
:::

::: {.callout-warning}
## üìù Ejercicio 2 ‚Äî Errores comunes

Prueba a copiar el siguiente c√≥digo en el editor de *Processing* y ejecutarlo:
```java
Line(10, 0, 40, 50);
```

<details>
<summary>üí° Soluci√≥n</summary>
Processing es sensible al uso de may√∫sculas y min√∫sculas. Por ejemplo, la funci√≥n para dibujar una l√≠nea es `line`, no `Line` ni `LINE`.

Las palabras reservadas se muestran <span style="color:#1f77ff; font-weight:600;">resaltadas</span> en el editor, por lo que esta es una manera de ver si el nombre de una funci√≥n est√° bien escrito. Los <span style="color:#FF0000; font-weight:600;">errores</span> se muestran en la pesta√±a *Errores* de la ventana inferior.
</details>
:::

::: {.callout-note}
## üß™ Ejercicio 3 - M√∫ltiples formas geom√©tricas

Prueba a dibujar varias l√≠neas en diferentes posiciones de la pantalla, utilizando la instrucci√≥n `line` varias veces. 
:::

### Lienzo

Las figuras geom√©tricas se dibujan sobre un lienzo de tama√±o predeterminado 100x100 p√≠xeles. No obstante, es posible cambiar el tama√±o del lienzo utilizando la funci√≥n `size`, que recibe dos par√°metros: el ancho y el alto del lienzo en p√≠xeles.

::: {.callout-note}
## üß™ Ejercicio 4 - Tama√±o del lienzo 

Dibuja varias l√≠neas en un lienzo de tama√±o 300x200 p√≠xeles.

<details>
<summary>üí° Soluci√≥n</summary>
```java
size(300, 200);
line(10, 0, 40, 50);
line(100, 50, 200, 150);
line(250, 0, 250, 200);
```
</details>
:::

### Tipos de figuras geom√©tricas

Adem√°s de la l√≠nea utilizada en los ejercicios anteriores, *Processing* permite dibujar otras figuras geom√©tricas b√°sicas, tales como **puntos**, **tri√°ngulos**, **cuadril√°teros**, **rect√°ngulos** y **elipses**. 

::: {.callout-note}
## üß™ Ejercicio 5 - Deducci√≥n de par√°metros

¬øPuedes deducir qu√© par√°metros son necesarios para dibujar algunas de las figuras geom√©tricas mencionadas anteriormente?
Puedes consultar la [documentaci√≥n oficial de *Processing*](https://processing.org/reference#shape), y m√°s concretamente, la secci√≥n *2d primitives* en el apartado *Shape*.

<details>
<summary>üí° Soluci√≥n</summary>
- `point(x, y)`: un punto en la posici√≥n (x, y).
- `triangle(x1, y1, x2, y2, x3, y3)`: un tri√°ngulo con v√©rtices en las posiciones (x1, y1), (x2, y2) y (x3, y3).
- `quad(x1, y1, x2, y2, x3, y3, x4, y4)`: un cuadril√°tero con v√©rtices en las posiciones (x1, y1), (x2, y2), (x3, y3) y (x4, y4).
- `rect(x, y, anchura, altura)`: un rect√°ngulo con esquina superior izquierda en la posici√≥n (x, y), de anchura y altura especificadas.
- `ellipse(x, y, anchura, altura)`: una elipse centrada en la posici√≥n (x, y), con anchura y altura especificadas.
</details>
:::

#### Dibujando rect√°ngulos y elipses

Tanto en la documentaci√≥n oficial, como en la soluci√≥n del ejercicio anterior, os habr√©is podido dar cuenta de que las funciones `rect` y `ellipse` requieren cuatro par√°metros: dos para la posici√≥n y dos para el tama√±o. Sin embargo, hemos asumido que la posici√≥n siempre corresponde a la esquina superior izquierda del rect√°ngulo o al centro de la elipse. Esta suposici√≥n es correcta por defecto, pero es posible cambiarla utilizando las funciones `rectMode` y `ellipseMode`.

![](../resources/lesson1/rect-mode.svg){#fig-rectmodes}

Por defecto, Processing interpreta las posiciones de la siguiente manera:
```java
rectMode(CORNER);
ellipseMode(CENTER);
```

Tambi√©n es posible cambiar esta interpretaci√≥n usando:

```java
rectMode(CENTER);
ellipseMode(CORNER);
```

::: {.callout-note}
## üß™ Ejercicio 6 - Modo de dibujo

Intenta dibujar un c√≠rculo centrado en (20, 30) con radio 10 utilizando ambos modos. En el siguiente c√≥digo tienes todas las instrucciones necesarias para completar el ejercicio:
```java
// Modo por defecto
ellipseMode(CENTER);
ellipse( , , , );

// Modo alternativo
ellipseMode(CORNER);
ellipse( , , , );
```
:::

## Color en *Processing*

### Escala de grises

::: {layout="[60,30]"}
::: {.column}
Hasta ahora, hemos dibujado figuras geom√©tricas sin especificar ning√∫n color. Por defecto, las figuras se dibujan en negro sobre un fondo blanco.

A continuaci√≥n, veremos c√≥mo especificar colores en *Processing*. Por ahora, basta con componer colores en escala de grises. Para ello hay que tener en cuenta que la escala de un tono de gris va de 0 a 255; el valor 0 corresponde al negro y el valor 255 corresponde al blanco. Por ejemplo, la figura de la derecha se ha representado √∫nica y exclusivamente con diferentes valores de gris.

En *Processing*, las figuras tienen **borde** y **relleno**, que se definen mediante los m√©todos `stroke` y `fill`. Adem√°s, tambi√©n puede controlarse el color de fondo de la ventana con `background`.
:::

::: {.column}
![Imagen representada √∫nicamente con valores de gris.](../resources/lesson1/grayscale.svg){#fig-grayscale}
:::
:::

Por ejemplo, podemos definir el color del fondo, as√≠ como del borde y el relleno de un rect√°ngulo de la siguiente manera:
```java
background(0);              // fondo 

stroke(200);                // borde
fill(100);                  // relleno
rect(50, 50, 100, 100);
```

Adem√°s, cabe destacar que *Processing* funciona como una **m√°quina de estados**; es decir, **una vez se indica el color de borde o de relleno, este se utilizar√° para todas las figuras que se dibujen a continuaci√≥n**. Por ejemplo, podemos dibujar dos rect√°ngulos con el mismo color de borde, pero diferente color de relleno, de la siguiente manera:
```java
stroke(0);
fill(150);
rect(20, 20, 50, 50);       // borde negro, relleno gris

fill(50);
rect(80, 20, 50, 50);       // mismo borde, diferente relleno
```

::: {.callout-note}
## üß™ Ejercicio 7 - C√≠rculo y colores

Dibuja un c√≠rculo negro con borde gris, centrado en (20, 30) y con radio 10.

<details>
<summary>üí° Soluci√≥n</summary>
```java
stroke(128);
fill(0);
ellipse(20, 30, 20, 20);
```
</details>
:::

::: {.callout-note}
## üß™ Ejercicio 8 - Dibuja una forma geom√©trica

Trata de obtener algo parecido a la figura que se muestra debajo.

![](../resources/lesson1/render.png){width="20%" fig-align="center"}
:::

### Colores RGB (red, green, blue)

::: {layout="[30,70]"}
::: {.column}
![Representaci√≥n de los colores primarios RGB.](../resources/lesson1/primary-colors.png){#fig-rgb}
:::

::: {.column}
Adem√°s de diferentes tonos de gris, *Processing* permite definir colores a partir de los tres colores primarios: rojo, verde y azul (RGB). Cuando los tres componentes toman el valor m√°ximo (255), el color resultante es el blanco. En una escala de grises, los tres valores RGB coinciden; por ejemplo, el color (0, 0, 0) corresponde al negro. Por otro lado, si s√≥lo activamos un canal con 255, y dejamos el resto a 0, obtenemos rojo, verde o azul.

```java
fill(255, 0, 0);  // rojo
fill(0, 255, 0);  // verde
fill(0, 0, 255);  // azul
```
:::
:::

::: {.callout-note}
## üß™ Ejercicio 9 - Colores RGB

¬øSabr√≠as decir qu√© colores crear√°n las siguientes combinaciones de rojo, verde y azul?

- `fill(255, 255, 0)`
- `fill(0, 255, 255)`
- `fill(255, 0, 255)`
- `fill(255, 255, 127)`
- `fill(127, 255, 255)`
- `fill(255, 127, 255)`

**Pista**: f√≠jate en la @fig-rgb.
:::

### Opacidad

Adem√°s de los canales R, G y B, tambi√©n podemos indicar un valor de **opacidad**. De esta manera, un valor de opacidad de 255 indica que elemento a dibujar es completamente opaco, y un valor de 0 indica que es completamente transparente. Para especificar la opacidad, bastante con indicar un cuarto valor en operaciones como `stroke` o `fill`.

```java
fill(255, 255, 127);
rect(50, 50, 100, 100);     // rect√°ngulo opaco     

fill(255, 0, 127, 127);     
rect(20, 20, 50, 50);       // rect√°ngulo semitransparente
```

## Programas din√°micos

Hasta este momento, hemos escrito programas est√°ticos, es decir, programas que dibujan una imagen fija. A continuaci√≥n, veremos c√≥mo crear programas din√°micos que pueden cambiar con el tiempo.

::: {layout="[50,50]"}
::: {.column}
Comenzaremos con este bloque de c√≥digo:
```java
size(800, 800);

// Aumenta el tama√±o de todo lo que se dibuje
scale(2);

// Pinta un fondo blanco
background(255);

// Fija las coordenadas basadas en el centro
ellipseMode(CENTER);
rectMode(CENTER);

// Dibuja el cuerpo
stroke(0);
fill(150);
rect(200, 200, 40, 200);

// Dibuja la cabeza
fill(255);
ellipse(200, 140, 120, 120);

// Dibuja los ojos
fill(0);
ellipse(162, 140, 32, 64);
ellipse(238, 140, 32, 64);

// Dibuja las piernas
stroke(0);
line(180, 300, 160, 320);
line(220, 300, 240, 320);
```
:::

::: {.column}
![Imagen del alien√≠gena Zoog.](../resources/lesson1/zoog.png){#fig-zoog}

::: {.callout-note}
## üß™ Ejercicio 10 - Dibuja a Zoog
Intenta dibujar al alien√≠gena Zoog utilizando el bloque de c√≥digo anterior como referencia.
:::
:::
:::

### Comentarios

Aprovechando que nuestro programa empieza a ser un poco m√°s largo, es recomendable a√±adir comentarios para explicar qu√© hace cada parte del c√≥digo. En *Processing*, los comentarios se indican con `//` para comentarios de una sola l√≠nea, o con `/*` y `*/` para comentarios multil√≠nea. Por ejemplo, en el siguiente c√≥digo se han a√±adido comentarios para explicar qu√© parte del cuerpo de Zoog dibuja cada bloque de instrucciones:

```java
// Dibuja el cuerpo de Zoog
rect(200, 200, 40, 200);

/* Dibuja los ojos de Zoog en la posici√≥n (200, 140) con ancho y alto 120 */
ellipse(200, 140, 120, 120);
```

### Funciones `setup` y `draw`

*Processing* utiliza dos funciones especiales para organizar el c√≥digo: `setup` y `draw`. 

- La funci√≥n `setup` se ejecuta una √∫nica vez al inicio del programa, y es el lugar adecuado para inicializar variables, definir el tama√±o de la ventana, etc. 
- Por otro lado, la funci√≥n `draw` se ejecuta de manera repetitiva en un bucle infinito, y es el lugar adecuado para dibujar figuras que cambian con el tiempo.

Tanto `setup` como `draw` son funciones especiales que no requieren ser llamadas expl√≠citamente en el c√≥digo; *Processing* se encarga de ello autom√°ticamente. Aunque no entraremos en detalles sobre la sintaxis de las funciones en este momento, es importante destacar que el c√≥digo que se encuentra dentro de una funci√≥n debe estar **sangrado** (indentado) para indicar que pertenece a dicha funci√≥n. Adem√°s, ambas funciones devuelven `void`, lo que significa que no devuelven ning√∫n valor. Tambi√©n es importante abrir y cerrar llaves `{}` para definir el bloque de c√≥digo que pertenece a cada funci√≥n.

::: {layout="[50.5,49.5]"}
::: {.column}
Por ejemplo, el siguiente programa dibuja una pelota que rebota dentro de la ventana:
```java
int x = 50;
int y = 50;
int speedX = 3;
int speedY = 2;

void setup() {
  size(400, 400);
} 

void draw() {
  background(255);
  
  // Dibuja la pelota
  fill(0);
  ellipse(x, y, 30, 30);
  
  // Actualiza la posici√≥n de la pelota
  x += speedX;
  y += speedY;
  
  // Rebote en los bordes
  if (x <= 15 || x >= width - 15) {
    speedX = -speedX;
  }
  if (y <= 15 || y >= height - 15) {
    speedY = -speedY;
  }
}
```
::: 

::: {.column .centered}
![](../resources/lesson1/bouncing_ball.gif)
:::
:::

::: {.callout-note}
## üß™ Ejercicio 11 - Zoog, utilizando `setup` y `draw`

Reescribe el c√≥digo de Zoog utilizando las funciones `setup` y `draw`. **¬øNotas alguna diferencia en el resultado respecto al c√≥digo original?**

```java
void draw() {
  // Pinta un fondo blanco
  background(255);

  // Fija las coordenadas basadas en el centro
  ellipseMode(CENTER);
  rectMode(CENTER);

  // Dibuja el cuerpo
  stroke(0);
  fill(150);
  rect(200, 200, 40, 200);

  // Dibuja la cabeza
  fill(255);
  ellipse(200, 140, 120, 120);

  // Dibuja los ojos
  fill(0);
  ellipse(162, 140, 32, 64);
  ellipse(238, 140, 32, 64);

  // Dibuja las piernas
  stroke(0);
  line(180, 300, 160, 320);
  line(220, 300, 240, 320);
}

void setup() {
  // Tama√±o del lienzo
  size(800, 800);
}
```
:::

::: {.callout-warning}
## üî¥ Color de fondo 

Prueba a mover la instrucci√≥n `background(255);` desde la funci√≥n `draw` a la funci√≥n `setup`. **¬øQu√© ocurre?**
:::

### Transformaciones geom√©tricas

Aunque no entraremos en detalles sobre las transformaciones geom√©tricas en este momento, es importante mencionar que *Processing* proporciona varias funciones para trasladar, rotar y escalar las figuras geom√©tricas. Por ejemplo, la funci√≥n `translate(x, y)` permite trasladar el origen de coordenadas a la posici√≥n (x, y), de manera que todas las figuras que se dibujen a continuaci√≥n se posicionar√°n en funci√≥n de este nuevo origen.

En resumen, las transformaciones geom√©tricas m√°s comunes son:

- `translate(x, y)`: traslada el origen de coordenadas a la posici√≥n (x, y).
- `rotate(angle)`: rota el sistema de coordenadas en un √°ngulo especificado (en radianes).
- `scale(s)`: escala el sistema de coordenadas por un factor s.
- `scale(sx, sy)`: escala el sistema de coordenadas por factores sx y sy en las direcciones x e y, respectivamente.

Por otro lado, cuando aplicamos transformaciones geom√©tricas, es importante tener en cuenta que estas se acumulan. Por ejemplo, si aplicamos una traslaci√≥n seguida de una rotaci√≥n, la rotaci√≥n se realizar√° en funci√≥n del nuevo origen de coordenadas tras la traslaci√≥n.

Para evitar este comportamiento acumulativo, *Processing* proporciona las funciones `pushMatrix()` y `popMatrix()`, que permiten guardar y restaurar el estado del sistema de coordenadas, respectivamente. De esta manera, podemos aplicar transformaciones geom√©tricas a un bloque espec√≠fico de c√≥digo sin afectar al resto del programa.

### Interacci√≥n con el rat√≥n

Como habr√°s podido observar, en el programa de la pelota que rebota, se utilizan algunas palabras reservadas como `width` y `height`. Estas palabras reservadas permiten acceder al ancho y alto de la ventana, respectivamente. De manera similar, *Processing* proporciona otras palabras reservadas que permiten interactuar con el rat√≥n, como `mouseX` y `mouseY`, que indican la posici√≥n actual del rat√≥n en la ventana.

::: {.callout-note}
## üß™ Ejercicio 12 - Sigue al rat√≥n

Modifica el programa de Zoog para que la esquina superior izquierda, es decir, desde donde se dibuja el cuerpo, siga la posici√≥n del rat√≥n, utilizando `mouseX` y `mouseY`.

üí°**Pista**: se puede trasladar toda la geometr√≠a con una de las transformaciones geom√©tricas antes mencionadas.
:::

::: {.callout-note}
## üß™ Ejercicio 13 - Reacci√≥n del cuerpo al movimiento del rat√≥n

Modifica el programa de Zoog para que la cabeza gire en funci√≥n de la posici√≥n del rat√≥n. Por ejemplo, si el rat√≥n est√° a la izquierda de Zoog, la cabeza debe girar hacia la izquierda, y viceversa.

üí°**Pista**: se puede rotar toda la geometr√≠a de la cabeza con una de las transformaciones geom√©tricas antes mencionadas. Para calcular el √°ngulo de rotaci√≥n, puedes utilizar la funci√≥n `atan2(dy, dx)`, donde `dy` y `dx` son las diferencias en las coordenadas y y x entre la posici√≥n del rat√≥n y la posici√≥n de la cabeza de Zoog.

<details>
<summary>üí° Soluci√≥n</summary>
```java
void drawPupil(float ex, float ey) {
  pushMatrix();
  translate(ex, ey);

  float angle = atan2(mouseY - ey, mouseX - ex);
  rotate(angle);

  fill(0);
  ellipse(6, 0, 12, 12);  // pupil offset along X

  popMatrix();
}
```
</details>
:::

## Variables, condicionales y bucles

### Introducci√≥n a variables

En la secci√≥n anterior hemos descubierto que el m√©todo `draw` se ejecuta de manera repetitiva en un bucle infinito. Esto nos permite crear programas din√°micos que cambian con el tiempo. Sin embargo, para crear programas m√°s complejos, es necesario utilizar **variables** para almacenar datos que pueden cambiar durante la ejecuci√≥n del programa.

::: {.callout-note}
## üß™ Ejercicio 14 - Traslada una esfera

Crea un programa que traslade una esfera de izquierda a derecha en la ventana. Utiliza una variable para almacenar la posici√≥n horizontal de la esfera, y actual√≠zala en cada iteraci√≥n del bucle `draw`.

<details>
<summary>üí° Soluci√≥n</summary>
```java
int circleX = 100;
int circleY = 100;

void setup() {
  size(200, 200);
}

void draw() {
  background(255);
  stroke(0);
  fill(175);
  ellipse(circleX, circleY, 50, 50);
  circleX = circleX + 1;
}
```
</details>
:::

### Condicionales

Los **condicionales** permiten ejecutar diferentes bloques de c√≥digo en funci√≥n de si se cumple o no una determinada condici√≥n. En *Processing*, los condicionales se implementan utilizando las palabras reservadas `if`, `else if` y `else`.

## Ap√©ndice: Instalaci√≥n de Processing {.unnumbered}

![Banner de la p√°gina oficial de *Processing*; a la izquierda se muestra el bot√≥n de *Download*.](../resources/lesson1/web-teaser.png){#fig-installation}

- Accede a [la p√°gina oficial de *Processing*](http://processing.org) y selecciona **Download**.
- Descarga la versi√≥n correspondiente a tu sistema operativo.
- Ejecuta el instalador descargado y sigue las instrucciones.

