---
title: "Pr√°ctica 1: Introducci√≥n a Processing"
format:
  html: 
    toc: true
    number-sections: true
navbar:
  background: primary
  search: true
  right:
    - icon: github
      href: https://github.com/fastai/course22
sidebar:
  style: "floating"
---

## Objetivos de la pr√°ctica

Los objetivos de esta pr√°ctica son los siguientes:

- Familiarizaci√≥n con el ordenador y los elementos b√°sicos de un sistema operativo.
- Familiarizaci√≥n con el entorno de desarrollo *Processing*.
- Familiarizaci√≥n con aspectos b√°sicos de programaci√≥n a trav√©s de programas en *Processing*.

::: {.callout-note}
## üéû Diapositivas
[**Diapositivas para la presentaci√≥n de la pr√°ctica en clase**](../slides/lesson1.html)
:::

---

## Processing

### Introducci√≥n

::: {layout="[80,20]"}
::: {.column}
*Processing* es un lenguaje de programaci√≥n y un entorno de desarrollo (*Integrated Development Environment*, IDE).

- **Basado en Java**.
- **Producci√≥n de proyectos multimedia e interactivos**.
- Creado por cient√≠ficos del MIT en 2001.
- Distribuci√≥n gratuita y de c√≥digo abierto.
:::
::: {.column}
![](../resources/lesson1/processing.svg)
:::
:::

La propia [p√°gina de Processing](https://processing.org/examples/) muestra numerosos ejemplos de proyectos realizados con este lenguaje. Tambi√©n hay muchos ejemplos en Youtube, en particular, en el canal de [The Coding Train](https://www.youtube.com/c/TheCodingTrain).

::: {layout="[50,50]"}
::: {.column}
![Visualizaci√≥n del [fractal de Mandelbrot](https://processing.org/examples/mandelbrot.html).](../resources/lesson1/processing-example.png){#fig-mandelbrot}
:::
::: {.column}
![Canal de Youtube [The Coding Train](https://www.youtube.com/c/TheCodingTrain).](../resources/lesson1/thecodetrain.gif){#fig-thecodetrain}
:::
:::

### El entorno de desarrollo

El entorno de desarrollo de *Processing* tiene un dise√±o minimalista que facilita su uso. La interfaz gr√°fica est√° compuesta por los siguientes elementos principales:

- **Un men√∫ de opciones** (archivo, editar, sketch, depuraci√≥n, herramientas y ayuda).
- **Dos botones para ejecutar y detener el programa.**
- Un √°rea central para escribir el c√≥digo fuente (**editor**).
- Una ventana inferior donde se muestran dos pesta√±as:
  - **Consola**: salida est√°ndar del programa.
  - **Errores**: mensajes de error generados durante la ejecuci√≥n.
  
Al ejecutar un programa se abrir√° una **nueva ventana donde se mostrar√° el resultado de la ejecuci√≥n**.

![Vista del entorno de desarrollo (derecha) y ventana *pop-up* (izquierda) que redirige a ejemplos disponibles en su p√°gina web.](../resources/lesson1/ide.png){#fig-ide}

::: {.callout-warning}
El primer archivo que se crea en un nuevo proyecto de *Processing* se denomina `sketch_yymmdda`. Es recomendable cambiar el nombre del archivo para que tenga sentido con el programa que se va a desarrollar. Adem√°s, al guardarlo nos preguntar√° el nombre del proyecto, que tambi√©n es recomendable que tenga sentido. 

Indicad una ubicaci√≥n de f√°cil acceso en vuestro ordenador para guardar los proyectos de *Processing*.
:::

## Dibujando figuras geom√©tricas

Las figuras geom√©tricas se dibujan en una ventana que est√° formada por una **matriz de p√≠xeles**. Cada p√≠xel es un peque√±o punto de luz que puede tener un color diferente. La combinaci√≥n de todos los p√≠xeles forma la imagen que vemos en la pantalla.

Un p√≠xel es la **unidad m√°s peque√±a de una imagen digital**. La resoluci√≥n de una imagen se refiere a la cantidad de p√≠xeles que contiene, y se expresa como el n√∫mero de p√≠xeles en el eje horizontal por el n√∫mero de p√≠xeles en el eje vertical (por ejemplo, 1920x1080 p√≠xeles). Por ejemplo, la @fig-highres muestra una animaci√≥n con una resoluci√≥n alta, donde los p√≠xeles no son visibles a simple vista. En cambio, en la @fig-lowres se ha reducido la resoluci√≥n de la animaci√≥n, y comienzan a ser visibles los p√≠xeles individuales.

::: {layout="[50,50]"}
::: {.column}
![Animaci√≥n con una resoluci√≥n de pantalla alta.](../resources/lesson1/animation_pixels.webm){#fig-highres}
:::

::: {.column}
![Animaci√≥n con una resoluci√≥n de pantalla m√°s baja, donde comienzan a ser visibles los p√≠xeles.](../resources/lesson1/animation_pixels_lowerres.webm){#fig-lowres}
:::
:::

::: {layout="[70,30]"}
::: {.column}
Para dibujar cualquier figura geom√©trica, es necesario especificar una o varias posiciones en la ventana. Dichas posiciones se definen mediante un par de coordenadas ***(x, y)***, donde ***x*** indica la **posici√≥n horizontal** e ***y*** la **posici√≥n vertical**. En *Processing*, **el origen de coordenadas (0,0) se encuentra en la esquina superior izquierda de la ventana**, como se muestra en la @fig-pixels

::: {.callout-note}
## üß™ Ejercicio 1 - Sistema de coordenadas

Dibuja una l√≠nea que va desde la posici√≥n (10, 0) hasta la posici√≥n (40, 50). Cuando se ejecute, os podr√©is dar cuenta de que el origen, (0,0), parte de la esquina superior izquierda.
```java
line(10, 0, 40, 50);
```
:::
:::
::: {.column}
![Ilustraci√≥n de una matriz de p√≠xeles, indicando las coordenadas de algunos de ellos.](../resources/lesson1/pixel-matrix.svg){#fig-pixels}
:::
:::

Este concepto puede entenderse como **darle un nombre a un conjunto de instrucciones para poder reutilizarlas f√°cilmente** m√°s adelante. En **matem√°ticas**, una funci√≥n toma uno o varios valores de entrada y produce un valor de salida siguiendo una regla. Por ejemplo, la funci√≥n
$f(x) = x^2$ toma un n√∫mero $x$ y devuelve su cuadrado.

En programaci√≥n ocurre algo muy similar: una funci√≥n recibe unos par√°metros, ejecuta unas instrucciones con ellos y, opcionalmente, devuelve un resultado.

Por ejemplo, podemos definir en Java una funci√≥n que reciba un n√∫mero entero y devuelva su cuadrado:
```java
int square(int x) {
  return x * x;
}
```

Una vez definida, podemos usar la funci√≥n tantas veces como queramos, simplemente indicando el valor de entrada:
```java
int result = square(5);  // result tendr√° el valor 25
```

De este modo:

- `square` es el nombre de la funci√≥n.
- `x` es el par√°metro de entrada.
- `return` indica el valor que devuelve la funci√≥n.

En *Processing* ocurre exactamente lo mismo. La funci√≥n `line`, por ejemplo, recibe cuatro par√°metros (las coordenadas de dos puntos) y ejecuta una acci√≥n: dibujar una l√≠nea en la ventana. La diferencia es que, en este caso, la funci√≥n no devuelve un valor, sino que produce un efecto visual en pantalla.

::: {.callout-warning}
## üìù Ejercicio 2 ‚Äî Errores comunes

Prueba a copiar el siguiente c√≥digo en el editor de *Processing* y ejecutarlo:
```java
Line(10, 0, 40, 50);
```

<details>
<summary>üí° Soluci√≥n</summary>
Processing es sensible al uso de may√∫sculas y min√∫sculas. Por ejemplo, la funci√≥n para dibujar una l√≠nea es `line`, no `Line` ni `LINE`.

Las palabras reservadas se muestran <span style="color:#1f77ff; font-weight:600;">resaltadas</span> en el editor, por lo que esta es una manera de ver si el nombre de una funci√≥n est√° bien escrito. Los <span style="color:#FF0000; font-weight:600;">errores</span> se muestran en la pesta√±a *Errores* de la ventana inferior.
</details>
:::

::: {.callout-note}
## üß™ Ejercicio 3 - M√∫ltiples formas geom√©tricas

Prueba a dibujar varias l√≠neas en diferentes posiciones de la pantalla, utilizando la instrucci√≥n `line` varias veces. 
:::

### Lienzo

Las figuras geom√©tricas se dibujan sobre un lienzo de tama√±o predeterminado 100x100 p√≠xeles. No obstante, es posible cambiar el tama√±o del lienzo utilizando la funci√≥n `size`, que recibe dos par√°metros: el ancho y el alto del lienzo en p√≠xeles.

::: {.callout-note}
## üß™ Ejercicio 4 - Tama√±o del lienzo 

Dibuja varias l√≠neas en un lienzo de tama√±o 300x200 p√≠xeles.

<details>
<summary>üí° Soluci√≥n</summary>
```java
size(300, 200);
line(10, 0, 40, 50);
line(100, 50, 200, 150);
line(250, 0, 250, 200);
```
</details>
:::

### Tipos de figuras geom√©tricas

Adem√°s de la l√≠nea utilizada en los ejercicios anteriores, *Processing* permite dibujar otras figuras geom√©tricas b√°sicas, tales como **puntos**, **tri√°ngulos**, **cuadril√°teros**, **rect√°ngulos** y **elipses**. 

::: {.callout-note}
## üß™ Ejercicio 5 - Deducci√≥n de par√°metros

¬øPuedes deducir qu√© par√°metros son necesarios para dibujar algunas de las figuras geom√©tricas mencionadas anteriormente?
Puedes consultar la [documentaci√≥n oficial de *Processing*](https://processing.org/reference#shape), y m√°s concretamente, la secci√≥n *2d primitives* en el apartado *Shape*.

<details>
<summary>üí° Soluci√≥n</summary>
- `point(x, y)`: un punto en la posici√≥n (x, y).
- `triangle(x1, y1, x2, y2, x3, y3)`: un tri√°ngulo con v√©rtices en las posiciones (x1, y1), (x2, y2) y (x3, y3).
- `quad(x1, y1, x2, y2, x3, y3, x4, y4)`: un cuadril√°tero con v√©rtices en las posiciones (x1, y1), (x2, y2), (x3, y3) y (x4, y4).
- `rect(x, y, anchura, altura)`: un rect√°ngulo con esquina superior izquierda en la posici√≥n (x, y), de anchura y altura especificadas.
- `ellipse(x, y, anchura, altura)`: una elipse centrada en la posici√≥n (x, y), con anchura y altura especificadas.
</details>
:::

#### Dibujando rect√°ngulos y elipses

Tanto en la documentaci√≥n oficial, como en la soluci√≥n del ejercicio anterior, os habr√©is podido dar cuenta de que las funciones `rect` y `ellipse` requieren cuatro par√°metros: **dos para la posici√≥n** y **dos para el tama√±o**. Sin embargo, hemos asumido que la posici√≥n siempre corresponde a la esquina superior izquierda del rect√°ngulo o al centro de la elipse. Esta suposici√≥n es correcta por defecto, pero es posible cambiarla utilizando las funciones `rectMode` y `ellipseMode`. M√°s concretamente, estas funciones permiten definir c√≥mo se interpretan las posiciones pasadas como par√°metros a las funciones `rect` y `ellipse`. Existen dos modos principales para cada una de estas funciones:

- `CORNER`: la posici√≥n corresponde a la esquina superior izquierda del rect√°ngulo o elipse.
- `CENTER`: la posici√≥n corresponde al centro del rect√°ngulo o elipse.

![Representaci√≥n de c√≥mo se interpretan las posiciones en ambos modos para rect√°ngulos y elipses.](../resources/lesson1/rect-mode.svg){#fig-rectmodes}

Por defecto, *Processing* interpreta las posiciones de la siguiente manera:
```java
rectMode(CORNER);
ellipseMode(CENTER);
```

Tambi√©n es posible cambiar esta interpretaci√≥n usando:

```java
rectMode(CENTER);
ellipseMode(CORNER);
```

::: {.callout-note}
## üß™ Ejercicio 6 - Modo de dibujo

Intenta dibujar un c√≠rculo centrado en (20, 30) con radio 10 utilizando ambos modos. En el siguiente c√≥digo tienes todas las instrucciones necesarias para completar el ejercicio:
```java
// Modo por defecto
ellipseMode(CENTER);
ellipse( , , , );

// Modo alternativo
ellipseMode(CORNER);
ellipse( , , , );
```
:::

## Color en *Processing*

### Escala de grises

::: {layout="[60,30]"}
::: {.column}
Hasta ahora, hemos dibujado figuras geom√©tricas sin especificar ning√∫n color. Por defecto, las figuras se dibujan en negro sobre un fondo blanco.

A continuaci√≥n, veremos c√≥mo especificar colores en *Processing*. Por ahora, basta con componer colores en escala de grises. Para ello hay que tener en cuenta que la escala de un tono de gris va de 0 a 255; el valor 0 corresponde al negro y el valor 255 corresponde al blanco. Por ejemplo, la figura de la derecha se ha representado √∫nica y exclusivamente con diferentes valores de gris.

En *Processing*, las figuras tienen **borde** y **relleno**, que se definen mediante los m√©todos `stroke` y `fill`. Adem√°s, tambi√©n puede controlarse el color de fondo de la ventana con `background`.
:::

::: {.column}
![Imagen representada √∫nicamente con valores de gris.](../resources/lesson1/grayscale.svg){#fig-grayscale}
:::
:::

Por ejemplo, podemos definir el color del fondo, as√≠ como del borde y el relleno de un rect√°ngulo de la siguiente manera:
```java
background(0);              // fondo 

stroke(200);                // borde
fill(100);                  // relleno
rect(50, 50, 100, 100);
```

Adem√°s, cabe destacar que *Processing* funciona como una **m√°quina de estados**; es decir, **una vez se indica el color de borde o de relleno, este se utilizar√° para todas las figuras que se dibujen a continuaci√≥n**. Por ejemplo, podemos dibujar dos rect√°ngulos con el mismo color de borde, pero diferente color de relleno, de la siguiente manera:
```java
stroke(0);
fill(150);
rect(20, 20, 50, 50);       // borde negro, relleno gris

fill(50);
rect(80, 20, 50, 50);       // mismo borde, diferente relleno
```

::: {layout="[50, 50]"}

::: {.column}
::: {.callout-note}
## üß™ Ejercicio 7 - C√≠rculo y colores

Dibuja un c√≠rculo negro con borde gris, centrado en (20, 30) y con radio 10.

<details>
<summary>üí° Soluci√≥n</summary>
```java
stroke(128);
fill(0);
ellipse(20, 30, 20, 20);
```
</details>
:::
:::

::: {.column}
::: {.callout-note}
## üß™ Ejercicio 8 - Dibuja una forma geom√©trica

Trata de obtener algo parecido a la figura que se muestra debajo.

![](../resources/lesson1/render.png){width="40%" fig-align="center"}
:::
:::
:::


### Colores RGB (red, green, blue)

::: {layout="[30,70]"}
::: {.column}
![Representaci√≥n de los colores primarios RGB.](../resources/lesson1/primary-colors.png){#fig-rgb}
:::

::: {.column}
Adem√°s de diferentes tonos de gris, *Processing* permite definir colores a partir de los tres colores primarios: rojo, verde y azul (RGB). Cuando los tres componentes toman el valor m√°ximo (255), el color resultante es el blanco. En una escala de grises, los tres valores RGB coinciden; por ejemplo, el color (0, 0, 0) corresponde al negro. Por otro lado, si s√≥lo activamos un canal con 255, y dejamos el resto a 0, obtenemos rojo, verde o azul.

```java
fill(255, 0, 0);  // rojo
fill(0, 255, 0);  // verde
fill(0, 0, 255);  // azul
```
:::
:::

::: {.callout-note}
## üß™ Ejercicio 9 - Colores RGB

¬øSabr√≠as decir qu√© colores crear√°n las siguientes combinaciones de rojo, verde y azul?

- `fill(255, 255, 0)`
- `fill(0, 255, 255)`
- `fill(255, 0, 255)`
- `fill(255, 255, 127)`
- `fill(127, 255, 255)`
- `fill(255, 127, 255)`

**Pista**: f√≠jate en la @fig-rgb.
:::

::: {layout="[40, 50]"}
::: {.column}
![Captura de pantalla del selector de color de *Processing*.](../resources/lesson1/hsv-picker.png){#fig-colorpicker}
:::

::: {.column}
Como habr√©is podido observar a partir del Ejercicio 9, no es sencillo imaginar qu√© color genera una mezcla concreta de valores RGB, ni determinar qu√© valores exactos u aproximados de rojo, verde y azul necesitamos para componer un color que tengamos en mente. Por esta raz√≥n, *Processing* dispone de una herramienta, ***Selector de color***, que permite interactuar con una paleta de colores y obtener valores de rojo, verde y azul. Pod√©is acceder a esta herramienta desde el men√∫ **Herramientas > Selector de color**.
:::
:::

### Opacidad

Adem√°s de los canales R, G y B, tambi√©n podemos indicar un valor de **opacidad**. De esta manera, un valor de opacidad de 255 indica que elemento a dibujar es completamente opaco, y un valor de 0 indica que es completamente transparente. Para especificar la opacidad, bastante con indicar un cuarto valor en operaciones como `stroke` o `fill`.

```java
fill(255, 255, 127);
rect(50, 50, 100, 100);     // rect√°ngulo opaco     

fill(255, 0, 127, 127);     
rect(20, 20, 50, 50);       // rect√°ngulo semitransparente
```

## Programas din√°micos

Hasta este momento, hemos escrito programas est√°ticos, es decir, programas que dibujan una imagen fija. A continuaci√≥n, veremos c√≥mo crear programas din√°micos que pueden cambiar con el tiempo.

::: {layout="[60,40]"}
::: {.column}
Comenzaremos con este bloque de c√≥digo:
```java
size(600, 600);

// Pinta un fondo blanco
background(255);

// Fija las coordenadas basadas en el centro
ellipseMode(CENTER);
rectMode(CENTER);

// Dibuja el cuerpo
stroke(0);
fill(150);
rect(200, 250, 53, 267);

// Dibuja la cabeza
fill(255);
ellipse(200, 170, 133, 160);

// Dibuja los ojos
fill(0);
ellipse(167, 170, 33, 67);
ellipse(233, 170, 33, 67);

// Dibuja las piernas
stroke(0);
line(173, 383, 147, 410);
line(227, 383, 253, 410);
```
:::

::: {.column}
![Imagen del alien√≠gena Zoog.](../resources/lesson1/zoog.png){#fig-zoog}

::: {.callout-note}
## üß™ Ejercicio 10 - Dibuja a Zoog
Intenta dibujar al alien√≠gena Zoog utilizando el bloque de c√≥digo anterior como referencia.
:::
:::
:::

### Comentarios

Aprovechando que nuestro programa empieza a ser un poco m√°s largo, es recomendable a√±adir comentarios para explicar qu√© hace cada parte del c√≥digo. En *Processing*, los comentarios se indican con `//` para comentarios de una sola l√≠nea, o con `/*` y `*/` para comentarios multil√≠nea. Adem√°s de para indicar qu√© hace una parte de nuestro c√≥digo, tambi√©n se pueden usar para desactivar temporalmente l√≠neas de c√≥digo durante la depuraci√≥n. Por ejemplo, en el siguiente c√≥digo se han a√±adido comentarios para explicar qu√© parte del cuerpo de Zoog dibuja cada bloque de instrucciones, y para desactivar el dibujo de la cabeza temporalmente:

```java
// Dibuja el cuerpo de Zoog
rect(200, 250, 53, 267);

/* Dibuja la cabeza de Zoog en la posici√≥n (200, 140) con ancho y alto 120 */
//ellipse(200, 170, 133, 160);        // Desactivado temporalmente

// Dibuja los ojos de Zoog
/**ellipse(167, 170, 33, 67);
ellipse(233, 170, 33, 67);**/         // Ojo derecho
```

### Funciones `setup` y `draw`

Cuando ejecutamos un programa en *Processing*, el c√≥digo no se ejecuta de arriba a abajo una sola vez, sino que utiliza un modelo de ejecuci√≥n basado en dos fases bien diferenciadas: `setup()` y `draw()`.

::: {layout="[70, 30]"}
::: {.column}
- Al pulsar el bot√≥n ‚ñ∂Ô∏è, *Processing* inicia el programa y lo primero que hace es llamar a la funci√≥n `setup()`.
- **La funci√≥n `setup()` se ejecuta una √∫nica vez al comienzo del programa**. Su objetivo es preparar el entorno antes de empezar a dibujar. En esta funci√≥n se suele definir el tama√±o de la ventana, inicializar variables, configurar colores o modos de dibujo y cargar recursos como im√°genes o fuentes. **Una vez que `setup()` termina, *Processing* no vuelve a ejecutarla**.
- Despu√©s de `setup()`, *Processing* entra autom√°ticamente en la funci√≥n `draw()`. **La funci√≥n `draw()` se ejecuta repetidamente**, normalmente unas sesenta veces por segundo. **En cada ejecuci√≥n se dibuja un nuevo fotograma y se actualizan posiciones o estados**. Gracias a este bucle continuo es posible crear animaciones, juegos y visualizaciones interactivas.

![Analog√≠a del funcionamiento de *Processing*, y el proceso de animaci√≥n. El resultado final se compone de varias llamadas a `draw`, y en cada llamada, se dibujan m√∫ltiples tipos de geometr√≠a.](../resources/lesson1/disney-animation.svg){#fig-disney-animation}
::: 

::: {.column .centered}
```{mermaid}
flowchart TD
    A["El programa comienza"]
    B["setup()"]
    C["Inicializa ventana y variables"]
    D["setup() termina"]
    E["draw()"]
    F["Dibuja un fotograma"]
    G["Actualiza estado"]

    A --> B
    B --> C
    C --> D
    D --> E
    E --> F
    F --> G
    G --> E
```
:::
:::

Tanto `setup` como `draw` son funciones especiales que no requieren ser llamadas expl√≠citamente en el c√≥digo; *Processing* se encarga de ello autom√°ticamente. Por ahora, s√≥lo cabe destacar que el c√≥digo que se encuentra dentro de una funci√≥n debe estar **sangrado** (indentado) para indicar que pertenece a dicha funci√≥n. Adem√°s, ambas funciones devuelven `void`, lo que significa que no devuelven ning√∫n valor. Tambi√©n es importante abrir y cerrar llaves `{}` para definir el bloque de c√≥digo que pertenece a cada funci√≥n.

::: {.grid}
::: {.g-col-4}
![Inicializa ventana y variables](../resources/lesson1/processing-setup.png){#fig-processing-setup}
:::

::: {.g-col-4}
![Dibuja un fotograma](../resources/lesson1/processing-draw.png){#fig-processing-draw}
:::

::: {.g-col-4}
![Fin de la animaci√≥n](../resources/lesson1/processing-finished.png){#fig-processing-finished}
:::
:::


::: {.callout-note}
## üß™ Ejercicio 11 - Zoog, utilizando `setup` y `draw`

Reescribe el c√≥digo de Zoog utilizando las funciones `setup` y `draw`. **¬øNotas alguna diferencia en el resultado respecto al c√≥digo original?**

```java
void setup() {
    // Tama√±o del lienzo
    size(600, 600);
}

void draw() {
    // Pinta un fondo blanco
    background(255);

    // Fija las coordenadas basadas en el centro
    ellipseMode(CENTER);
    rectMode(CENTER);

    // Dibuja el cuerpo
    stroke(0);
    fill(150);
    rect(200, 250, 53, 267);

    // Dibuja la cabeza
    fill(255);
    ellipse(200, 170, 133, 160);

    // Dibuja los ojos
    fill(0);
    ellipse(167, 170, 33, 67);
    ellipse(233, 170, 33, 67);

    // Dibuja las piernas
    stroke(0);
    line(173, 383, 147, 410);
    line(227, 383, 253, 410);
}
```
:::

::: {.callout-warning}
## üî¥ Color de fondo 

Prueba a mover la instrucci√≥n `background(255);` desde la funci√≥n `draw` a la funci√≥n `setup`. **¬øQu√© ocurre?**
:::

### Interacci√≥n con el rat√≥n

En *Processing* existen algunas **palabras reservadas** como `width` y `height`, que permiten acceder al ancho y alto de la ventana, respectivamente, y otras que permiten interactuar con el usuario, como `mouseX` y `mouseY`, que indican la **posici√≥n actual del rat√≥n en la ventana**.

::: {.callout-note}
## üß™ Ejercicio 12 - Sigue al rat√≥n

Modifica el programa de Zoog para que la esquina superior izquierda del cuerpo de Zoog sea la posici√≥n del rat√≥n, utilizando `mouseX` y `mouseY`.
:::

::: {.callout-note}
## üß™ Ejercicio 13 - Sigue al rat√≥n II

Centra la cabeza de Zoog en la posici√≥n (`mouseX`, `mouseY` - 30), de manera que la cabeza se mueva en funci√≥n de la posici√≥n del rat√≥n, pero siempre est√© situada por encima del cuerpo. Por supuesto, tendr√°s que ajustar tambi√©n la posici√≥n de los ojos.
:::

::: {.callout-note}
## üß™ Ejercicio extra - Sigue al rat√≥n III
Intenta que las piernas de Zoog tambi√©n sigan al rat√≥n, manteniendo la misma distancia relativa con el cuerpo.
:::

## Variables, condicionales y bucles

### Introducci√≥n a variables

En la secci√≥n anterior hemos descubierto que el m√©todo `draw` se ejecuta de manera repetitiva en un bucle infinito. Esto nos permite crear programas din√°micos que cambian con el tiempo. Sin embargo, para crear programas m√°s complejos, es necesario utilizar **variables** para almacenar datos que pueden cambiar durante la ejecuci√≥n del programa.

::: {.callout-note}
## üß™ Ejercicio 14 - Traslada una esfera

Crea un programa que traslade una esfera de izquierda a derecha en la ventana. Utiliza una variable para almacenar la posici√≥n horizontal de la esfera, y actual√≠zala en cada iteraci√≥n del bucle `draw`.

<details>
<summary>üí° Soluci√≥n</summary>
```java
int circleX = 100;
int circleY = 100;

void setup() {
  size(200, 200);
}

void draw() {
  background(255);
  stroke(0);
  fill(175);
  ellipse(circleX, circleY, 50, 50);
  circleX = circleX + 1;
}
```
</details>
:::

### Condicionales

Los **condicionales** permiten ejecutar **diferentes bloques de c√≥digo** en funci√≥n de **si se cumple o no una determinada condici√≥n**. En *Processing*, los condicionales se implementan utilizando las palabras reservadas `if`, `else if` y `else`.

La sintaxis b√°sica de un condicional es la siguiente:
```java
if (condici√≥n) {
  // bloque de c√≥digo si la condici√≥n es verdadera
} else if (otra_condici√≥n) {
  // bloque de c√≥digo si la otra condici√≥n es verdadera
} else {
  // bloque de c√≥digo si ninguna condici√≥n es verdadera
}
```

Ten en cuenta que no siempre es necesario utilizar `else if` o `else`; **un condicional puede consistir √∫nicamente en una instrucci√≥n `if`**.

::: {.callout-note}
## üß™ Ejercicio 15 - Color de fondo interactivo

Modifica el programa de Zoog para que el color de fondo cambie en funci√≥n de la posici√≥n del rat√≥n. Por ejemplo, si el rat√≥n se encuentra en el primer tercio de la ventana, el fondo debe ser blanco; si est√° en el segundo tercio, el fondo debe ser gris; y si est√° en el tercer tercio, el fondo debe ser negro.

üí° **Pista**: en el c√≥digo que hemos utilizado para dibujar a Zoog se define una ventana de tama√±o 600x600. Puedes comprobar si `mouseX` o `mouseY` se encuentran en un determinado tercio de la pantalla:
```java
if (mouseX < 200) {
    ...
}
else if (...) {
    ...
}
else {
    ...
}
```
:::

### Bucles

Existen algunas palabras reservadas en *Java* para representar **bucles**, es decir, **bloques de c√≥digo que se repiten durante un n√∫mero de iteraciones, o infinitamente hasta que no se cumpla alguna condici√≥n**. 

En esta sesi√≥n es suficiente con conocer el bucle `for`, que permite ejecutar un bloque de c√≥digo un n√∫mero determinado de veces. La sintaxis b√°sica de un bucle `for` es la siguiente:
```java
for (int i = 1; i <= N; i++) {
  // bloque de c√≥digo a ejecutar N veces
}
```

---

::: {.callout-note}
### üß™ Ejercicio 16 - M√∫ltiples Zoog

El objetivo es mostrar 2 Zoogs en la pantalla a partir del programa de un √∫nico Zoog. Ten en cuenta que tendr√°s que modificar la posici√≥n de al menos uno de ellos para que sea visible.

**A modo de inspiraci√≥n**, el siguiente c√≥digo dibuja dos rect√°ngulos desplazados en el eje horizontal y vertical en funci√≥n de *i*:
```java
size(500, 200);

int N = 2;
float offsetX = 0;
float offsetY = 0;

for (int i = 1; i <= N; i++) {
  rect(50 + offsetX, 20 + offsetY, 80, 80);

  offsetX += 100;
  offsetY += 10;
}
```
:::

::: {layout="[70,30]"}
::: {.column}
::: {.callout-note}
### üß™ Ejercicio 17 - Z pares de brazos

Modifica el programa de Zoog para que dibuje *Z* pares de brazos, donde *Z* es una variable que puedes definir al principio del programa. Utiliza un bucle `for` para dibujar los brazos.
:::
:::
::: {.column}
![Resultado de a√±adir 3 pares de brazos a Zoog.](../resources/lesson1/zoog-arms.png){#fig-zoog-multiple-arms}
:::
:::

## Ap√©ndice: Instalaci√≥n de Processing {.unnumbered}

![Banner de la p√°gina oficial de *Processing*; a la izquierda se muestra el bot√≥n de *Download*.](../resources/lesson1/web-teaser.png){#fig-installation}

- Accede a [la p√°gina oficial de *Processing*](http://processing.org) y selecciona **Download**.
- Descarga la versi√≥n correspondiente a tu sistema operativo.
- Ejecuta el instalador descargado y sigue las instrucciones.

