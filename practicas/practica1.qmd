---
title: "Pr치ctica 1: Introducci칩n a Processing"
format:
  html: 
    toc: true
    number-sections: true
  revealjs: 
    output-ext: "reveal.html"
---

## Objetivos de la pr치ctica

Los objetivos de esta pr치ctica son los siguientes:

- Familiarizaci칩n con el ordenador y los elementos b치sicos de un sistema operativo.
- Familiarizaci칩n con el entorno de desarrollo *Processing*.
- Familiarizaci칩n con aspectos b치sicos de programaci칩n a trav칠s de programas en *Processing*.

---

## Processing

### Introducci칩n

::: {layout="[75,25]"}
::: {.column}
*Processing* es un lenguaje de programaci칩n y un entorno de desarrollo (*Integrated Development Environment*, IDE).

- **Basado en Java**.
- **Producci칩n de proyectos multimedia e interactivos**.
- Creado por cient칤ficos del MIT en 2001.
- Distribuci칩n gratuita y de c칩digo abierto.
:::
::: {.column}
![](../resources/practica1/processing.svg)
:::
:::

---

La propia [p치gina de Processing](https://processing.org/examples/) muestra numerosos ejemplos de proyectos realizados con este lenguaje. Tambi칠n hay muchos ejemplos en Youtube, en particular, en el canal de [The Coding Train](https://www.youtube.com/c/TheCodingTrain).

::: {layout="[50,50]"}
::: {.column}
![Visualizaci칩n del [fractal de Mandelbrot](https://processing.org/examples/mandelbrot.html).](../resources/practica1/processing-example.png){#fig-mandelbrot}
:::
::: {.column}
![Canal de Youtube [The Coding Train](https://www.youtube.com/c/TheCodingTrain).](../resources/practica1/thecodetrain.gif){#fig-thecodetrain}
:::
:::

---

### El entorno de desarrollo

El entorno de desarrollo de *Processing* tiene un dise침o minimalista que facilita su uso. La interfaz gr치fica est치 compuesta por los siguientes elementos principales:

- **Un men칰 de opciones** (archivo, editar, sketch, depuraci칩n, herramientas y ayuda).
- **Dos botones para ejecutar y detener el programa.**
- Un 치rea central para escribir el c칩digo fuente (**editor**).
- Una ventana inferior donde se muestran dos pesta침as:
  - **Consola**: salida est치ndar del programa.
  - **Errores**: mensajes de error generados durante la ejecuci칩n.

---

Al ejecutar un programa se abrir치 una **nueva ventana donde se mostrar치 el resultado de la ejecuci칩n**.

![Vista del entorno de desarrollo (derecha) y ventana *pop-up* (izquierda) que redirige a ejemplos disponibles en su p치gina web.](../resources/practica1/ide.png){#fig-ide}

---

::: {.callout-warning}
El primer archivo que se crea en un nuevo proyecto de *Processing* se denomina `sketch_yymmdda`. Es recomendable cambiar el nombre del archivo para que tenga sentido con el programa que se va a desarrollar. Adem치s, al guardarlo nos preguntar치 el nombre del proyecto, que tambi칠n es recomendable que tenga sentido. 

Indicad una ubicaci칩n de f치cil acceso en vuestro ordenador para guardar los proyectos de *Processing*.
:::

---

## Dibujando figuras geom칠tricas

Las figuras geom칠tricas se dibujan en una ventana que est치 formada por una **matriz de p칤xeles**. Cada p칤xel es un peque침o punto de luz que puede tener un color diferente. La combinaci칩n de todos los p칤xeles forma la imagen que vemos en la pantalla.

---

Un p칤xel es la **unidad m치s peque침a de una imagen digital**. La resoluci칩n de una imagen se refiere a la cantidad de p칤xeles que contiene, y se expresa como el n칰mero de p칤xeles en el eje horizontal por el n칰mero de p칤xeles en el eje vertical (por ejemplo, 1920x1080 p칤xeles). Por ejemplo, la @fig-highres muestra una animaci칩n con una resoluci칩n alta, donde los p칤xeles no son visibles a simple vista. En cambio, en la @fig-lowres se ha reducido la resoluci칩n de la animaci칩n, y comienzan a ser visibles los p칤xeles individuales.

::: {layout="[50,50]"}
::: {.column}
![Animaci칩n con una resoluci칩n de pantalla alta.](../resources/practica1/animation_pixels.webm){#fig-highres}
:::

::: {.column}
![Animaci칩n con una resoluci칩n de pantalla m치s baja, donde comienzan a ser visibles los p칤xeles.](../resources/practica1/animation_pixels_lowerres.webm){#fig-lowres}
:::
:::

---

::: {layout="[68,32]"}
::: {.column}
Para dibujar cualquier figura geom칠trica, es necesario especificar una o varias posiciones en la ventana. Dichas posiciones se definen mediante un par de coordenadas ***(x, y)***, donde ***x*** indica la **posici칩n horizontal** e ***y*** la **posici칩n vertical**. En *Processing*, **el origen de coordenadas (0,0) se encuentra en la esquina superior izquierda de la ventana**, como se muestra en la @fig-pixels.

::: {.callout-note}
## 游 Ejercicio 1 - Sistema de coordenadas

Dibuja una l칤nea que va desde la posici칩n (10, 0) hasta la posici칩n (40, 50). Cuando se ejecute, os podr칠is dar cuenta de que el origen, (0,0), parte de la esquina superior izquierda.
```java
line(10, 0, 40, 50);
```
:::
:::
::: {.column}
![Ilustraci칩n de una matriz de p칤xeles, indicando las coordenadas de algunos de ellos.](../resources/practica1/pixel-matrix.svg){#fig-pixels}
:::
:::

---

Este concepto puede entenderse como **darle un nombre a un conjunto de instrucciones para poder reutilizarlas f치cilmente** m치s adelante. En **matem치ticas**, una funci칩n toma uno o varios valores de entrada y produce un valor de salida siguiendo una regla. Por ejemplo, la funci칩n $f(x) = x^2$ toma un n칰mero $x$ y devuelve su cuadrado.

En programaci칩n ocurre algo muy similar: una funci칩n recibe unos par치metros, ejecuta unas instrucciones con ellos y, opcionalmente, devuelve un resultado.

---

Por ejemplo, podemos definir en Java una funci칩n que reciba un n칰mero entero y devuelva su cuadrado:
```java
int square(int x) {
  return x * x;
}
```

Una vez definida, podemos usar la funci칩n tantas veces como queramos, simplemente indicando el valor de entrada:
```java
int result = square(5);  // result tendr치 el valor 25
```

De este modo:

- `square` es el nombre de la funci칩n.
- `x` es el par치metro de entrada.
- `return` indica el valor que devuelve la funci칩n.

En *Processing* ocurre exactamente lo mismo. La funci칩n `line`, por ejemplo, recibe cuatro par치metros (las coordenadas de dos puntos) y ejecuta una acci칩n: dibujar una l칤nea en la ventana. La diferencia es que, en este caso, la funci칩n no devuelve un valor, sino que produce un efecto visual en pantalla.

---

::: {.callout-warning}
## Ejercicio 2 - Errores comunes

Prueba a copiar el siguiente c칩digo en el editor de *Processing* y ejecutarlo:
```java
Line(10, 0, 40, 50);
```

<details>
<summary>游눠 Soluci칩n</summary>
Processing es sensible al uso de may칰sculas y min칰sculas. Por ejemplo, la funci칩n para dibujar una l칤nea es `line`, no `Line` ni `LINE`.

Las palabras reservadas se muestran <span style="color:#1f77ff; font-weight:600;">resaltadas</span> en el editor, por lo que esta es una manera de ver si el nombre de una funci칩n est치 bien escrito. Los <span style="color:#FF0000; font-weight:600;">errores</span> se muestran en la pesta침a *Errores* de la ventana inferior.
</details>
:::

::: {.callout-note}
## 游 Ejercicio 3 - M칰ltiples formas geom칠tricas

Prueba a dibujar varias l칤neas en diferentes posiciones de la pantalla, utilizando la instrucci칩n `line` varias veces. 
:::

---

### Lienzo

Las figuras geom칠tricas se dibujan sobre un lienzo de tama침o predeterminado 100x100 p칤xeles. No obstante, es posible cambiar el tama침o del lienzo utilizando la funci칩n `size`, que recibe dos par치metros: el ancho y el alto del lienzo en p칤xeles.

::: {.callout-note}
## 游 Ejercicio 4 - Tama침o del lienzo 

Dibuja varias l칤neas en un lienzo de tama침o 300x200 p칤xeles.

<details>
<summary>游눠 Soluci칩n</summary>
```java
size(300, 200);
line(10, 0, 40, 50);
line(100, 50, 200, 150);
line(250, 0, 250, 200);
```
</details>
:::

---

### Tipos de figuras geom칠tricas

Adem치s de la l칤nea utilizada en los ejercicios anteriores, *Processing* permite dibujar otras figuras geom칠tricas b치sicas, tales como **puntos**, **tri치ngulos**, **cuadril치teros**, **rect치ngulos** y **elipses**. 

::: {.callout-note}
## 游 Ejercicio 5 - Deducci칩n de par치metros

쯇uedes deducir qu칠 par치metros son necesarios para dibujar algunas de las figuras geom칠tricas mencionadas anteriormente?
Puedes consultar la [documentaci칩n oficial de *Processing*](https://processing.org/reference#shape), y m치s concretamente, la secci칩n *2d primitives* en el apartado *Shape*.

<details>
<summary>游눠 Soluci칩n</summary>
- `point(x, y)`: un punto en la posici칩n (x, y).
- `triangle(x1, y1, x2, y2, x3, y3)`: un tri치ngulo con v칠rtices en las posiciones (x1, y1), (x2, y2) y (x3, y3).
- `quad(x1, y1, x2, y2, x3, y3, x4, y4)`: un cuadril치tero con v칠rtices en las posiciones (x1, y1), (x2, y2), (x3, y3) y (x4, y4).
- `rect(x, y, anchura, altura)`: un rect치ngulo con esquina superior izquierda en la posici칩n (x, y), de anchura y altura especificadas.
- `ellipse(x, y, anchura, altura)`: una elipse centrada en la posici칩n (x, y), con anchura y altura especificadas.
</details>
:::

---

#### Dibujando rect치ngulos y elipses

Tanto en la documentaci칩n oficial, como en la soluci칩n del ejercicio anterior, os habr칠is podido dar cuenta de que las funciones `rect` y `ellipse` requieren cuatro par치metros: **dos para la posici칩n** y **dos para el tama침o**. Sin embargo, hemos asumido que la posici칩n siempre corresponde a la esquina superior izquierda del rect치ngulo o al centro de la elipse. Esta suposici칩n es correcta por defecto, pero es posible cambiarla utilizando las funciones `rectMode` y `ellipseMode`. M치s concretamente, estas funciones permiten definir c칩mo se interpretan las posiciones pasadas como par치metros a las funciones `rect` y `ellipse`. Existen dos modos principales para cada una de estas funciones:

- `CORNER`: la posici칩n corresponde a la esquina superior izquierda del rect치ngulo o elipse.
- `CENTER`: la posici칩n corresponde al centro del rect치ngulo o elipse.

---

![Representaci칩n de c칩mo se interpretan las posiciones en ambos modos para rect치ngulos y elipses.](../resources/practica1/rect-mode.svg){#fig-rectmodes}

---

Por defecto, *Processing* interpreta las posiciones de la siguiente manera:
```java
rectMode(CORNER);
ellipseMode(CENTER);
```

Tambi칠n es posible cambiar esta interpretaci칩n usando:

```java
rectMode(CENTER);
ellipseMode(CORNER);
```

::: {.callout-note}
## 游 Ejercicio 6 - Modo de dibujo

Intenta dibujar un c칤rculo centrado en (20, 30) con radio 10 utilizando ambos modos. En el siguiente c칩digo tienes todas las instrucciones necesarias para completar el ejercicio:
```java
// Modo por defecto
ellipseMode(CENTER);
ellipse( , , , );

// Modo alternativo
ellipseMode(CORNER);
ellipse( , , , );
```
:::

---

## Color en *Processing*

### Escala de grises

::: {layout="[60,30]"}
::: {.column}
Hasta ahora, hemos dibujado figuras geom칠tricas sin especificar ning칰n color. Por defecto, las figuras se dibujan en negro sobre un fondo blanco.

A continuaci칩n, veremos c칩mo especificar colores en *Processing*. Por ahora, basta con componer colores en escala de grises. Para ello hay que tener en cuenta que la escala de un tono de gris va de 0 a 255; el valor 0 corresponde al negro y el valor 255 corresponde al blanco. Por ejemplo, la figura de la derecha se ha representado 칰nica y exclusivamente con diferentes valores de gris.

En *Processing*, las figuras tienen **borde** y **relleno**, que se definen mediante los m칠todos `stroke` y `fill`. Adem치s, tambi칠n puede controlarse el color de fondo de la ventana con `background`.
:::

::: {.column}
![Imagen representada 칰nicamente con valores de gris.](../resources/practica1/grayscale.svg){#fig-grayscale}
:::
:::

---

Por ejemplo, podemos definir el color del fondo, as칤 como del borde y el relleno de un rect치ngulo de la siguiente manera:
```java
background(0);              // fondo 

stroke(200);                // borde
fill(100);                  // relleno
rect(50, 50, 100, 100);
```

Adem치s, cabe destacar que *Processing* funciona como una **m치quina de estados**; es decir, **una vez se indica el color de borde o de relleno, este se utilizar치 para todas las figuras que se dibujen a continuaci칩n**. Por ejemplo, podemos dibujar dos rect치ngulos con el mismo color de borde, pero diferente color de relleno, de la siguiente manera:
```java
stroke(0);
fill(150);
rect(20, 20, 50, 50);       // borde negro, relleno gris

fill(50);
rect(80, 20, 50, 50);       // mismo borde, diferente relleno
```

---

::: {layout="[50, 50]"}

::: {.column}
::: {.callout-note}
## 游 Ejercicio 7 - C칤rculo y colores

Dibuja un c칤rculo negro con borde gris, centrado en (20, 30) y con radio 10.

<details>
<summary>游눠 Soluci칩n</summary>
```java
stroke(128);
fill(0);
ellipse(20, 30, 20, 20);
```
</details>
:::

Intenta crear un lienzo de tama침o 30x30 y repite este ejercicio. **쯈u칠 sucede ahora?**
:::

::: {.column}
::: {.callout-note}
## 游 Ejercicio 8 - Dibuja una forma geom칠trica

Trata de obtener algo parecido a la figura que se muestra debajo.

![](../resources/practica1/render.png){width="40%" fig-align="center"}
:::
:::
:::

---

### Colores RGB (red, green, blue)

::: {layout="[30,70]"}
::: {.column}
![Representaci칩n de los colores primarios RGB.](../resources/practica1/primary-colors.png){#fig-rgb}
:::

::: {.column}
Adem치s de diferentes tonos de gris, *Processing* permite definir colores a partir de los tres colores primarios: rojo, verde y azul (RGB). Cuando los tres componentes toman el valor m치ximo (255), el color resultante es el blanco. En una escala de grises, los tres valores RGB coinciden; por ejemplo, el color (0, 0, 0) corresponde al negro. Por otro lado, si s칩lo activamos un canal con 255, y dejamos el resto a 0, obtenemos rojo, verde o azul.

```java
fill(255, 0, 0);  // rojo
fill(0, 255, 0);  // verde
fill(0, 0, 255);  // azul
```
:::
:::

::: {.callout-note}
## 游 Ejercicio 9 - Colores RGB

쯉abr칤as decir qu칠 colores crear치n las siguientes combinaciones de rojo, verde y azul?

- `fill(255, 255, 0)`
- `fill(0, 255, 255)`
- `fill(255, 0, 255)`
- `fill(255, 255, 127)`
- `fill(127, 255, 255)`
- `fill(255, 127, 255)`

**Pista**: f칤jate en la @fig-rgb.
:::

---

::: {layout="[40, 50]"}
::: {.column}
![Captura de pantalla del selector de color de *Processing*.](../resources/practica1/hsv-picker.png){#fig-colorpicker}
:::

::: {.column}
Como habr칠is podido observar a partir del Ejercicio 9, no es sencillo imaginar qu칠 color genera una mezcla concreta de valores RGB, ni determinar qu칠 valores exactos u aproximados de rojo, verde y azul necesitamos para componer un color que tengamos en mente. Por esta raz칩n, *Processing* dispone de una herramienta, ***Selector de color***, que permite interactuar con una paleta de colores y obtener valores de rojo, verde y azul. Pod칠is acceder a esta herramienta desde el men칰 **Herramientas > Selector de color**.
:::
:::

---

### Opacidad

Adem치s de los canales R, G y B, tambi칠n podemos indicar un valor de **opacidad**. De esta manera, un valor de opacidad de 255 indica que elemento a dibujar es completamente opaco, y un valor de 0 indica que es completamente transparente. Para especificar la opacidad, bastante con indicar un cuarto valor en operaciones como `stroke` o `fill`.

```java
fill(255, 255, 127);
rect(50, 50, 100, 100);     // rect치ngulo opaco     

fill(255, 0, 127, 127);     
rect(20, 20, 50, 50);       // rect치ngulo semitransparente
```

---

## Programas din치micos

Hasta este momento, hemos escrito programas est치ticos, es decir, programas que dibujan una imagen fija. A continuaci칩n, veremos c칩mo crear programas din치micos que pueden cambiar con el tiempo.

--- 

::: {layout="[60,40]"}
::: {.column}
Comenzaremos con este bloque de c칩digo:
```java
size(600, 600);

// Fondo blanco
background(255);

// Coordenadas desde el centro
ellipseMode(CENTER);
rectMode(CENTER);

// CUERPO
stroke(0);
fill(150);
rect(200, 260, 50, 260);

// CABEZA
fill(255);
ellipse(200, 160, 130, 160);

// OJOS
fill(0);
ellipse(170, 160, 30, 60);
ellipse(230, 160, 30, 60);

// PIERNAS
stroke(0);
line(175, 390, 150, 420);
line(226, 390, 250, 420);
```
:::

::: {.column}
![Imagen del alien칤gena Zoog.](../resources/practica1/zoog.png){#fig-zoog}

::: {.callout-note}
## 游 Ejercicio 10 - Dibuja a Zoog
Intenta dibujar al alien칤gena Zoog utilizando el bloque de c칩digo anterior como referencia.
:::
:::
:::

---

### Comentarios

Aprovechando que nuestro programa empieza a ser un poco m치s largo, es recomendable a침adir comentarios para explicar qu칠 hace cada parte del c칩digo. En *Processing*, los comentarios se indican con `//` para comentarios de una sola l칤nea, o con `/*` y `*/` para comentarios multil칤nea. Adem치s de para indicar qu칠 hace una parte de nuestro c칩digo, tambi칠n se pueden usar para desactivar temporalmente l칤neas de c칩digo durante la depuraci칩n. Por ejemplo, en el siguiente c칩digo se han a침adido comentarios para explicar qu칠 parte del cuerpo de Zoog dibuja cada bloque de instrucciones, y para desactivar el dibujo de la cabeza temporalmente:

```java
// Dibuja el cuerpo de Zoog
rect(200, 260, 50, 260);

/* Dibuja la cabeza de Zoog en la posici칩n (200, 140) con ancho y alto 120 */
//ellipse(200, 160, 130, 160);        // Desactivado temporalmente

// Dibuja los ojos de Zoog
/*ellipse(170, 160, 30, 60);
ellipse(230, 160, 30, 60);*/          // Ojo derecho
```

---

### Funciones `setup` y `draw`

Cuando ejecutamos un programa en *Processing*, el c칩digo no se ejecuta de arriba a abajo una sola vez, sino que utiliza un modelo de ejecuci칩n basado en dos fases bien diferenciadas: `setup()` y `draw()`.

---

::: {layout="[70, 30]"}
::: {.column}
- Al pulsar el bot칩n 郊윒잺, *Processing* inicia el programa y lo primero que hace es llamar a la funci칩n `setup()`.
- **La funci칩n `setup()` se ejecuta una 칰nica vez al comienzo del programa**. Su objetivo es preparar el entorno antes de empezar a dibujar. En esta funci칩n se suele definir el tama침o de la ventana, inicializar variables, configurar colores o modos de dibujo y cargar recursos como im치genes o fuentes. **Una vez que `setup()` termina, *Processing* no vuelve a ejecutarla**.
- Despu칠s de `setup()`, *Processing* entra autom치ticamente en la funci칩n `draw()`. **La funci칩n `draw()` se ejecuta repetidamente**, normalmente unas sesenta veces por segundo. **En cada ejecuci칩n se dibuja un nuevo fotograma y se actualizan posiciones o estados**. Gracias a este bucle continuo es posible crear animaciones, juegos y visualizaciones interactivas.

![Analog칤a del funcionamiento de *Processing*, y el proceso de animaci칩n. El resultado final se compone de varias llamadas a `draw`, y en cada llamada, se dibujan m칰ltiples tipos de geometr칤a.](../resources/practica1/disney-animation.svg){#fig-disney-animation}
::: 

::: {.column .centered}
```{mermaid}
flowchart TD
    A["El programa comienza"]
    B["setup()"]
    C["Inicializa ventana y variables"]
    D["setup() termina"]
    E["draw()"]
    F["Dibuja un fotograma"]
    G["Actualiza estado"]

    A --> B
    B --> C
    C --> D
    D --> E
    E --> F
    F --> G
    G --> E
```
:::
:::

---

Tanto `setup` como `draw` son funciones especiales que no requieren ser llamadas expl칤citamente en el c칩digo; *Processing* se encarga de ello autom치ticamente. Por ahora, s칩lo cabe destacar que el c칩digo que se encuentra dentro de una funci칩n debe estar **sangrado** (indentado) para indicar que pertenece a dicha funci칩n. Adem치s, ambas funciones devuelven `void`, lo que significa que no devuelven ning칰n valor. Tambi칠n es importante abrir y cerrar llaves `{}` para definir el bloque de c칩digo que pertenece a cada funci칩n.

---

::: {.callout-note}
## 游 Ejercicio 11 - Zoog, utilizando `setup` y `draw`

Reescribe el c칩digo de Zoog utilizando las funciones `setup` y `draw`. **쯅otas alguna diferencia en el resultado respecto al c칩digo original?**

```java
void setup() {
  // Tama침o del lienzo
  size(600, 600);
}

void draw() {
  // Fondo blanco
  background(255);

  // Coordenadas desde el centro
  ellipseMode(CENTER);
  rectMode(CENTER);

  // CUERPO
  stroke(0);
  fill(150);
  rect(200, 260, 50, 260);

  // CABEZA
  fill(255);
  ellipse(200, 160, 130, 160);

  // OJOS
  fill(0);
  ellipse(170, 160, 30, 60);
  ellipse(230, 160, 30, 60);

  // PIERNAS
  stroke(0);
  line(175, 390, 150, 420);
  line(226, 390, 250, 420);
}
```
:::

--- 

::: {.callout-warning}
## 游댮 Color de fondo 

Prueba a mover la instrucci칩n `background(255);` desde la funci칩n `draw` a la funci칩n `setup`. **쯈u칠 ocurre?**
:::

---

### Interacci칩n con el rat칩n

En *Processing* existen algunas **palabras reservadas** como `width` y `height`, que permiten acceder al ancho y alto de la ventana, respectivamente, y otras que permiten 
interactuar con el usuario, como `mouseX` y `mouseY`, que indican la **posici칩n actual del rat칩n en la ventana**.

--- 

::: {layout="[70,30]"}
::: {.column}
::: {.callout-note}
## 游 Ejercicio 12 - Sigue al rat칩n

Modifica el programa de Zoog para que la esquina superior izquierda del cuerpo de Zoog sea la posici칩n del rat칩n, utilizando `mouseX` y `mouseY`.
:::

::: {.callout-note}
## 游 Ejercicio 13 - Sigue al rat칩n II

Posiciona la cabeza de Zoog sobre el cuerpo, de acuerdo tambi칠n a las coordenadas (`mouseX`, `mouseY`), de manera que la cabeza se mueva en funci칩n de la posici칩n del rat칩n. Por supuesto, tendr치s que ajustar tambi칠n la posici칩n de los ojos.
:::

::: {.callout-note}
## 游 Ejercicio extra - Sigue al rat칩n III
Intenta que las piernas de Zoog tambi칠n sigan al rat칩n, manteniendo la misma distancia relativa con el cuerpo.
:::
:::

::: {.column}
![Algunas medidas de Zoog.](../resources/practica1/zoog_size.svg){#fig-zoog-follow-mouse}
:::
:::

---

## Variables, condicionales y bucles

### Introducci칩n a variables

En la secci칩n anterior hemos descubierto que el m칠todo `draw` se ejecuta de manera repetitiva en un bucle infinito. Esto nos permite crear programas din치micos que cambian con el tiempo. Sin embargo, para crear programas m치s complejos, es necesario utilizar **variables** para almacenar datos que pueden cambiar durante la ejecuci칩n del programa.

::: {.callout-note}
## 游 Ejercicio 14 - Traslada una esfera

Crea un programa que traslade una esfera de izquierda a derecha en la ventana. Utiliza una variable para almacenar la posici칩n horizontal de la esfera, y actual칤zala en cada iteraci칩n del bucle `draw`.

<details>
<summary>游눠 Soluci칩n</summary>
```java
int circleX = 100;
int circleY = 100;

void setup() {
  size(400, 200);
}

void draw() {
  background(255);
  stroke(0);
  fill(175);
  ellipse(circleX, circleY, 50, 50);
  circleX = circleX + 1;
}
```
</details>
:::

---

### Condicionales

Los **condicionales** permiten ejecutar **diferentes bloques de c칩digo** en funci칩n de **si se cumple o no una determinada condici칩n**. En *Processing*, los condicionales se implementan utilizando las palabras reservadas `if`, `else if` y `else`.

La sintaxis b치sica de un condicional es la siguiente:
```java
if (condici칩n) {
  // bloque de c칩digo si la condici칩n es verdadera
} else if (otra_condici칩n) {
  // bloque de c칩digo si la otra condici칩n es verdadera
} else {
  // bloque de c칩digo si ninguna condici칩n es verdadera
}
```

Ten en cuenta que no siempre es necesario utilizar `else if` o `else`; **un condicional puede consistir 칰nicamente en una instrucci칩n `if`**.

---

::: {.callout-note}
## 游 Ejercicio 15 - Color de fondo interactivo

Modifica el programa de Zoog para que el color de fondo cambie en funci칩n de la posici칩n del rat칩n. Por ejemplo, si el rat칩n se encuentra en el primer tercio de la ventana, el fondo debe ser blanco; si est치 en el segundo tercio, el fondo debe ser gris; y si est치 en el tercer tercio, el fondo debe ser negro.

游눠 **Pista**: en el c칩digo que hemos utilizado para dibujar a Zoog se define una ventana de tama침o 600x600. Puedes comprobar si `mouseX` o `mouseY` se encuentran en un determinado tercio de la pantalla:
```java
if (mouseX < 200) {
    ...
}
else if (...) {
    ...
}
else {
    ...
}
```
:::

---

### Bucles

Existen algunas palabras reservadas en *Java* para representar **bucles**, es decir, **bloques de c칩digo que se repiten durante un n칰mero de iteraciones, o infinitamente hasta que no se cumpla alguna condici칩n**. 

En esta sesi칩n es suficiente con conocer el bucle `for`, que permite ejecutar un bloque de c칩digo un n칰mero determinado de veces. La sintaxis b치sica de un bucle `for` es la siguiente:
```java
for (int i = 1; i <= N; i++) {
  // bloque de c칩digo a ejecutar N veces
}
```

---

::: {.callout-note}
### 游 Ejercicio 16 - M칰ltiples Zoog

El objetivo es mostrar 2 Zoogs en la pantalla a partir del programa de un 칰nico Zoog. Ten en cuenta que tendr치s que modificar la posici칩n de al menos uno de ellos para que sea visible.

**A modo de inspiraci칩n**, el siguiente c칩digo dibuja dos rect치ngulos desplazados en el eje horizontal y vertical en funci칩n de *i*:
```java
size(500, 200);

int N = 2;
float offsetX = 0;
float offsetY = 0;

for (int i = 1; i <= N; i++) {
  rect(50 + offsetX, 20 + offsetY, 80, 80);

  offsetX += 100;
  offsetY += 10;
}
```
:::

---

::: {layout="[80,20]"}
::: {.column}
::: {.callout-note}
### 游 Ejercicio 17 - Z pares de brazos

Modifica el programa de Zoog para que dibuje *Z* pares de brazos, donde *Z* es una variable que puedes definir al principio del programa. Utiliza un bucle `for` para dibujar los brazos.
:::
:::
::: {.column}
![Resultado de a침adir 3 pares de brazos a Zoog.](../resources/practica1/zoog-arms.png){#fig-zoog-multiple-arms}
:::
:::

---

## Ap칠ndice: Instalaci칩n de Processing {.unnumbered}

![Banner de la p치gina oficial de *Processing*; a la izquierda se muestra el bot칩n de *Download*.](../resources/practica1/web-teaser.png){#fig-installation}

- Accede a [la p치gina oficial de *Processing*](http://processing.org) y selecciona **Download**.
- Descarga la versi칩n correspondiente a tu sistema operativo.
- Ejecuta el instalador descargado y sigue las instrucciones.

