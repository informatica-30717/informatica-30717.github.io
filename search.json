[
  {
    "objectID": "practicas/practica8.html",
    "href": "practicas/practica8.html",
    "title": "Pr√°ctica 8: BIM sem√°ntico",
    "section": "",
    "text": "Conocer la representaci√≥n de modelos BIM usando ontolog√≠as\nHacer consultas al modelo BIM usando un razonador sem√°ntico."
  },
  {
    "objectID": "practicas/practica8.html#objetivos-de-la-pr√°ctica",
    "href": "practicas/practica8.html#objetivos-de-la-pr√°ctica",
    "title": "Pr√°ctica 8: BIM sem√°ntico",
    "section": "",
    "text": "Conocer la representaci√≥n de modelos BIM usando ontolog√≠as\nHacer consultas al modelo BIM usando un razonador sem√°ntico."
  },
  {
    "objectID": "practicas/practica8.html#qu√©-es-bim",
    "href": "practicas/practica8.html#qu√©-es-bim",
    "title": "Pr√°ctica 8: BIM sem√°ntico",
    "section": "2 ¬øQu√© es BIM?",
    "text": "2 ¬øQu√© es BIM?\n\n\n\n\n\n\nFigura¬†1: Youtube: Autodesk Building Solutions What Is BIM (Building Information Modeling)?.\n\n\n\n\n\n\n\n\n\nFigura¬†2: Ciclo de vida de la edificaci√≥n."
  },
  {
    "objectID": "practicas/practica8.html#uso-de-un-software-visualizador-bim",
    "href": "practicas/practica8.html#uso-de-un-software-visualizador-bim",
    "title": "Pr√°ctica 8: BIM sem√°ntico",
    "section": "3 Uso de un software visualizador BIM",
    "text": "3 Uso de un software visualizador BIM\nEn esta pr√°ctica considerararemos diferentes versiones de un modelo BIM p√∫blicamente disponible correspondiente a un apartamento d√∫plex. La versi√≥n original (‚¨áÔ∏è Duplex.ifc) est√° en IFC (concretamente, 2x3). La versi√≥n sem√°ntica (‚¨áÔ∏è Duplex.owl) est√° en el lenguaje OWL.\nEl primer paso de la pr√°ctica es usar BIMvision u otro visualizador BIM para abrir el fichero Duplex.ifc y familiarizarse con el modelo. La Figura¬†3 muestra el detalle de una ventana de la planta baja (Level 1).\n\n\n\n\n\n\nFigura¬†3: Modelo Duplex en BIMvision.\n\n\n\n\n\n\n\n\n\nNotaüß† Ejercicio 1 - Encontrar elementos\n\n\n\n¬øCu√°ntas ventanas hay?\n¬øQu√© identificador, alturas y anchura tiene cada una?"
  },
  {
    "objectID": "practicas/practica8.html#conversi√≥n-a-modelo-sem√°ntico",
    "href": "practicas/practica8.html#conversi√≥n-a-modelo-sem√°ntico",
    "title": "Pr√°ctica 8: BIM sem√°ntico",
    "section": "4 Conversi√≥n a modelo sem√°ntico",
    "text": "4 Conversi√≥n a modelo sem√°ntico\nEste apartado es opcional, puesto que el objetivo es obtener el fichero Duplex.owl que ya est√° disponible, pero en todo caso vamos a describir mejor el proceso seguido para obtener el fichero. Aunque existen varias herramientas que permiten traducir un fichero de entrada en IFC a un fichero de salida en OWL, en nuestro caso se ha usado en particular IFCtoLBD 2.43.5. Debemos tener cuenta que este fichero utiliza vocabulario (clases y propiedades) previamente definidas en ontolog√≠as existentes en el √°mbito de la construcci√≥n.\n\n\n\n\n\n\nAdvertencia\n\n\n\nSe ha usado la configuraci√≥n BOT + PRODUCT + PROPS, Level L1. Manualmente, se ha eliminado la referencia a 2 ontolog√≠as externas (OMG y MEP) para simplificar la pr√°ctica."
  },
  {
    "objectID": "practicas/practica8.html#uso-del-editor-de-ontolog√≠as-prot√©g√©",
    "href": "practicas/practica8.html#uso-del-editor-de-ontolog√≠as-prot√©g√©",
    "title": "Pr√°ctica 8: BIM sem√°ntico",
    "section": "5 Uso del editor de ontolog√≠as Prot√©g√©",
    "text": "5 Uso del editor de ontolog√≠as Prot√©g√©\nPara abrir el fichero Duplex.owl usaremos Prot√©g√©, un editor de ontolog√≠as gratuito y con versiones para varios sistemas operativos,. Prot√©g√© no requiere instalaci√≥n, basta descargar un fichero .zip, descomprimirlo y pinchar en el ejecutable.\nEn el men√∫ de opciones que hay bajo el t√≠tulo de la ontolog√≠a (‚ÄúConverters‚Äù), podemos elegir ‚ÄúEntities‚Äù para seleccionar los diferentes componentes de la ontolog√≠a (ver Figura¬†4 cuadro en color rojo): clases (‚ÄúClasses‚Äù), propiedades cuyo valor es un objeto/individuo (‚ÄúObject properties‚Äù), propiedades cuyo valor es un tipo de dato conocido por la m√°quina (‚ÄúData properties‚Äù), individuos (‚ÄúIndividuals‚Äù), etc.\nLa Figura¬†4 muestra el resultado de seleccionar ‚ÄúClases‚Äù y, concretamente, ‚ÄúEdificio‚Äù. Obs√©rvese c√≥mo la interfaz nos muestra que ‚ÄúEdificio‚Äù es una subclase de ‚ÄúZona‚Äù.\n\n\n\n\n\n\nFigura¬†4: Jerarqu√≠a de clases y detalle de la clase ‚ÄúEdificio‚Äù.\n\n\n\n[V√≠deo tutorial: editor Prot√©g√© The Coding Train.]\nDependiendo de la versi√≥n de la herramienta Prot√©g√© utilizada, es posible que importe autom√°ticamente las ontolog√≠as desde Internet o que nos pida que aportemos ficheros locales para importar las ontolog√≠as. En este √∫ltimo caso, en ‚ÄúActive ontology ‚Üí Ontology imports‚Äù pinchamos en el bot√≥n ‚Äú+‚Äù para a√±adir los ficheros ‚¨áÔ∏è beo.owl y ‚¨áÔ∏è bot.owl.\nComo vemos en la Figura¬†4, algunos elementos de la ontolog√≠a tienen asociadas varias anotaciones con etiquetas en m√∫ltiples idiomas. Por ejemplo, la clase ‚Äúhttp://w3id.org/bot/Building‚Äù tiene etiquetas ‚ÄúBuilding‚Äù, ‚ÄúEdificio‚Äù, etc. Dependiendo de la configuraci√≥n de nuestro ordenador (del idioma predeterminado), Prot√©g√© puede mostrarnos las etiquetas en un idioma u otro. En este guion, se asume que se muestran en castellano.\n\n\n\n\n\n\nNotaüß† Ejercicio 2 - Encontrar elementos\n\n\n\nNavegar a trav√©s de la jerarqu√≠a de clases de la ontolog√≠a y localizar la que permite representar las ventanas.\nNavegar a trav√©s de la jerarqu√≠a de propiedades de la ontolog√≠a y localizar las que permiten representar la altura de una ventana y la anchura de una ventana.\nNavegar a trav√©s de los individuos de la ontolog√≠a, localizar una ventana y comprobar el valor de sus propiedades. ¬øSe corresponden con lo mostrado por OpenIFCViewer?\n\n\n\n\n\n\n\n\nNotaüß† Ejercicio 3 - Inferencia y consultar\n\n\n\nPara cargar un razonador, pinchamos en la opci√≥n del men√∫ superior Reasoner. Seg√∫n la versi√≥n de Prot√©g√©, puede haber uno o varios razonadores. Seleccionamos HermiT y pinchamos en Start reasoner. Si hacemos cambios en la ontolog√≠a, tendremos que pinchar en Synchronize reasoner.\nPosteriormente, a trav√©s de la pesta√±a DL query, podemos hacer consultas al razonador. Recuperar las instancias de la clase que representa las ventanas (en ingl√©s). Pinchando en alguna de ellas, podemos ver los valores de las propiedades (tanto los originales como los inferidos por el razonador, si los hubiera).\nRecuperar las superclases de la clase que representa las ventanas.\nRecuperar las instancias de alguna de las superclases obtenidas en el paso anterior, para comprobar que el razonador recupera las instancias indirectas.\nRecuperar nuevamente las instancias de la clase que representa las ventanas. Da click sobre el simbolo ? en alguna instancia. El rasonador te dara al menos una explicaci√≥n.\n\n\n\n\n\n\n\n\nNotaüß† Ejercicio 3 - Consultas\n\n\n\nPara hacerlo a√∫n m√°s interesante, Prot√©g√© permite construir consultas complejas que involucran a varios elementos a la vez.\nRecuperar las instancias de ‚ÄúEspacio and ‚Äòelemento adyacente‚Äô some Window‚Äù, que es el conjunto de espacios que tienen un elemento tal adyacente que pertenece a la clase Ventana. ¬øCu√°ntos individuos hay?\n\n\n\n\n\n\n\n\nNotaüß† Ejercicio 4 - Ontolog√≠a incosistente\n\n\n\nSi la ontolog√≠a es inconsistente, no se puede razonar con ella: el razonador avisa de ello y permite pinchar en el bot√≥n Explain para entender el motivo y poder resolverlo.\nActualizar la ontolog√≠a introduciendo una inconsistencia. Por ejemplo, a√±adiendo dos valores diferentes para la altura de una ventana. Primero, marcamos la propiedad como Functional. A continuaci√≥n, buscamos la ventana y a√±adimos una Data property assertions con el bot√≥n +, eligiendo la propiedad que representa la altura y un valor diferente al que ya ten√≠a (como 1234). Por √∫ltimo, debemos sincronizar el razonador."
  },
  {
    "objectID": "practicas/practica8.reveal.html#objetivos-de-la-pr√°ctica",
    "href": "practicas/practica8.reveal.html#objetivos-de-la-pr√°ctica",
    "title": "Pr√°ctica 8: BIM sem√°ntico",
    "section": "Objetivos de la pr√°ctica",
    "text": "Objetivos de la pr√°ctica\n\nConocer la representaci√≥n de modelos BIM usando ontolog√≠as\nHacer consultas al modelo BIM usando un razonador sem√°ntico."
  },
  {
    "objectID": "practicas/practica8.reveal.html#qu√©-es-bim",
    "href": "practicas/practica8.reveal.html#qu√©-es-bim",
    "title": "Pr√°ctica 8: BIM sem√°ntico",
    "section": "¬øQu√© es BIM?",
    "text": "¬øQu√© es BIM?\n\n\n\n\n\n\nFigura¬†1: Youtube: Autodesk Building Solutions What Is BIM (Building Information Modeling)?.\n\n\n\n\n\n\n\n\n\nFigura¬†2: Ciclo de vida de la edificaci√≥n."
  },
  {
    "objectID": "practicas/practica8.reveal.html#uso-de-un-software-visualizador-bim",
    "href": "practicas/practica8.reveal.html#uso-de-un-software-visualizador-bim",
    "title": "Pr√°ctica 8: BIM sem√°ntico",
    "section": "Uso de un software visualizador BIM",
    "text": "Uso de un software visualizador BIM\nEn esta pr√°ctica considerararemos diferentes versiones de un modelo BIM p√∫blicamente disponible correspondiente a un apartamento d√∫plex. La versi√≥n original (‚¨áÔ∏è Duplex.ifc) est√° en IFC (concretamente, 2x3). La versi√≥n sem√°ntica (‚¨áÔ∏è Duplex.owl) est√° en el lenguaje OWL.\nEl primer paso de la pr√°ctica es usar BIMvision u otro visualizador BIM para abrir el fichero Duplex.ifc y familiarizarse con el modelo. La Figura¬†3 muestra el detalle de una ventana de la planta baja (Level 1).\n\n\nFigura¬†3: Modelo Duplex en BIMvision.\n\n\n\n\n\n\nüß† Ejercicio 1 - Encontrar elementos\n\n\n¬øCu√°ntas ventanas hay?\n¬øQu√© identificador, alturas y anchura tiene cada una?"
  },
  {
    "objectID": "practicas/practica8.reveal.html#conversi√≥n-a-modelo-sem√°ntico",
    "href": "practicas/practica8.reveal.html#conversi√≥n-a-modelo-sem√°ntico",
    "title": "Pr√°ctica 8: BIM sem√°ntico",
    "section": "Conversi√≥n a modelo sem√°ntico",
    "text": "Conversi√≥n a modelo sem√°ntico\nEste apartado es opcional, puesto que el objetivo es obtener el fichero Duplex.owl que ya est√° disponible, pero en todo caso vamos a describir mejor el proceso seguido para obtener el fichero. Aunque existen varias herramientas que permiten traducir un fichero de entrada en IFC a un fichero de salida en OWL, en nuestro caso se ha usado en particular IFCtoLBD 2.43.5. Debemos tener cuenta que este fichero utiliza vocabulario (clases y propiedades) previamente definidas en ontolog√≠as existentes en el √°mbito de la construcci√≥n.\n\n\n\n\n\n\nAdvertencia\n\n\nSe ha usado la configuraci√≥n BOT + PRODUCT + PROPS, Level L1. Manualmente, se ha eliminado la referencia a 2 ontolog√≠as externas (OMG y MEP) para simplificar la pr√°ctica."
  },
  {
    "objectID": "practicas/practica8.reveal.html#uso-del-editor-de-ontolog√≠as-prot√©g√©",
    "href": "practicas/practica8.reveal.html#uso-del-editor-de-ontolog√≠as-prot√©g√©",
    "title": "Pr√°ctica 8: BIM sem√°ntico",
    "section": "Uso del editor de ontolog√≠as Prot√©g√©",
    "text": "Uso del editor de ontolog√≠as Prot√©g√©\nPara abrir el fichero Duplex.owl usaremos Prot√©g√©, un editor de ontolog√≠as gratuito y con versiones para varios sistemas operativos,. Prot√©g√© no requiere instalaci√≥n, basta descargar un fichero .zip, descomprimirlo y pinchar en el ejecutable.\nEn el men√∫ de opciones que hay bajo el t√≠tulo de la ontolog√≠a (‚ÄúConverters‚Äù), podemos elegir ‚ÄúEntities‚Äù para seleccionar los diferentes componentes de la ontolog√≠a (ver Figura¬†4 cuadro en color rojo): clases (‚ÄúClasses‚Äù), propiedades cuyo valor es un objeto/individuo (‚ÄúObject properties‚Äù), propiedades cuyo valor es un tipo de dato conocido por la m√°quina (‚ÄúData properties‚Äù), individuos (‚ÄúIndividuals‚Äù), etc.\nLa Figura¬†4 muestra el resultado de seleccionar ‚ÄúClases‚Äù y, concretamente, ‚ÄúEdificio‚Äù. Obs√©rvese c√≥mo la interfaz nos muestra que ‚ÄúEdificio‚Äù es una subclase de ‚ÄúZona‚Äù.\n\n\nFigura¬†4: Jerarqu√≠a de clases y detalle de la clase ‚ÄúEdificio‚Äù.\n[V√≠deo tutorial: editor Prot√©g√© The Coding Train.]\nDependiendo de la versi√≥n de la herramienta Prot√©g√© utilizada, es posible que importe autom√°ticamente las ontolog√≠as desde Internet o que nos pida que aportemos ficheros locales para importar las ontolog√≠as. En este √∫ltimo caso, en ‚ÄúActive ontology ‚Üí Ontology imports‚Äù pinchamos en el bot√≥n ‚Äú+‚Äù para a√±adir los ficheros ‚¨áÔ∏è beo.owl y ‚¨áÔ∏è bot.owl.\nComo vemos en la Figura¬†4, algunos elementos de la ontolog√≠a tienen asociadas varias anotaciones con etiquetas en m√∫ltiples idiomas. Por ejemplo, la clase ‚Äúhttp://w3id.org/bot/Building‚Äù tiene etiquetas ‚ÄúBuilding‚Äù, ‚ÄúEdificio‚Äù, etc. Dependiendo de la configuraci√≥n de nuestro ordenador (del idioma predeterminado), Prot√©g√© puede mostrarnos las etiquetas en un idioma u otro. En este guion, se asume que se muestran en castellano.\n\n\n\n\n\n\nüß† Ejercicio 2 - Encontrar elementos\n\n\nNavegar a trav√©s de la jerarqu√≠a de clases de la ontolog√≠a y localizar la que permite representar las ventanas.\nNavegar a trav√©s de la jerarqu√≠a de propiedades de la ontolog√≠a y localizar las que permiten representar la altura de una ventana y la anchura de una ventana.\nNavegar a trav√©s de los individuos de la ontolog√≠a, localizar una ventana y comprobar el valor de sus propiedades. ¬øSe corresponden con lo mostrado por OpenIFCViewer?\n\n\n\n\n\n\n\n\n\nüß† Ejercicio 3 - Inferencia y consultar\n\n\nPara cargar un razonador, pinchamos en la opci√≥n del men√∫ superior Reasoner. Seg√∫n la versi√≥n de Prot√©g√©, puede haber uno o varios razonadores. Seleccionamos HermiT y pinchamos en Start reasoner. Si hacemos cambios en la ontolog√≠a, tendremos que pinchar en Synchronize reasoner.\nPosteriormente, a trav√©s de la pesta√±a DL query, podemos hacer consultas al razonador. Recuperar las instancias de la clase que representa las ventanas (en ingl√©s). Pinchando en alguna de ellas, podemos ver los valores de las propiedades (tanto los originales como los inferidos por el razonador, si los hubiera).\nRecuperar las superclases de la clase que representa las ventanas.\nRecuperar las instancias de alguna de las superclases obtenidas en el paso anterior, para comprobar que el razonador recupera las instancias indirectas.\nRecuperar nuevamente las instancias de la clase que representa las ventanas. Da click sobre el simbolo ? en alguna instancia. El rasonador te dara al menos una explicaci√≥n.\n\n\n\n\n\n\n\n\n\nüß† Ejercicio 3 - Consultas\n\n\nPara hacerlo a√∫n m√°s interesante, Prot√©g√© permite construir consultas complejas que involucran a varios elementos a la vez.\nRecuperar las instancias de ‚ÄúEspacio and ‚Äòelemento adyacente‚Äô some Window‚Äù, que es el conjunto de espacios que tienen un elemento tal adyacente que pertenece a la clase Ventana. ¬øCu√°ntos individuos hay?\n\n\n\n\n\n\n\n\n\nüß† Ejercicio 4 - Ontolog√≠a incosistente\n\n\nSi la ontolog√≠a es inconsistente, no se puede razonar con ella: el razonador avisa de ello y permite pinchar en el bot√≥n Explain para entender el motivo y poder resolverlo.\nActualizar la ontolog√≠a introduciendo una inconsistencia. Por ejemplo, a√±adiendo dos valores diferentes para la altura de una ventana. Primero, marcamos la propiedad como Functional. A continuaci√≥n, buscamos la ventana y a√±adimos una Data property assertions con el bot√≥n +, eligiendo la propiedad que representa la altura y un valor diferente al que ya ten√≠a (como 1234). Por √∫ltimo, debemos sincronizar el razonador."
  },
  {
    "objectID": "practicas/practica2.html",
    "href": "practicas/practica2.html",
    "title": "Pr√°ctica 2: Un entorno de programaci√≥n en Java",
    "section": "",
    "text": "Los objetivos de la segunda pr√°ctica de la asignatura son los siguientes:\n\nFamiliarizarse con el ordenador y los elementos b√°sicos de su sistema operativo.\nFamiliarizarse con el entorno de desarrollo Java Eclipse.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Pr√°cticas",
      "Pr√°ctica 2: Un entorno de programaci√≥n en Java"
    ]
  },
  {
    "objectID": "practicas/practica2.html#objetivos-de-la-pr√°ctica",
    "href": "practicas/practica2.html#objetivos-de-la-pr√°ctica",
    "title": "Pr√°ctica 2: Un entorno de programaci√≥n en Java",
    "section": "",
    "text": "Los objetivos de la segunda pr√°ctica de la asignatura son los siguientes:\n\nFamiliarizarse con el ordenador y los elementos b√°sicos de su sistema operativo.\nFamiliarizarse con el entorno de desarrollo Java Eclipse.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Pr√°cticas",
      "Pr√°ctica 2: Un entorno de programaci√≥n en Java"
    ]
  },
  {
    "objectID": "practicas/practica2.html#el-entorno-de-desarrollo-eclipse",
    "href": "practicas/practica2.html#el-entorno-de-desarrollo-eclipse",
    "title": "Pr√°ctica 2: Un entorno de programaci√≥n en Java",
    "section": "2 El entorno de desarrollo Eclipse",
    "text": "2 El entorno de desarrollo Eclipse\nPara facilitar la tarea de desarrollo de programas existen entornos que permiten trabajar de una manera m√°s c√≥moda. Algunos ejemplos son NetBeans, Eclipse o IntelliJ. Nosotros recomendamos el uso de Eclipse, un entorno de desarrollo de libre distribuci√≥n.\nInicia la herramienta Eclipse haciendo doble clic sobre el ejecutable Eclipse en el escritorio de los laboratorios de pr√°cticas, o bien buscando Eclipse en la barra de tareas. Para instalar esta aplicaci√≥n en otros ordenadores puede consultarse el Ap√©ndice. Al iniciar Eclipse aparecer√° la pantalla de bienvenida que se muestra en la @fig:init_eclipse.\n\n\n\nPantalla de bienvenida.\n\n\nPara poder comenzar a trabajar con el entorno de desarrollo ser√° necesario definir un espacio de trabajo (workspace), tal y como se muestra en la @fig:workspace_eclipse. Este workspace contendr√° todos los ficheros creados con Eclipse. Por ejemplo, se puede establecer el directorio C:/PracticasARQ como directorio de trabajo.\n\n\n\nConfiguraci√≥n del workspace.\n\n\nEn los siguientes subapartados aparecen solo algunas de las caracter√≠sticas de Eclipse, o recomendaciones acerca de su uso. Si tienes m√°s dudas sobre c√≥mo utilizar Eclipse, deber√°s consultar la ayuda en l√≠nea (opci√≥n de men√∫ Help &gt; Help Contents), o bien accediendo a su p√°gina web, donde se encuentra tambi√©n toda la documentaci√≥n del programa.\n\n2.1 Pantalla de bienvenida\nLa primera vez que se utiliza Eclipse, aparecer√° un mensaje pregunt√°ndonos si queremos excluir Eclipse del an√°lisis del antivirus de Windows. Como aparece en la @fig:antivirus_eclipse, podemos indicar que se excluya Eclipse de dichos an√°lisis para evitar ralentizar la aplicaci√≥n.\n\n\n\nPregunta de exclusi√≥n de Eclipse IDE respecto del sistema antivirus de Windows.\n\n\nUna vez seleccionada una opci√≥n, nos aparecer√° una ventana de bienvenida (@fig:welcome_eclipse) con varias opciones, de las cuales cabe destacar las siguientes:\n\n\n\nPantalla de bienvenida.\n\n\nSi cerramos la pesta√±a de bienvenida, nos conducir√° al entorno de trabajo que se explica en la siguiente secci√≥n.\nEn esta pantalla de bienvenida, en la barra izquierda, se nos muestran algunas opciones, entre las que se incluye Create a Java project. Utilizaremos esta opci√≥n cada vez que queramos crear un nuevo proyecto, por ejemplo, para cada pr√°ctica de programaci√≥n de este curso. Para esta pr√°ctica, podemos crear un nuevo proyecto al que llamaremos practica2.\n\n\n2.2 Entorno de trabajo\nEl entorno de trabajo o workbench nos proporciona una interfaz de usuario intuitiva, bien estructurada y sencilla de utilizar, donde est√°n bien definidas las distintas zonas de trabajo. En la Figura 5 se puede observar la interfaz de usuario de Eclipse.\nLas diferentes partes en las que est√° dividida la interfaz son:\n\nEn la zona de la izquierda, se halla un men√∫ (Package Explorer) que agrupa los componentes de cada uno de los proyectos abiertos.\nEn la zona central de la pantalla se encuentra un editor, que sirve para ver y modificar los ficheros Java con los que trabajamos.\nEn la zona de la derecha, hay un resumen (Outline) que nos indica la estructura del fichero activo en el editor (clases, m√©todos, variables, etc.).\nEn la parte inferior del editor se encuentran algunas utilidades que nos permiten conocer el estado del proyecto, incluyendo errores (Problems) y la salida obtenida en los programas ejecutados (Console).\n\n\n\n\nEspacio de trabajo de Eclipse IDE.\n\n\n\n\n2.3 1.3. Crear un proyecto\nPara la realizaci√≥n de cada pr√°ctica se recomienda crear un proyecto nuevo. De esta forma se pueden agrupar los ficheros correspondientes a una determinada pr√°ctica dentro de ese proyecto para compilar y ejecutar programas individuales que comparten una configuraci√≥n com√∫n.\nLos proyectos se crean a trav√©s de la opci√≥n File &gt; New &gt; Java Project. Para crear el nuevo proyecto hay que dotarlo de un nombre identificativo (ej. practica2). Dicho proyecto corresponder√° con un directorio dentro del equipo, y dentro del workspace seleccionado al lanzar Eclipse. Conviene seleccionar la opci√≥n Create separate source and output folders. En la Figura 6 se pueden observar todas las propiedades que se pueden definir en la creaci√≥n del proyecto.\nEl nuevo proyecto que has creado se configurar√° sobre la carpeta:\nC:\\practicasARQ\\practica2\nObserva que en la carpeta practica2 se han creado dos subcarpetas. En src se almacenar√°n los ficheros con el c√≥digo en lenguaje Java (source), mientras que en la carpeta bin se almacenan los ficheros binarios (binaries).\nIlustraci√≥n . Propiedades que podemos configurar al crear un nuevo proyecto.\n\n\n2.4 1.4. Crear una aplicaci√≥n\nLos lenguajes orientados a objetos, como Java, giran en torno al concepto de clase. Todas las variables y m√©todos de Java deben pertenecer a una clase. Una clase es una colecci√≥n de datos (variables) y de m√©todos (funciones) que operan sobre dichos datos. Cada clase p√∫blica debe ir en un fichero con extensi√≥n .java, cuyo nombre es exactamente igual que el de la clase. Por ejemplo, en un fichero HolaMundo.java, definiremos una clase HolaMundo.\nPara a√±adir nuevas clases al proyecto utilizaremos la opci√≥n de men√∫ File &gt; New &gt; Class. Selecciona src como subcarpeta e introduce HolaMundo como nombre del archivo que contendr√° el programa (clase) que deber√°s escribir a continuaci√≥n. La opci√≥n public static void main(String[] args) debe marcarse para que la clase sea ejecutable (ejecut√°ndose por tanto el m√©todo main de la clase). La Ilustraci√≥n 7 ilustra este proceso.\nIlustraci√≥n . Creaci√≥n de una nueva clase de Java.\nFijaos en que, adem√°s de la carpeta, hemos indicado el nombre de un paquete. Dicho nombre no se puede dejar en blanco, por lo que hemos nombrado practica2. En futuras sesiones de pr√°cticas hablaremos de qu√© es un paquete, y c√≥mo crearlo para estructurar las clases que creemos en cada proyecto.\nAl finalizar la creaci√≥n, se crear√° autom√°ticamente un peque√±o esqueleto con el c√≥digo inicial com√∫n a cada clase, que deber√° completarse para contener el siguiente c√≥digo:\nimport java.util.*;\n\n/**\n * La clase HolaMundo ejemplifica el uso de Eclipse para programar en Java.\n * @author Fernando Bobillo, Alfonso L√≥pez, Ignacio Huitzil.\n */\npublic class HolaMundo\n{\n    /**\n     * El m√©todo main contiene el programa principal.\n     * @param args Puede recibir una lista de par√°metros como argumento.\n     */\n    public static void main(String[] args)\n    {\n        System.out.print(\"Escribe tu nombre: \");\n        String nombre = (new Scanner(System.in)).nextLinea();\n        System.out.println(\"Hola \" + nom + \", mucho gusto.\");\n    }\n}\nEl c√≥digo anterior contiene algunos errores introducidos voluntariamente para que se produzcan errores de compilaci√≥n.\nEl editor de Eclipse es un editor t√≠pico del entorno Windows: se puede copiar, cortar, pegar, buscar y sustituir. Tiene un sistema de tabulaci√≥n inteligente que facilita la tarea de escritura. Se puede conseguir aumentar o disminuir la tabulaci√≥n de una porci√≥n de c√≥digo seleccionando dicha porci√≥n y pulsando tabulador o may√∫sculas-tabulador.\nGuarda los cambios que hemos introducido pulsando los iconos con disquetes que hay en la barra de herramientas superior ( ), pulsando Ctrl-S o bien con File &gt; Save.\n\n\n2.5 1.5. Compilaci√≥n de aplicaciones\nPara compilar el programa deber√°s utilizar la opci√≥n de men√∫ Project &gt; Build Project en el caso de que no est√© marcada la compilaci√≥n autom√°tica. En este √∫ltimo caso, ser√° suficiente con guardar el fichero para que se compile.\nDentro de las herramientas que se muestran en la porci√≥n inferior, encontramos la subpesta√±a Problems. En esa subpesta√±a se nos informar√° sobre el proceso de compilaci√≥n indicando los posibles errores (ver Ilustraci√≥n 8). Puedes seleccionar cada error mediante doble click, y se indicar√° dentro del c√≥digo d√≥nde se encuentra el error.\nSi trabaj√°semos sin un entorno de desarrollo, ser√≠a equivalente a abrir una ventana de √≥rdenes del sistema operativo y teclear:\njavac HolaMundo.java\nIlustraci√≥n . Compilaci√≥n con errores.\nEl primer error se produce porque el nombre correcto del m√©todo es nextLine; el segundo porque se ha escrito mal la variable nombre. Corrige ambos errores y recompila con Project &gt; Build project. Ahora no te deber√° mostrar ning√∫n error. El fichero compilado se llama HolaMundo.class y se habr√° creado en la subcarpeta bin.\n\n\n2.6 1.6. Ejecuci√≥n de aplicaciones\nFinalmente, hay que llamar al int√©rprete de la m√°quina virtual. En el entorno Eclipse esto se hace utilizando la opci√≥n de men√∫ Run &gt; Run as: Java application, o mediante el icono de ejecutar en la barra de herramientas superior .\nSi trabaj√°semos directamente con el JDK deber√≠amos invocar al int√©rprete (comando java) pas√°ndole como par√°metro el fichero compilado sin poner la extensi√≥n .class. As√≠ pues, en el int√©rprete de √≥rdenes teclear√≠amos:\njava HolaMundo\n\n\n2.7 1.7. Depuraci√≥n de errores\nPara depurar los errores de un proyecto, lo ejecutaremos paso a paso para comprender mejor el funcionamiento real del programa, tal y como se ilustra en la Ilustraci√≥n 9.\nIlustraci√≥n . Depuraci√≥n de un programa.\nPara ello, seguimos los siguientes pasos:\nUtiliza la opci√≥n de men√∫ Run &gt; Toggle line breakpoint para establecer (o eliminar) puntos de parada sobre el c√≥digo que queremos ejecutar paso a paso. La ejecuci√≥n paso a paso comenzar√° en la l√≠nea que contenga el punto de ruptura. Tambi√©n se puede utilizar el men√∫ desplegable que aparece al pulsar el bot√≥n derecho del rat√≥n sobre el margen izquierdo de la ventana que muestra el c√≥digo de una clase Java.\nUtiliza la opci√≥n Run &gt; Debug, o Debug  en la barra de herramientas superior, para lanzar la ejecuci√≥n en modo depuraci√≥n de errores. Aparecer√° una ventana de debugger (depurador) con el estado de todas las variables.\nUtiliza Run &gt; Step into (F5) y Run &gt; Step over (F6) para ejecutar el c√≥digo instrucci√≥n a instrucci√≥n. Step over ejecuta las llamadas a m√©todos como sentencias simples (sin entrar a ejecutar paso a paso cada instrucci√≥n dentro del m√©todo).\nPara practicar todo lo visto hasta ahora, haz lo siguiente:\nCrea una nueva clase llamada Ejercicio (comenzando con una letra may√∫scula).\nPega el siguiente c√≥digo en la clase creada.\npackage practica2;\n\npublic class Ejercicio\n{\n        public static void main(String[] args)\n        {\n            int n, x, y, z;\n            n = 10;\n            x = 0;\n            y = 1;\n            z = 1;\n\n            if (n == 0) || (n == 1)\n            {\n                x = 1\n            }\n            else\n            {\n                for (i=2; i&lt;=n; i++)\n                {\n                    int s = y + z;\n                    x = s;\n                    z = y;\n                    y = x;\n                }\n            }\n\n            System.out.println(Programa terminado);\n        }\n}\nSoluciona todos los errores de compilaci√≥n en el programa anterior.\nEjecuta el programa paso a paso para observar cu√°l es el valor que toma la variable x justo antes de finalizar el programa.\n\n\n2.8 1.8. Exportar e importar proyectos\nLas opciones de exportar e importar proyectos sirven para transferir proyectos de un ordenador a otro. Por ejemplo, podemos exportar un proyecto Eclipse a una carpeta de ficheros ubicada en una memoria USB y, en otro ordenador, importar la carpeta.\nPara exportar un proyecto de Eclipse a una carpeta de ficheros, haremos lo siguiente:\nUtiliza la opci√≥n de men√∫ File &gt; Export y elegir General &gt; File system (ver Ilustraci√≥n 10).\nIlustraci√≥n . Exportar proyectos del workspace.\nMarcaremos el proyecto a exportar y todos sus elementos (carpetas en la parte izquierda, ficheros concretos en la parte izquierda). En general, s√≥lo se suele exportar la carpeta src, dado que los ficheros binarios (bin) se generan a partir de la compilaci√≥n.\nEn la zona To directory se indicar√° el nombre de la carpeta que vamos a crear.\nPulsa Finish para finalizar.\nSi ha ido todo bien, habr√°s generado una carpeta con la estructura de subcarpetas del proyecto actual. Existen otras maneras de exportar proyectos, pero esta es la m√°s sencilla.\nPor otro lado, no es estrictamente necesario exportar el proyecto, sino que es suficiente con guardar los ficheros .java ubicados en la carpeta src.\nPara importar un proyecto tenemos varias alternativas:\nCopiamos la carpeta de ficheros exportada en el workspace del ordenador. Si existe otra carpeta con una versi√≥n previa del proyecto (por ejemplo, si estamos practicando la exportaci√≥n y la importaci√≥n en el mismo ordenador), deberemos borrar la versi√≥n previa para poder importarla correctamente.\nUtilizamos la opci√≥n File &gt; Import y a continuaci√≥n seleccionamos General &gt; Existing projects into workspace (ver Ilustraci√≥n 11).\nIlustraci√≥n . Importar proyectos del workspace.\nCrear un nuevo proyecto a partir de clases Java existentes utilizando la opci√≥n Import  &gt; General &gt; File system. De esta manera, podr√≠amos importar √∫nicamente los ficheros .java sin necesidad de considerar el resto del proyecto.\nPor ahora recomendamos utilizar la opci√≥n General &gt; Existing projects into workspace.\n\n\n2.9 1.9. Crear y utilizar bibliotecas .jar\nCuando se quiere distribuir una aplicaci√≥n desarrollada en Java que incluye un n√∫mero considerable de clases y paquetes, conviene generar una biblioteca. Las bibliotecas en Java son archivos con extensi√≥n .jar que comprimen (al estilo de los ficheros .zip) un conjunto de clases compiladas (.class) organizadas en paquetes. Se puede explorar el contenido de un fichero .jar con programas de compresi√≥n de ficheros como WinZip.\nPara crear una biblioteca en el entorno Eclipse debemos seleccionar el proyecto que queremos exportar, utilizar la opci√≥n de men√∫ File &gt; Export, seleccionar Java &gt; Runnable JAR File y seguir los siguientes pasos, ilustrados en la Ilustraci√≥n 12:\nEn Launch configuration se elige la clase principal, es decir, la que tiene el m√©todo main que se ejecutar√° una vez que ejecutemos el fichero .jar.\nEn Export destination se indica el nombre del fichero que vamos a crear y la ruta donde se va a almacenar dicho fichero.\nPulsa Finish para finalizar. Si ha ido todo bien, se habr√° generado un fichero .jar.\nIlustraci√≥n . Construcci√≥n de una biblioteca .jar.\nSi el programa se llama HolaMundo.jar, podr√°s ejecutarlo escribiendo en una terminal del sistema operativo lo siguiente:\njava ‚Äìjar HolaMundo.jar\nPara abrir una terminal en Windows, hay que utilizar la barra de b√∫squeda e introducir S√≠mbolo del sistema. Antes de poder ejecutar el .jar con la instrucci√≥n anterior, debemos posicionarnos en la carpeta que lo contenga. Para simplificar, guarda el fichero .jar en la carpeta ra√≠z del disco duro,  C:, y posteriormente escribe en la ventana de √≥rdenes la siguiente instrucci√≥n:\ncd /\n\n\n2.10 1.10. A√±adir bibliotecas a un proyecto\nSi queremos utilizar alguna de las clases ya definidas en Java, simplemente es necesario a√±adir una sentencia en nuestro programa para importar la biblioteca correspondiente. Por ejemplo, para utilizar las clases definidas en el paquete java.util, hemos a√±adido en nuestro programa la sentencia\nimport java.util.*;\nEl proceso de incluir bibliotecas diferentes a las incluidas por defecto en Java puede no ser sencillo, ya que hay varias opciones para hacerlo de una manera correcta. Entre las distintas opciones que tenemos para incluir bibliotecas est√°n las siguientes:\nSi tenemos un fichero .jar con las clases compiladas, podemos a√±adirlo directamente.\nSi tenemos las clases compiladas pero no un fichero .jar, nos puede interesar incluir el directorio con clases compiladas.\nSi vamos a utilizar una biblioteca com√∫n, es recomendable crear una variable, e incluirla como biblioteca.\nEn este apartado vamos a describir el primer escenario. Para ello, vamos a importar a modo de ejemplo la biblioteca .jar incluida en Moodle, biblioteca.jar.\nAntes de ello, vamos a escribir en nuestro programa la siguiente instrucci√≥n:\nPracticas.escribeMensaje();\nAl compilar, se nos informa de un error: la clase Practicas no ha sido definida todav√≠a. Para solucionarlo, vamos a importar una biblioteca donde se define dicha clase. Debemos hacer click derecho sobre el nombre del proyecto y seleccionar Properties &gt; Java Build Path. Obtendremos una ventana como la de la Ilustraci√≥n 13.\nA continuaci√≥n, hacemos click sobre Add External JARs y seleccionamos el fichero a importar.  Una vez hecho esto, podemos comprobar que es posible ejecutar nuestro programa sin ning√∫n tipo de problemas, pues el c√≥digo necesario se obtiene en el fichero importado.\nIlustraci√≥n . A√±adiendo una biblioteca .jar a un proyecto.\n\n\n2.11 1.11. Generar documentaci√≥n\nPara generar la documentaci√≥n de las clases y paquetes desarrollados se utiliza la herramienta javadoc, incluida en la JDK. Desde el entorno de Eclipse, se facilita la utilizaci√≥n de esta herramienta a trav√©s de la opci√≥n de men√∫ Project &gt; Generate Javadoc (Ilustraci√≥n 14).\nEn primer lugar, seleccionamos la ubicaci√≥n del ejecutable javadoc con el bot√≥n Configure. Normalmente, Eclipse detecta autom√°ticamente su ubicaci√≥n y rellena este campo por nosotros, por lo que no necesitamos hacer nada.\nA continuaci√≥n, se debe configurar el directorio de salida de la documentaci√≥n utilizando la caja de texto Destination y el bot√≥n Browse asociado.\nPor √∫ltimo, se pulsar√° el bot√≥n Finish para finalizar y generar la documentaci√≥n. La documentaci√≥n podr√° abrirse con cualquier navegador HTML.\nPru√©balo para la clase HolaMundo.\nIlustraci√≥n . Generaci√≥n de documentaci√≥n con la herramienta javadoc.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Pr√°cticas",
      "Pr√°ctica 2: Un entorno de programaci√≥n en Java"
    ]
  },
  {
    "objectID": "practicas/practica2.html#acceso-a-la-documentaci√≥n-del-jdk",
    "href": "practicas/practica2.html#acceso-a-la-documentaci√≥n-del-jdk",
    "title": "Pr√°ctica 2: Un entorno de programaci√≥n en Java",
    "section": "3 1.12. Acceso a la documentaci√≥n del JDK",
    "text": "3 1.12. Acceso a la documentaci√≥n del JDK\nJava proporciona una amplia y detallada documentaci√≥n acerca de las herramientas que incluye el JDK, as√≠ como la especificaci√≥n de la API (Application Programming Interface), es decir, la documentaci√≥n de las bibliotecas disponibles por defecto en Java. Esta documentaci√≥n est√° accesible en la p√°gina oficial de Oracle (Ilustraci√≥n 15), y lo mismo sucede para la documentaci√≥n de la API (Ilustraci√≥n 16). Esta documentaci√≥n puede descargarse para poder consultarla sin necesidad de acceder a Internet; el material descargado puede visualizarse con cualquier navegador web.\nModifica la clase Ejercicio para que cada vez que se ejecute escriba por pantalla un n√∫mero diferente. Para ello, modifica la instrucci√≥n x = 1 con m√©todos de la clase Math que permitan obtener un n√∫mero enteros aleatorio: primero se obtendr√° un n√∫mero real aleatorio y luego se redondear√° a un n√∫mero entero. Puede buscarse dicho m√©todo en la documentaci√≥n de la clase java.lang.Math.\nx = Math.???(Math.???());\nIlustraci√≥n . Documentaci√≥n del JDK.\nIlustraci√≥n . Documentaci√≥n de la API de Java.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Pr√°cticas",
      "Pr√°ctica 2: Un entorno de programaci√≥n en Java"
    ]
  },
  {
    "objectID": "practicas/practica2.html#ap√©ndice.-instalaci√≥n-de-eclipse-y-jdk",
    "href": "practicas/practica2.html#ap√©ndice.-instalaci√≥n-de-eclipse-y-jdk",
    "title": "Pr√°ctica 2: Un entorno de programaci√≥n en Java",
    "section": "4 Ap√©ndice. Instalaci√≥n de Eclipse y JDK",
    "text": "4 Ap√©ndice. Instalaci√≥n de Eclipse y JDK\nEn este ap√©ndice explicaremos el proceso de instalaci√≥n del software necesario para realizar las pr√°cticas de Inform√°tica en los ordenadores personales. Existen al menos dos maneras de instalar el software:\n\n4.1 Instalaci√≥n de Eclipse mediante un instalador\nVisita la p√°gina web oficial de Eclipse.\nLocaliza el bot√≥n de Download. Nos llevar√° a la p√°gina de descargas.\nLocaliza el panel de Eclipse Installer (Ilustraci√≥n 17). Debemos reconocer nuestro sistema operativo (Windows, Linux o macOS), y pulsar sobre x86_64.\nUna vez descargado el instalador, lo ejecutamos.\nEl instalador permite obtener m√∫ltiples herramientas de Eclipse, aunque nosotros s√≥lo necesitamos el entorno de desarrollo para Java. La instalaci√≥n es bastante autom√°tica, y simplemente tendremos que seleccionar Eclipse IDE for Java Developers (Ilustraci√≥n 18).\nIlustraci√≥n . Instalador de la suite de Eclipse.\nIlustraci√≥n . Herramientas disponibles en la suite de Eclipse.\nUna vez seleccionada dicha opci√≥n, se nos dirige a una pantalla como la que se muestra en la Ilustraci√≥n 19. El objetivo es configurar dos rutas: la localizaci√≥n de las herramientas de desarrollo para Java y la ruta de instalaci√≥n de Eclipse. Pod√©is personalizar ambas rutas, pero no es recomendable hacerlo. En particular, la primera ruta apunta a un Java Development Kit (JDK), que, si no queremos descargar junto con Eclipse, deber√° instalarse por separado. Esta √∫ltima opci√≥n, aunque es menos sencilla, se describe en el siguiente punto y, entre otras ventajas, permite probar los comandos java y javac en la terminal del ordenador.\nIlustraci√≥n . Instalaci√≥n de Eclipse para Java, indicando que queremos descargar un JRE.\nUna opci√≥n alternativa consiste en indicar la ruta de un Java Runtime Environment (JRE) (versi√≥n 21 o superior) previamente instalado (ver Ilustraci√≥n 20). Para la descarga e instalaci√≥n del JDK de Java, por favor, dir√≠gete a la secci√≥n B.1 del Ap√©ndice. Por ejemplo, en la siguiente imagen, se ha detectado una instalaci√≥n en la ruta C:/Program Files/Java/jdk-25, que es la ruta de instalaci√≥n por defecto de un JDK.\nIlustraci√≥n . Instalaci√≥n de Eclipse para Java, indicando la ruta de un JDK previamente instalado.\n\n\n4.2 Instalaci√≥n alternativa de Eclipse sin instalador\n\n4.2.1 Instalaci√≥n del Java Software Development Kit (JDK)\nPara comenzar, debemos descargar la √∫ltima versi√≥n del JDK de la p√°gina web de Oracle:\nDescargamos el JDK de Java de la p√°gina oficial de Oracle. En este momento, la √∫ltima versi√≥n disponible es la 25.\nDebemos seleccionar el sistema operativo de nuestro ordenador personal (Linux, macOS o Windows) y descargar un instalador. En Windows, podemos descargar tanto x64 Installer como x64 MSI Installer.\nUna vez descargado, abrimos el archivo para comenzar el proceso de instalaci√≥n. El proceso es completamente autom√°tico y no habr√° que hacer nada, salvo utilizar el bot√≥n Next para avanzar entre pasos. La ruta de instalaci√≥n por defecto en Windows es C:/Program Files/Java/jdk-25. Se recomienda no modificar esta ruta, salvo que no tengamos espacio en C:.\nIlustraci√≥n . Paso intermedio de la instalaci√≥n del JDK. Se muestra la ruta de instalaci√≥n por defecto, la cual no modificaremos.\n\n\n4.2.2 Instalaci√≥n de Eclipse\nVisita la p√°gina web oficial de Eclipse.\nLocaliza el bot√≥n de Download. Nos llevar√° a la p√°gina de descargas.\nPartiendo de un panel similar al de la Ilustraci√≥n 22, reconocemos nuestro sistema operativo y pulsamos sobre x86_64. Se descargar√° un .zip con una carpeta dentro llamada eclipse (ver Ilustraci√≥n 23). Podemos situar dicha carpeta en cualquier directorio de nuestra elecci√≥n, por ejemplo, en la unidad C:. Ten en cuenta que esta opci√≥n no requiere instalaci√≥n, y por tanto, accederemos siempre a dicha carpeta cuando queramos iniciar Eclipse haciendo click sobre eclipse.exe. En la Ilustraci√≥n 23 se muestra el contenido del fichero .zip descomprimido.\nIlustraci√≥n . Panel de descarga de Eclipse sin instalador.\nIlustraci√≥n . Ficheros contenidos en el directorio eclipse, tras descomprimir el fichero .zip descargado de la p√°gina oficial de Eclipse.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Pr√°cticas",
      "Pr√°ctica 2: Un entorno de programaci√≥n en Java"
    ]
  },
  {
    "objectID": "practicas/practica2.reveal.html#objetivos-de-la-pr√°ctica",
    "href": "practicas/practica2.reveal.html#objetivos-de-la-pr√°ctica",
    "title": "Pr√°ctica 2: Un entorno de programaci√≥n en Java",
    "section": "Objetivos de la pr√°ctica",
    "text": "Objetivos de la pr√°ctica\nLos objetivos de la segunda pr√°ctica de la asignatura son los siguientes:\n\nFamiliarizarse con el ordenador y los elementos b√°sicos de su sistema operativo.\nFamiliarizarse con el entorno de desarrollo Java Eclipse."
  },
  {
    "objectID": "practicas/practica2.reveal.html#el-entorno-de-desarrollo-eclipse",
    "href": "practicas/practica2.reveal.html#el-entorno-de-desarrollo-eclipse",
    "title": "Pr√°ctica 2: Un entorno de programaci√≥n en Java",
    "section": "El entorno de desarrollo Eclipse",
    "text": "El entorno de desarrollo Eclipse\nPara facilitar la tarea de desarrollo de programas existen entornos que permiten trabajar de una manera m√°s c√≥moda. Algunos ejemplos son NetBeans, Eclipse o IntelliJ. Nosotros recomendamos el uso de Eclipse, un entorno de desarrollo de libre distribuci√≥n.\nInicia la herramienta Eclipse haciendo doble clic sobre el ejecutable Eclipse en el escritorio de los laboratorios de pr√°cticas, o bien buscando Eclipse en la barra de tareas. Para instalar esta aplicaci√≥n en otros ordenadores puede consultarse el Ap√©ndice. Al iniciar Eclipse aparecer√° la pantalla de bienvenida que se muestra en la @fig:init_eclipse.\n\n\n\nPantalla de bienvenida.\n\n\nPara poder comenzar a trabajar con el entorno de desarrollo ser√° necesario definir un espacio de trabajo (workspace), tal y como se muestra en la @fig:workspace_eclipse. Este workspace contendr√° todos los ficheros creados con Eclipse. Por ejemplo, se puede establecer el directorio C:/PracticasARQ como directorio de trabajo.\n\n\n\nConfiguraci√≥n del workspace.\n\n\nEn los siguientes subapartados aparecen solo algunas de las caracter√≠sticas de Eclipse, o recomendaciones acerca de su uso. Si tienes m√°s dudas sobre c√≥mo utilizar Eclipse, deber√°s consultar la ayuda en l√≠nea (opci√≥n de men√∫ Help &gt; Help Contents), o bien accediendo a su p√°gina web, donde se encuentra tambi√©n toda la documentaci√≥n del programa.\nPantalla de bienvenida\nLa primera vez que se utiliza Eclipse, aparecer√° un mensaje pregunt√°ndonos si queremos excluir Eclipse del an√°lisis del antivirus de Windows. Como aparece en la @fig:antivirus_eclipse, podemos indicar que se excluya Eclipse de dichos an√°lisis para evitar ralentizar la aplicaci√≥n.\n\n\n\nPregunta de exclusi√≥n de Eclipse IDE respecto del sistema antivirus de Windows.\n\n\nUna vez seleccionada una opci√≥n, nos aparecer√° una ventana de bienvenida (@fig:welcome_eclipse) con varias opciones, de las cuales cabe destacar las siguientes:\n\n\n\nPantalla de bienvenida.\n\n\nSi cerramos la pesta√±a de bienvenida, nos conducir√° al entorno de trabajo que se explica en la siguiente secci√≥n.\nEn esta pantalla de bienvenida, en la barra izquierda, se nos muestran algunas opciones, entre las que se incluye Create a Java project. Utilizaremos esta opci√≥n cada vez que queramos crear un nuevo proyecto, por ejemplo, para cada pr√°ctica de programaci√≥n de este curso. Para esta pr√°ctica, podemos crear un nuevo proyecto al que llamaremos practica2.\nEntorno de trabajo\nEl entorno de trabajo o workbench nos proporciona una interfaz de usuario intuitiva, bien estructurada y sencilla de utilizar, donde est√°n bien definidas las distintas zonas de trabajo. En la Figura 5 se puede observar la interfaz de usuario de Eclipse.\nLas diferentes partes en las que est√° dividida la interfaz son:\n\nEn la zona de la izquierda, se halla un men√∫ (Package Explorer) que agrupa los componentes de cada uno de los proyectos abiertos.\nEn la zona central de la pantalla se encuentra un editor, que sirve para ver y modificar los ficheros Java con los que trabajamos.\nEn la zona de la derecha, hay un resumen (Outline) que nos indica la estructura del fichero activo en el editor (clases, m√©todos, variables, etc.).\nEn la parte inferior del editor se encuentran algunas utilidades que nos permiten conocer el estado del proyecto, incluyendo errores (Problems) y la salida obtenida en los programas ejecutados (Console).\n\n\n\n\nEspacio de trabajo de Eclipse IDE.\n\n\n1.3. Crear un proyecto\nPara la realizaci√≥n de cada pr√°ctica se recomienda crear un proyecto nuevo. De esta forma se pueden agrupar los ficheros correspondientes a una determinada pr√°ctica dentro de ese proyecto para compilar y ejecutar programas individuales que comparten una configuraci√≥n com√∫n.\nLos proyectos se crean a trav√©s de la opci√≥n File &gt; New &gt; Java Project. Para crear el nuevo proyecto hay que dotarlo de un nombre identificativo (ej. practica2). Dicho proyecto corresponder√° con un directorio dentro del equipo, y dentro del workspace seleccionado al lanzar Eclipse. Conviene seleccionar la opci√≥n Create separate source and output folders. En la Figura 6 se pueden observar todas las propiedades que se pueden definir en la creaci√≥n del proyecto.\nEl nuevo proyecto que has creado se configurar√° sobre la carpeta:\nC:\\practicasARQ\\practica2\nObserva que en la carpeta practica2 se han creado dos subcarpetas. En src se almacenar√°n los ficheros con el c√≥digo en lenguaje Java (source), mientras que en la carpeta bin se almacenan los ficheros binarios (binaries).\nIlustraci√≥n . Propiedades que podemos configurar al crear un nuevo proyecto.\n1.4. Crear una aplicaci√≥n\nLos lenguajes orientados a objetos, como Java, giran en torno al concepto de clase. Todas las variables y m√©todos de Java deben pertenecer a una clase. Una clase es una colecci√≥n de datos (variables) y de m√©todos (funciones) que operan sobre dichos datos. Cada clase p√∫blica debe ir en un fichero con extensi√≥n .java, cuyo nombre es exactamente igual que el de la clase. Por ejemplo, en un fichero HolaMundo.java, definiremos una clase HolaMundo.\nPara a√±adir nuevas clases al proyecto utilizaremos la opci√≥n de men√∫ File &gt; New &gt; Class. Selecciona src como subcarpeta e introduce HolaMundo como nombre del archivo que contendr√° el programa (clase) que deber√°s escribir a continuaci√≥n. La opci√≥n public static void main(String[] args) debe marcarse para que la clase sea ejecutable (ejecut√°ndose por tanto el m√©todo main de la clase). La Ilustraci√≥n 7 ilustra este proceso.\nIlustraci√≥n . Creaci√≥n de una nueva clase de Java.\nFijaos en que, adem√°s de la carpeta, hemos indicado el nombre de un paquete. Dicho nombre no se puede dejar en blanco, por lo que hemos nombrado practica2. En futuras sesiones de pr√°cticas hablaremos de qu√© es un paquete, y c√≥mo crearlo para estructurar las clases que creemos en cada proyecto.\nAl finalizar la creaci√≥n, se crear√° autom√°ticamente un peque√±o esqueleto con el c√≥digo inicial com√∫n a cada clase, que deber√° completarse para contener el siguiente c√≥digo:\nimport java.util.*;\n\n/**\n * La clase HolaMundo ejemplifica el uso de Eclipse para programar en Java.\n * @author Fernando Bobillo, Alfonso L√≥pez, Ignacio Huitzil.\n */\npublic class HolaMundo\n{\n    /**\n     * El m√©todo main contiene el programa principal.\n     * @param args Puede recibir una lista de par√°metros como argumento.\n     */\n    public static void main(String[] args)\n    {\n        System.out.print(\"Escribe tu nombre: \");\n        String nombre = (new Scanner(System.in)).nextLinea();\n        System.out.println(\"Hola \" + nom + \", mucho gusto.\");\n    }\n}\nEl c√≥digo anterior contiene algunos errores introducidos voluntariamente para que se produzcan errores de compilaci√≥n.\nEl editor de Eclipse es un editor t√≠pico del entorno Windows: se puede copiar, cortar, pegar, buscar y sustituir. Tiene un sistema de tabulaci√≥n inteligente que facilita la tarea de escritura. Se puede conseguir aumentar o disminuir la tabulaci√≥n de una porci√≥n de c√≥digo seleccionando dicha porci√≥n y pulsando tabulador o may√∫sculas-tabulador.\nGuarda los cambios que hemos introducido pulsando los iconos con disquetes que hay en la barra de herramientas superior ( ), pulsando Ctrl-S o bien con File &gt; Save.\n1.5. Compilaci√≥n de aplicaciones\nPara compilar el programa deber√°s utilizar la opci√≥n de men√∫ Project &gt; Build Project en el caso de que no est√© marcada la compilaci√≥n autom√°tica. En este √∫ltimo caso, ser√° suficiente con guardar el fichero para que se compile.\nDentro de las herramientas que se muestran en la porci√≥n inferior, encontramos la subpesta√±a Problems. En esa subpesta√±a se nos informar√° sobre el proceso de compilaci√≥n indicando los posibles errores (ver Ilustraci√≥n 8). Puedes seleccionar cada error mediante doble click, y se indicar√° dentro del c√≥digo d√≥nde se encuentra el error.\nSi trabaj√°semos sin un entorno de desarrollo, ser√≠a equivalente a abrir una ventana de √≥rdenes del sistema operativo y teclear:\njavac HolaMundo.java\nIlustraci√≥n . Compilaci√≥n con errores.\nEl primer error se produce porque el nombre correcto del m√©todo es nextLine; el segundo porque se ha escrito mal la variable nombre. Corrige ambos errores y recompila con Project &gt; Build project. Ahora no te deber√° mostrar ning√∫n error. El fichero compilado se llama HolaMundo.class y se habr√° creado en la subcarpeta bin.\n1.6. Ejecuci√≥n de aplicaciones\nFinalmente, hay que llamar al int√©rprete de la m√°quina virtual. En el entorno Eclipse esto se hace utilizando la opci√≥n de men√∫ Run &gt; Run as: Java application, o mediante el icono de ejecutar en la barra de herramientas superior .\nSi trabaj√°semos directamente con el JDK deber√≠amos invocar al int√©rprete (comando java) pas√°ndole como par√°metro el fichero compilado sin poner la extensi√≥n .class. As√≠ pues, en el int√©rprete de √≥rdenes teclear√≠amos:\njava HolaMundo\n1.7. Depuraci√≥n de errores\nPara depurar los errores de un proyecto, lo ejecutaremos paso a paso para comprender mejor el funcionamiento real del programa, tal y como se ilustra en la Ilustraci√≥n 9.\nIlustraci√≥n . Depuraci√≥n de un programa.\nPara ello, seguimos los siguientes pasos:\nUtiliza la opci√≥n de men√∫ Run &gt; Toggle line breakpoint para establecer (o eliminar) puntos de parada sobre el c√≥digo que queremos ejecutar paso a paso. La ejecuci√≥n paso a paso comenzar√° en la l√≠nea que contenga el punto de ruptura. Tambi√©n se puede utilizar el men√∫ desplegable que aparece al pulsar el bot√≥n derecho del rat√≥n sobre el margen izquierdo de la ventana que muestra el c√≥digo de una clase Java.\nUtiliza la opci√≥n Run &gt; Debug, o Debug  en la barra de herramientas superior, para lanzar la ejecuci√≥n en modo depuraci√≥n de errores. Aparecer√° una ventana de debugger (depurador) con el estado de todas las variables.\nUtiliza Run &gt; Step into (F5) y Run &gt; Step over (F6) para ejecutar el c√≥digo instrucci√≥n a instrucci√≥n. Step over ejecuta las llamadas a m√©todos como sentencias simples (sin entrar a ejecutar paso a paso cada instrucci√≥n dentro del m√©todo).\nPara practicar todo lo visto hasta ahora, haz lo siguiente:\nCrea una nueva clase llamada Ejercicio (comenzando con una letra may√∫scula).\nPega el siguiente c√≥digo en la clase creada.\npackage practica2;\n\npublic class Ejercicio\n{\n        public static void main(String[] args)\n        {\n            int n, x, y, z;\n            n = 10;\n            x = 0;\n            y = 1;\n            z = 1;\n\n            if (n == 0) || (n == 1)\n            {\n                x = 1\n            }\n            else\n            {\n                for (i=2; i&lt;=n; i++)\n                {\n                    int s = y + z;\n                    x = s;\n                    z = y;\n                    y = x;\n                }\n            }\n\n            System.out.println(Programa terminado);\n        }\n}\nSoluciona todos los errores de compilaci√≥n en el programa anterior.\nEjecuta el programa paso a paso para observar cu√°l es el valor que toma la variable x justo antes de finalizar el programa.\n1.8. Exportar e importar proyectos\nLas opciones de exportar e importar proyectos sirven para transferir proyectos de un ordenador a otro. Por ejemplo, podemos exportar un proyecto Eclipse a una carpeta de ficheros ubicada en una memoria USB y, en otro ordenador, importar la carpeta.\nPara exportar un proyecto de Eclipse a una carpeta de ficheros, haremos lo siguiente:\nUtiliza la opci√≥n de men√∫ File &gt; Export y elegir General &gt; File system (ver Ilustraci√≥n 10).\nIlustraci√≥n . Exportar proyectos del workspace.\nMarcaremos el proyecto a exportar y todos sus elementos (carpetas en la parte izquierda, ficheros concretos en la parte izquierda). En general, s√≥lo se suele exportar la carpeta src, dado que los ficheros binarios (bin) se generan a partir de la compilaci√≥n.\nEn la zona To directory se indicar√° el nombre de la carpeta que vamos a crear.\nPulsa Finish para finalizar.\nSi ha ido todo bien, habr√°s generado una carpeta con la estructura de subcarpetas del proyecto actual. Existen otras maneras de exportar proyectos, pero esta es la m√°s sencilla.\nPor otro lado, no es estrictamente necesario exportar el proyecto, sino que es suficiente con guardar los ficheros .java ubicados en la carpeta src.\nPara importar un proyecto tenemos varias alternativas:\nCopiamos la carpeta de ficheros exportada en el workspace del ordenador. Si existe otra carpeta con una versi√≥n previa del proyecto (por ejemplo, si estamos practicando la exportaci√≥n y la importaci√≥n en el mismo ordenador), deberemos borrar la versi√≥n previa para poder importarla correctamente.\nUtilizamos la opci√≥n File &gt; Import y a continuaci√≥n seleccionamos General &gt; Existing projects into workspace (ver Ilustraci√≥n 11).\nIlustraci√≥n . Importar proyectos del workspace.\nCrear un nuevo proyecto a partir de clases Java existentes utilizando la opci√≥n Import  &gt; General &gt; File system. De esta manera, podr√≠amos importar √∫nicamente los ficheros .java sin necesidad de considerar el resto del proyecto.\nPor ahora recomendamos utilizar la opci√≥n General &gt; Existing projects into workspace.\n1.9. Crear y utilizar bibliotecas .jar\nCuando se quiere distribuir una aplicaci√≥n desarrollada en Java que incluye un n√∫mero considerable de clases y paquetes, conviene generar una biblioteca. Las bibliotecas en Java son archivos con extensi√≥n .jar que comprimen (al estilo de los ficheros .zip) un conjunto de clases compiladas (.class) organizadas en paquetes. Se puede explorar el contenido de un fichero .jar con programas de compresi√≥n de ficheros como WinZip.\nPara crear una biblioteca en el entorno Eclipse debemos seleccionar el proyecto que queremos exportar, utilizar la opci√≥n de men√∫ File &gt; Export, seleccionar Java &gt; Runnable JAR File y seguir los siguientes pasos, ilustrados en la Ilustraci√≥n 12:\nEn Launch configuration se elige la clase principal, es decir, la que tiene el m√©todo main que se ejecutar√° una vez que ejecutemos el fichero .jar.\nEn Export destination se indica el nombre del fichero que vamos a crear y la ruta donde se va a almacenar dicho fichero.\nPulsa Finish para finalizar. Si ha ido todo bien, se habr√° generado un fichero .jar.\nIlustraci√≥n . Construcci√≥n de una biblioteca .jar.\nSi el programa se llama HolaMundo.jar, podr√°s ejecutarlo escribiendo en una terminal del sistema operativo lo siguiente:\njava ‚Äìjar HolaMundo.jar\nPara abrir una terminal en Windows, hay que utilizar la barra de b√∫squeda e introducir S√≠mbolo del sistema. Antes de poder ejecutar el .jar con la instrucci√≥n anterior, debemos posicionarnos en la carpeta que lo contenga. Para simplificar, guarda el fichero .jar en la carpeta ra√≠z del disco duro,  C:, y posteriormente escribe en la ventana de √≥rdenes la siguiente instrucci√≥n:\ncd /\n1.10. A√±adir bibliotecas a un proyecto\nSi queremos utilizar alguna de las clases ya definidas en Java, simplemente es necesario a√±adir una sentencia en nuestro programa para importar la biblioteca correspondiente. Por ejemplo, para utilizar las clases definidas en el paquete java.util, hemos a√±adido en nuestro programa la sentencia\nimport java.util.*;\nEl proceso de incluir bibliotecas diferentes a las incluidas por defecto en Java puede no ser sencillo, ya que hay varias opciones para hacerlo de una manera correcta. Entre las distintas opciones que tenemos para incluir bibliotecas est√°n las siguientes:\nSi tenemos un fichero .jar con las clases compiladas, podemos a√±adirlo directamente.\nSi tenemos las clases compiladas pero no un fichero .jar, nos puede interesar incluir el directorio con clases compiladas.\nSi vamos a utilizar una biblioteca com√∫n, es recomendable crear una variable, e incluirla como biblioteca.\nEn este apartado vamos a describir el primer escenario. Para ello, vamos a importar a modo de ejemplo la biblioteca .jar incluida en Moodle, biblioteca.jar.\nAntes de ello, vamos a escribir en nuestro programa la siguiente instrucci√≥n:\nPracticas.escribeMensaje();\nAl compilar, se nos informa de un error: la clase Practicas no ha sido definida todav√≠a. Para solucionarlo, vamos a importar una biblioteca donde se define dicha clase. Debemos hacer click derecho sobre el nombre del proyecto y seleccionar Properties &gt; Java Build Path. Obtendremos una ventana como la de la Ilustraci√≥n 13.\nA continuaci√≥n, hacemos click sobre Add External JARs y seleccionamos el fichero a importar.  Una vez hecho esto, podemos comprobar que es posible ejecutar nuestro programa sin ning√∫n tipo de problemas, pues el c√≥digo necesario se obtiene en el fichero importado.\nIlustraci√≥n . A√±adiendo una biblioteca .jar a un proyecto.\n1.11. Generar documentaci√≥n\nPara generar la documentaci√≥n de las clases y paquetes desarrollados se utiliza la herramienta javadoc, incluida en la JDK. Desde el entorno de Eclipse, se facilita la utilizaci√≥n de esta herramienta a trav√©s de la opci√≥n de men√∫ Project &gt; Generate Javadoc (Ilustraci√≥n 14).\nEn primer lugar, seleccionamos la ubicaci√≥n del ejecutable javadoc con el bot√≥n Configure. Normalmente, Eclipse detecta autom√°ticamente su ubicaci√≥n y rellena este campo por nosotros, por lo que no necesitamos hacer nada.\nA continuaci√≥n, se debe configurar el directorio de salida de la documentaci√≥n utilizando la caja de texto Destination y el bot√≥n Browse asociado.\nPor √∫ltimo, se pulsar√° el bot√≥n Finish para finalizar y generar la documentaci√≥n. La documentaci√≥n podr√° abrirse con cualquier navegador HTML.\nPru√©balo para la clase HolaMundo.\nIlustraci√≥n . Generaci√≥n de documentaci√≥n con la herramienta javadoc."
  },
  {
    "objectID": "practicas/practica2.reveal.html#acceso-a-la-documentaci√≥n-del-jdk",
    "href": "practicas/practica2.reveal.html#acceso-a-la-documentaci√≥n-del-jdk",
    "title": "Pr√°ctica 2: Un entorno de programaci√≥n en Java",
    "section": "1.12. Acceso a la documentaci√≥n del JDK",
    "text": "1.12. Acceso a la documentaci√≥n del JDK\nJava proporciona una amplia y detallada documentaci√≥n acerca de las herramientas que incluye el JDK, as√≠ como la especificaci√≥n de la API (Application Programming Interface), es decir, la documentaci√≥n de las bibliotecas disponibles por defecto en Java. Esta documentaci√≥n est√° accesible en la p√°gina oficial de Oracle (Ilustraci√≥n 15), y lo mismo sucede para la documentaci√≥n de la API (Ilustraci√≥n 16). Esta documentaci√≥n puede descargarse para poder consultarla sin necesidad de acceder a Internet; el material descargado puede visualizarse con cualquier navegador web.\nModifica la clase Ejercicio para que cada vez que se ejecute escriba por pantalla un n√∫mero diferente. Para ello, modifica la instrucci√≥n x = 1 con m√©todos de la clase Math que permitan obtener un n√∫mero enteros aleatorio: primero se obtendr√° un n√∫mero real aleatorio y luego se redondear√° a un n√∫mero entero. Puede buscarse dicho m√©todo en la documentaci√≥n de la clase java.lang.Math.\nx = Math.???(Math.???());\nIlustraci√≥n . Documentaci√≥n del JDK.\nIlustraci√≥n . Documentaci√≥n de la API de Java."
  },
  {
    "objectID": "practicas/practica2.reveal.html#ap√©ndice.-instalaci√≥n-de-eclipse-y-jdk",
    "href": "practicas/practica2.reveal.html#ap√©ndice.-instalaci√≥n-de-eclipse-y-jdk",
    "title": "Pr√°ctica 2: Un entorno de programaci√≥n en Java",
    "section": "Ap√©ndice. Instalaci√≥n de Eclipse y JDK",
    "text": "Ap√©ndice. Instalaci√≥n de Eclipse y JDK\nEn este ap√©ndice explicaremos el proceso de instalaci√≥n del software necesario para realizar las pr√°cticas de Inform√°tica en los ordenadores personales. Existen al menos dos maneras de instalar el software:\nInstalaci√≥n de Eclipse mediante un instalador\nVisita la p√°gina web oficial de Eclipse.\nLocaliza el bot√≥n de Download. Nos llevar√° a la p√°gina de descargas.\nLocaliza el panel de Eclipse Installer (Ilustraci√≥n 17). Debemos reconocer nuestro sistema operativo (Windows, Linux o macOS), y pulsar sobre x86_64.\nUna vez descargado el instalador, lo ejecutamos.\nEl instalador permite obtener m√∫ltiples herramientas de Eclipse, aunque nosotros s√≥lo necesitamos el entorno de desarrollo para Java. La instalaci√≥n es bastante autom√°tica, y simplemente tendremos que seleccionar Eclipse IDE for Java Developers (Ilustraci√≥n 18).\nIlustraci√≥n . Instalador de la suite de Eclipse.\nIlustraci√≥n . Herramientas disponibles en la suite de Eclipse.\nUna vez seleccionada dicha opci√≥n, se nos dirige a una pantalla como la que se muestra en la Ilustraci√≥n 19. El objetivo es configurar dos rutas: la localizaci√≥n de las herramientas de desarrollo para Java y la ruta de instalaci√≥n de Eclipse. Pod√©is personalizar ambas rutas, pero no es recomendable hacerlo. En particular, la primera ruta apunta a un Java Development Kit (JDK), que, si no queremos descargar junto con Eclipse, deber√° instalarse por separado. Esta √∫ltima opci√≥n, aunque es menos sencilla, se describe en el siguiente punto y, entre otras ventajas, permite probar los comandos java y javac en la terminal del ordenador.\nIlustraci√≥n . Instalaci√≥n de Eclipse para Java, indicando que queremos descargar un JRE.\nUna opci√≥n alternativa consiste en indicar la ruta de un Java Runtime Environment (JRE) (versi√≥n 21 o superior) previamente instalado (ver Ilustraci√≥n 20). Para la descarga e instalaci√≥n del JDK de Java, por favor, dir√≠gete a la secci√≥n B.1 del Ap√©ndice. Por ejemplo, en la siguiente imagen, se ha detectado una instalaci√≥n en la ruta C:/Program Files/Java/jdk-25, que es la ruta de instalaci√≥n por defecto de un JDK.\nIlustraci√≥n . Instalaci√≥n de Eclipse para Java, indicando la ruta de un JDK previamente instalado.\nInstalaci√≥n alternativa de Eclipse sin instalador\nInstalaci√≥n del Java Software Development Kit (JDK)\nPara comenzar, debemos descargar la √∫ltima versi√≥n del JDK de la p√°gina web de Oracle:\nDescargamos el JDK de Java de la p√°gina oficial de Oracle. En este momento, la √∫ltima versi√≥n disponible es la 25.\nDebemos seleccionar el sistema operativo de nuestro ordenador personal (Linux, macOS o Windows) y descargar un instalador. En Windows, podemos descargar tanto x64 Installer como x64 MSI Installer.\nUna vez descargado, abrimos el archivo para comenzar el proceso de instalaci√≥n. El proceso es completamente autom√°tico y no habr√° que hacer nada, salvo utilizar el bot√≥n Next para avanzar entre pasos. La ruta de instalaci√≥n por defecto en Windows es C:/Program Files/Java/jdk-25. Se recomienda no modificar esta ruta, salvo que no tengamos espacio en C:.\nIlustraci√≥n . Paso intermedio de la instalaci√≥n del JDK. Se muestra la ruta de instalaci√≥n por defecto, la cual no modificaremos.\nInstalaci√≥n de Eclipse\nVisita la p√°gina web oficial de Eclipse.\nLocaliza el bot√≥n de Download. Nos llevar√° a la p√°gina de descargas.\nPartiendo de un panel similar al de la Ilustraci√≥n 22, reconocemos nuestro sistema operativo y pulsamos sobre x86_64. Se descargar√° un .zip con una carpeta dentro llamada eclipse (ver Ilustraci√≥n 23). Podemos situar dicha carpeta en cualquier directorio de nuestra elecci√≥n, por ejemplo, en la unidad C:. Ten en cuenta que esta opci√≥n no requiere instalaci√≥n, y por tanto, accederemos siempre a dicha carpeta cuando queramos iniciar Eclipse haciendo click sobre eclipse.exe. En la Ilustraci√≥n 23 se muestra el contenido del fichero .zip descomprimido.\nIlustraci√≥n . Panel de descarga de Eclipse sin instalador.\nIlustraci√≥n . Ficheros contenidos en el directorio eclipse, tras descomprimir el fichero .zip descargado de la p√°gina oficial de Eclipse."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "üìå Informaci√≥n general",
    "section": "",
    "text": "En esta p√°gina web se ir√° publicando el material de pr√°cticas actualizado de la asignatura.\nLas pr√°cticas se resolver√°n utilizando herramientas tales como Processing, Eclipse (programaci√≥n en Java), Grasshopper (Rhinoceros) o Proteg√© (ontolog√≠as).\nA tener en cuenta a la hora de resolver las pr√°cticas:\n\nRepresentan el 30% de la nota final de la asignatura.\nSe resolver√°n organiz√°ndose en parejas.\nLa asistencia es obligatoria, y se evaluar√° al final de cada sesi√≥n el trabajo realizado.\nSe recomienda leer cada pr√°ctica antes de la sesi√≥n correspondiente para familiarizarse con los conceptos y herramientas que se van a utilizar.\n\nM√°s informaci√≥n sobre la asignatura en la documentaci√≥n oficial de la universidad.\n\n\n\n\n\n\n\nNotaTutor√≠as\n\n\n\nPuedes encontrar nuestro horario de tutor√≠as en los siguientes enlaces:\n\nTutor√≠as de Alfonso L√≥pez Ruiz\nTutor√≠as de Ignacio Huitzil Velasco\nTutor√≠as de Yamilka Toca D√≠az\n\n\n\n\n\n\n\n\n\n\nTipGet started\n\n\n\n¬°Comienza leyendo la primera pr√°ctica!",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Informaci√≥n",
      "üìå Informaci√≥n general"
    ]
  },
  {
    "objectID": "calendar.html",
    "href": "calendar.html",
    "title": "üìÖ Calendario",
    "section": "",
    "text": "En esta secci√≥n se publicar√° el calendario de pr√°cticas actualizado. Adem√°s:\n\nRecordad que la asistencia a las pr√°cticas es obligatoria.\nAquellas pr√°cticas con una fecha an√≥mala se han marcado con una advertencia ‚ö†Ô∏è.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Informaci√≥n",
      "üìÖ Calendario"
    ]
  },
  {
    "objectID": "practicas/practica1.reveal.html#objetivos-de-la-pr√°ctica",
    "href": "practicas/practica1.reveal.html#objetivos-de-la-pr√°ctica",
    "title": "Pr√°ctica 1: Introducci√≥n a Processing",
    "section": "Objetivos de la pr√°ctica",
    "text": "Objetivos de la pr√°ctica\nLos objetivos de esta pr√°ctica son los siguientes:\n\nFamiliarizaci√≥n con el ordenador y los elementos b√°sicos de un sistema operativo.\nFamiliarizaci√≥n con el entorno de desarrollo Processing.\nFamiliarizaci√≥n con aspectos b√°sicos de programaci√≥n a trav√©s de programas en Processing."
  },
  {
    "objectID": "practicas/practica1.reveal.html#processing",
    "href": "practicas/practica1.reveal.html#processing",
    "title": "Pr√°ctica 1: Introducci√≥n a Processing",
    "section": "Processing",
    "text": "Processing\nIntroducci√≥n\n\n\n\nProcessing es un lenguaje de programaci√≥n y un entorno de desarrollo (Integrated Development Environment, IDE).\n\nBasado en Java.\nProducci√≥n de proyectos multimedia e interactivos.\nCreado por cient√≠ficos del MIT en 2001.\nDistribuci√≥n gratuita y de c√≥digo abierto."
  },
  {
    "objectID": "practicas/practica1.reveal.html#dibujando-figuras-geom√©tricas",
    "href": "practicas/practica1.reveal.html#dibujando-figuras-geom√©tricas",
    "title": "Pr√°ctica 1: Introducci√≥n a Processing",
    "section": "Dibujando figuras geom√©tricas",
    "text": "Dibujando figuras geom√©tricas\nLas figuras geom√©tricas se dibujan en una ventana que est√° formada por una matriz de p√≠xeles. Cada p√≠xel es un peque√±o punto de luz que puede tener un color diferente. La combinaci√≥n de todos los p√≠xeles forma la imagen que vemos en la pantalla."
  },
  {
    "objectID": "practicas/practica1.reveal.html#color-en-processing",
    "href": "practicas/practica1.reveal.html#color-en-processing",
    "title": "Pr√°ctica 1: Introducci√≥n a Processing",
    "section": "Color en Processing",
    "text": "Color en Processing\nEscala de grises\n\n\n\nHasta ahora, hemos dibujado figuras geom√©tricas sin especificar ning√∫n color. Por defecto, las figuras se dibujan en negro sobre un fondo blanco.\nA continuaci√≥n, veremos c√≥mo especificar colores en Processing. Por ahora, basta con componer colores en escala de grises. Para ello hay que tener en cuenta que la escala de un tono de gris va de 0 a 255; el valor 0 corresponde al negro y el valor 255 corresponde al blanco. Por ejemplo, la figura de la derecha se ha representado √∫nica y exclusivamente con diferentes valores de gris.\nEn Processing, las figuras tienen borde y relleno, que se definen mediante los m√©todos stroke y fill. Adem√°s, tambi√©n puede controlarse el color de fondo de la ventana con background.\n\n\n\n\n\n\n\nFigura¬†8: Imagen representada √∫nicamente con valores de gris."
  },
  {
    "objectID": "practicas/practica1.reveal.html#programas-din√°micos",
    "href": "practicas/practica1.reveal.html#programas-din√°micos",
    "title": "Pr√°ctica 1: Introducci√≥n a Processing",
    "section": "Programas din√°micos",
    "text": "Programas din√°micos\nHasta este momento, hemos escrito programas est√°ticos, es decir, programas que dibujan una imagen fija. A continuaci√≥n, veremos c√≥mo crear programas din√°micos que pueden cambiar con el tiempo."
  },
  {
    "objectID": "practicas/practica1.reveal.html#variables-condicionales-y-bucles",
    "href": "practicas/practica1.reveal.html#variables-condicionales-y-bucles",
    "title": "Pr√°ctica 1: Introducci√≥n a Processing",
    "section": "Variables, condicionales y bucles",
    "text": "Variables, condicionales y bucles\nIntroducci√≥n a variables\nEn la secci√≥n anterior hemos descubierto que el m√©todo draw se ejecuta de manera repetitiva en un bucle infinito. Esto nos permite crear programas din√°micos que cambian con el tiempo. Sin embargo, para crear programas m√°s complejos, es necesario utilizar variables para almacenar datos que pueden cambiar durante la ejecuci√≥n del programa.\n\n\n\n\n\n\nüß† Ejercicio 14 - Traslada una esfera\n\n\nCrea un programa que traslade una esfera de izquierda a derecha en la ventana. Utiliza una variable para almacenar la posici√≥n horizontal de la esfera, y actual√≠zala en cada iteraci√≥n del bucle draw.\n\n\nüí° Soluci√≥n\n\nint circleX = 100;\nint circleY = 100;\n\nvoid setup() {\n  size(400, 200);\n}\n\nvoid draw() {\n  background(255);\n  stroke(0);\n  fill(175);\n  ellipse(circleX, circleY, 50, 50);\n  circleX = circleX + 1;\n}"
  },
  {
    "objectID": "practicas/practica1.reveal.html#ap√©ndice-instalaci√≥n-de-processing",
    "href": "practicas/practica1.reveal.html#ap√©ndice-instalaci√≥n-de-processing",
    "title": "Pr√°ctica 1: Introducci√≥n a Processing",
    "section": "Ap√©ndice: Instalaci√≥n de Processing",
    "text": "Ap√©ndice: Instalaci√≥n de Processing\n\n\nFigura¬†15: Banner de la p√°gina oficial de Processing; a la izquierda se muestra el bot√≥n de Download.\n\nAccede a la p√°gina oficial de Processing y selecciona Download.\nDescarga la versi√≥n correspondiente a tu sistema operativo.\nEjecuta el instalador descargado y sigue las instrucciones."
  },
  {
    "objectID": "practicas/practica1.html",
    "href": "practicas/practica1.html",
    "title": "Pr√°ctica 1: Introducci√≥n a Processing",
    "section": "",
    "text": "Los objetivos de esta pr√°ctica son los siguientes:\n\nFamiliarizaci√≥n con el ordenador y los elementos b√°sicos de un sistema operativo.\nFamiliarizaci√≥n con el entorno de desarrollo Processing.\nFamiliarizaci√≥n con aspectos b√°sicos de programaci√≥n a trav√©s de programas en Processing.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Pr√°cticas",
      "Pr√°ctica 1: Introducci√≥n a Processing"
    ]
  },
  {
    "objectID": "practicas/practica1.html#objetivos-de-la-pr√°ctica",
    "href": "practicas/practica1.html#objetivos-de-la-pr√°ctica",
    "title": "Pr√°ctica 1: Introducci√≥n a Processing",
    "section": "",
    "text": "Los objetivos de esta pr√°ctica son los siguientes:\n\nFamiliarizaci√≥n con el ordenador y los elementos b√°sicos de un sistema operativo.\nFamiliarizaci√≥n con el entorno de desarrollo Processing.\nFamiliarizaci√≥n con aspectos b√°sicos de programaci√≥n a trav√©s de programas en Processing.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Pr√°cticas",
      "Pr√°ctica 1: Introducci√≥n a Processing"
    ]
  },
  {
    "objectID": "practicas/practica1.html#processing",
    "href": "practicas/practica1.html#processing",
    "title": "Pr√°ctica 1: Introducci√≥n a Processing",
    "section": "2 Processing",
    "text": "2 Processing\n\n2.1 Introducci√≥n\n\n\n\nProcessing es un lenguaje de programaci√≥n y un entorno de desarrollo (Integrated Development Environment, IDE).\n\nBasado en Java.\nProducci√≥n de proyectos multimedia e interactivos.\nCreado por cient√≠ficos del MIT en 2001.\nDistribuci√≥n gratuita y de c√≥digo abierto.\n\n\n\n\n\n\n\n\nLa propia p√°gina de Processing muestra numerosos ejemplos de proyectos realizados con este lenguaje. Tambi√©n hay muchos ejemplos en Youtube, en particular, en el canal de The Coding Train.\n\n\n\n\n\n\n\n\n\nFigura¬†1: Visualizaci√≥n del fractal de Mandelbrot.\n\n\n\n\n\n\n\n\n\n\n\nFigura¬†2: Canal de Youtube The Coding Train.\n\n\n\n\n\n\n\n\n\n2.2 El entorno de desarrollo\nEl entorno de desarrollo de Processing tiene un dise√±o minimalista que facilita su uso. La interfaz gr√°fica est√° compuesta por los siguientes elementos principales:\n\nUn men√∫ de opciones (archivo, editar, sketch, depuraci√≥n, herramientas y ayuda).\nDos botones para ejecutar y detener el programa.\nUn √°rea central para escribir el c√≥digo fuente (editor).\nUna ventana inferior donde se muestran dos pesta√±as:\n\nConsola: salida est√°ndar del programa.\nErrores: mensajes de error generados durante la ejecuci√≥n.\n\n\n\nAl ejecutar un programa se abrir√° una nueva ventana donde se mostrar√° el resultado de la ejecuci√≥n.\n\n\n\n\n\n\nFigura¬†3: Vista del entorno de desarrollo (derecha) y ventana pop-up (izquierda) que redirige a ejemplos disponibles en su p√°gina web.\n\n\n\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nEl primer archivo que se crea en un nuevo proyecto de Processing se denomina sketch_yymmdda. Es recomendable cambiar el nombre del archivo para que tenga sentido con el programa que se va a desarrollar. Adem√°s, al guardarlo nos preguntar√° el nombre del proyecto, que tambi√©n es recomendable que tenga sentido.\nIndicad una ubicaci√≥n de f√°cil acceso en vuestro ordenador para guardar los proyectos de Processing.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Pr√°cticas",
      "Pr√°ctica 1: Introducci√≥n a Processing"
    ]
  },
  {
    "objectID": "practicas/practica1.html#dibujando-figuras-geom√©tricas",
    "href": "practicas/practica1.html#dibujando-figuras-geom√©tricas",
    "title": "Pr√°ctica 1: Introducci√≥n a Processing",
    "section": "3 Dibujando figuras geom√©tricas",
    "text": "3 Dibujando figuras geom√©tricas\nLas figuras geom√©tricas se dibujan en una ventana que est√° formada por una matriz de p√≠xeles. Cada p√≠xel es un peque√±o punto de luz que puede tener un color diferente. La combinaci√≥n de todos los p√≠xeles forma la imagen que vemos en la pantalla.\n\nUn p√≠xel es la unidad m√°s peque√±a de una imagen digital. La resoluci√≥n de una imagen se refiere a la cantidad de p√≠xeles que contiene, y se expresa como el n√∫mero de p√≠xeles en el eje horizontal por el n√∫mero de p√≠xeles en el eje vertical (por ejemplo, 1920x1080 p√≠xeles). Por ejemplo, la Figura¬†4 muestra una animaci√≥n con una resoluci√≥n alta, donde los p√≠xeles no son visibles a simple vista. En cambio, en la Figura¬†5 se ha reducido la resoluci√≥n de la animaci√≥n, y comienzan a ser visibles los p√≠xeles individuales.\n\n\n\n\n\n\nVideo\n\n\nFigura¬†4: Animaci√≥n con una resoluci√≥n de pantalla alta.\n\n\n\n\n\n\n\n\nVideo\n\n\nFigura¬†5: Animaci√≥n con una resoluci√≥n de pantalla m√°s baja, donde comienzan a ser visibles los p√≠xeles.\n\n\n\n\n\n\n\n\n\n\nPara dibujar cualquier figura geom√©trica, es necesario especificar una o varias posiciones en la ventana. Dichas posiciones se definen mediante un par de coordenadas (x, y), donde x indica la posici√≥n horizontal e y la posici√≥n vertical. En Processing, el origen de coordenadas (0,0) se encuentra en la esquina superior izquierda de la ventana, como se muestra en la Figura¬†6.\n\n\n\n\n\n\nNotaüß† Ejercicio 1 - Sistema de coordenadas\n\n\n\nDibuja una l√≠nea que va desde la posici√≥n (10, 0) hasta la posici√≥n (40, 50). Cuando se ejecute, os podr√©is dar cuenta de que el origen, (0,0), parte de la esquina superior izquierda.\nline(10, 0, 40, 50);\n\n\n\n\n\n\n\n\n\n\nFigura¬†6: Ilustraci√≥n de una matriz de p√≠xeles, indicando las coordenadas de algunos de ellos.\n\n\n\n\n\n\n\nEste concepto puede entenderse como darle un nombre a un conjunto de instrucciones para poder reutilizarlas f√°cilmente m√°s adelante. En matem√°ticas, una funci√≥n toma uno o varios valores de entrada y produce un valor de salida siguiendo una regla. Por ejemplo, la funci√≥n \\(f(x) = x^2\\) toma un n√∫mero \\(x\\) y devuelve su cuadrado.\nEn programaci√≥n ocurre algo muy similar: una funci√≥n recibe unos par√°metros, ejecuta unas instrucciones con ellos y, opcionalmente, devuelve un resultado.\n\nPor ejemplo, podemos definir en Java una funci√≥n que reciba un n√∫mero entero y devuelva su cuadrado:\nint square(int x) {\n  return x * x;\n}\nUna vez definida, podemos usar la funci√≥n tantas veces como queramos, simplemente indicando el valor de entrada:\nint result = square(5);  // result tendr√° el valor 25\nDe este modo:\n\nsquare es el nombre de la funci√≥n.\nx es el par√°metro de entrada.\nreturn indica el valor que devuelve la funci√≥n.\n\nEn Processing ocurre exactamente lo mismo. La funci√≥n line, por ejemplo, recibe cuatro par√°metros (las coordenadas de dos puntos) y ejecuta una acci√≥n: dibujar una l√≠nea en la ventana. La diferencia es que, en este caso, la funci√≥n no devuelve un valor, sino que produce un efecto visual en pantalla.\n\n\n\n\n\n\n\nAdvertenciaEjercicio 2 - Errores comunes\n\n\n\nPrueba a copiar el siguiente c√≥digo en el editor de Processing y ejecutarlo:\nLine(10, 0, 40, 50);\n\n\nüí° Soluci√≥n\n\nProcessing es sensible al uso de may√∫sculas y min√∫sculas. Por ejemplo, la funci√≥n para dibujar una l√≠nea es line, no Line ni LINE.\nLas palabras reservadas se muestran resaltadas en el editor, por lo que esta es una manera de ver si el nombre de una funci√≥n est√° bien escrito. Los errores se muestran en la pesta√±a Errores de la ventana inferior.\n\n\n\n\n\n\n\n\n\nNotaüß† Ejercicio 3 - M√∫ltiples formas geom√©tricas\n\n\n\nPrueba a dibujar varias l√≠neas en diferentes posiciones de la pantalla, utilizando la instrucci√≥n line varias veces.\n\n\n\n\n3.1 Lienzo\nLas figuras geom√©tricas se dibujan sobre un lienzo de tama√±o predeterminado 100x100 p√≠xeles. No obstante, es posible cambiar el tama√±o del lienzo utilizando la funci√≥n size, que recibe dos par√°metros: el ancho y el alto del lienzo en p√≠xeles.\n\n\n\n\n\n\nNotaüß† Ejercicio 4 - Tama√±o del lienzo\n\n\n\nDibuja varias l√≠neas en un lienzo de tama√±o 300x200 p√≠xeles.\n\n\nüí° Soluci√≥n\n\nsize(300, 200);\nline(10, 0, 40, 50);\nline(100, 50, 200, 150);\nline(250, 0, 250, 200);\n\n\n\n\n\n\n3.2 Tipos de figuras geom√©tricas\nAdem√°s de la l√≠nea utilizada en los ejercicios anteriores, Processing permite dibujar otras figuras geom√©tricas b√°sicas, tales como puntos, tri√°ngulos, cuadril√°teros, rect√°ngulos y elipses.\n\n\n\n\n\n\nNotaüß† Ejercicio 5 - Deducci√≥n de par√°metros\n\n\n\n¬øPuedes deducir qu√© par√°metros son necesarios para dibujar algunas de las figuras geom√©tricas mencionadas anteriormente? Puedes consultar la documentaci√≥n oficial de Processing, y m√°s concretamente, la secci√≥n 2d primitives en el apartado Shape.\n\n\nüí° Soluci√≥n\n\n\npoint(x, y): un punto en la posici√≥n (x, y).\ntriangle(x1, y1, x2, y2, x3, y3): un tri√°ngulo con v√©rtices en las posiciones (x1, y1), (x2, y2) y (x3, y3).\nquad(x1, y1, x2, y2, x3, y3, x4, y4): un cuadril√°tero con v√©rtices en las posiciones (x1, y1), (x2, y2), (x3, y3) y (x4, y4).\nrect(x, y, anchura, altura): un rect√°ngulo con esquina superior izquierda en la posici√≥n (x, y), de anchura y altura especificadas.\nellipse(x, y, anchura, altura): una elipse centrada en la posici√≥n (x, y), con anchura y altura especificadas.\n\n\n\n\n\n\n3.2.1 Dibujando rect√°ngulos y elipses\nTanto en la documentaci√≥n oficial, como en la soluci√≥n del ejercicio anterior, os habr√©is podido dar cuenta de que las funciones rect y ellipse requieren cuatro par√°metros: dos para la posici√≥n y dos para el tama√±o. Sin embargo, hemos asumido que la posici√≥n siempre corresponde a la esquina superior izquierda del rect√°ngulo o al centro de la elipse. Esta suposici√≥n es correcta por defecto, pero es posible cambiarla utilizando las funciones rectMode y ellipseMode. M√°s concretamente, estas funciones permiten definir c√≥mo se interpretan las posiciones pasadas como par√°metros a las funciones rect y ellipse. Existen dos modos principales para cada una de estas funciones:\n\nCORNER: la posici√≥n corresponde a la esquina superior izquierda del rect√°ngulo o elipse.\nCENTER: la posici√≥n corresponde al centro del rect√°ngulo o elipse.\n\n\n\n\n\n\n\n\nFigura¬†7: Representaci√≥n de c√≥mo se interpretan las posiciones en ambos modos para rect√°ngulos y elipses.\n\n\n\n\nPor defecto, Processing interpreta las posiciones de la siguiente manera:\nrectMode(CORNER);\nellipseMode(CENTER);\nTambi√©n es posible cambiar esta interpretaci√≥n usando:\nrectMode(CENTER);\nellipseMode(CORNER);\n\n\n\n\n\n\nNotaüß† Ejercicio 6 - Modo de dibujo\n\n\n\nIntenta dibujar un c√≠rculo centrado en (20, 30) con radio 10 utilizando ambos modos. En el siguiente c√≥digo tienes todas las instrucciones necesarias para completar el ejercicio:\n// Modo por defecto\nellipseMode(CENTER);\nellipse( , , , );\n\n// Modo alternativo\nellipseMode(CORNER);\nellipse( , , , );",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Pr√°cticas",
      "Pr√°ctica 1: Introducci√≥n a Processing"
    ]
  },
  {
    "objectID": "practicas/practica1.html#color-en-processing",
    "href": "practicas/practica1.html#color-en-processing",
    "title": "Pr√°ctica 1: Introducci√≥n a Processing",
    "section": "4 Color en Processing",
    "text": "4 Color en Processing\n\n4.1 Escala de grises\n\n\n\nHasta ahora, hemos dibujado figuras geom√©tricas sin especificar ning√∫n color. Por defecto, las figuras se dibujan en negro sobre un fondo blanco.\nA continuaci√≥n, veremos c√≥mo especificar colores en Processing. Por ahora, basta con componer colores en escala de grises. Para ello hay que tener en cuenta que la escala de un tono de gris va de 0 a 255; el valor 0 corresponde al negro y el valor 255 corresponde al blanco. Por ejemplo, la figura de la derecha se ha representado √∫nica y exclusivamente con diferentes valores de gris.\nEn Processing, las figuras tienen borde y relleno, que se definen mediante los m√©todos stroke y fill. Adem√°s, tambi√©n puede controlarse el color de fondo de la ventana con background.\n\n\n\n\n\n\n\n\nFigura¬†8: Imagen representada √∫nicamente con valores de gris.\n\n\n\n\n\n\n\nPor ejemplo, podemos definir el color del fondo, as√≠ como del borde y el relleno de un rect√°ngulo de la siguiente manera:\nbackground(0);              // fondo \n\nstroke(200);                // borde\nfill(100);                  // relleno\nrect(50, 50, 100, 100);\nAdem√°s, cabe destacar que Processing funciona como una m√°quina de estados; es decir, una vez se indica el color de borde o de relleno, este se utilizar√° para todas las figuras que se dibujen a continuaci√≥n. Por ejemplo, podemos dibujar dos rect√°ngulos con el mismo color de borde, pero diferente color de relleno, de la siguiente manera:\nstroke(0);\nfill(150);\nrect(20, 20, 50, 50);       // borde negro, relleno gris\n\nfill(50);\nrect(80, 20, 50, 50);       // mismo borde, diferente relleno\n\n\n\n\n\n\n\n\n\n\nNotaüß† Ejercicio 7 - C√≠rculo y colores\n\n\n\nDibuja un c√≠rculo negro con borde gris, centrado en (20, 30) y con radio 10.\n\n\nüí° Soluci√≥n\n\nstroke(128);\nfill(0);\nellipse(20, 30, 20, 20);\n\n\n\nIntenta crear un lienzo de tama√±o 30x30 y repite este ejercicio. ¬øQu√© sucede ahora?\n\n\n\n\n\n\n\n\nNotaüß† Ejercicio 8 - Dibuja una forma geom√©trica\n\n\n\nTrata de obtener algo parecido a la figura que se muestra debajo.\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.2 Colores RGB (red, green, blue)\n\n\n\n\n\n\n\n\n\nFigura¬†9: Representaci√≥n de los colores primarios RGB.\n\n\n\n\n\nAdem√°s de diferentes tonos de gris, Processing permite definir colores a partir de los tres colores primarios: rojo, verde y azul (RGB). Cuando los tres componentes toman el valor m√°ximo (255), el color resultante es el blanco. En una escala de grises, los tres valores RGB coinciden; por ejemplo, el color (0, 0, 0) corresponde al negro. Por otro lado, si s√≥lo activamos un canal con 255, y dejamos el resto a 0, obtenemos rojo, verde o azul.\nfill(255, 0, 0);  // rojo\nfill(0, 255, 0);  // verde\nfill(0, 0, 255);  // azul\n\n\n\n\n\n\n\n\n\nNotaüß† Ejercicio 9 - Colores RGB\n\n\n\n¬øSabr√≠as decir qu√© colores crear√°n las siguientes combinaciones de rojo, verde y azul?\n\nfill(255, 255, 0)\nfill(0, 255, 255)\nfill(255, 0, 255)\nfill(255, 255, 127)\nfill(127, 255, 255)\nfill(255, 127, 255)\n\nPista: f√≠jate en la Figura¬†9.\n\n\n\n\n\n\n\n\n\n\n\n\nFigura¬†10: Captura de pantalla del selector de color de Processing.\n\n\n\n\n\nComo habr√©is podido observar a partir del Ejercicio 9, no es sencillo imaginar qu√© color genera una mezcla concreta de valores RGB, ni determinar qu√© valores exactos u aproximados de rojo, verde y azul necesitamos para componer un color que tengamos en mente. Por esta raz√≥n, Processing dispone de una herramienta, Selector de color, que permite interactuar con una paleta de colores y obtener valores de rojo, verde y azul. Pod√©is acceder a esta herramienta desde el men√∫ Herramientas &gt; Selector de color.\n\n\n\n\n\n\n4.3 Opacidad\nAdem√°s de los canales R, G y B, tambi√©n podemos indicar un valor de opacidad. De esta manera, un valor de opacidad de 255 indica que elemento a dibujar es completamente opaco, y un valor de 0 indica que es completamente transparente. Para especificar la opacidad, bastante con indicar un cuarto valor en operaciones como stroke o fill.\nfill(255, 255, 127);\nrect(50, 50, 100, 100);     // rect√°ngulo opaco     \n\nfill(255, 0, 127, 127);     \nrect(20, 20, 50, 50);       // rect√°ngulo semitransparente",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Pr√°cticas",
      "Pr√°ctica 1: Introducci√≥n a Processing"
    ]
  },
  {
    "objectID": "practicas/practica1.html#programas-din√°micos",
    "href": "practicas/practica1.html#programas-din√°micos",
    "title": "Pr√°ctica 1: Introducci√≥n a Processing",
    "section": "5 Programas din√°micos",
    "text": "5 Programas din√°micos\nHasta este momento, hemos escrito programas est√°ticos, es decir, programas que dibujan una imagen fija. A continuaci√≥n, veremos c√≥mo crear programas din√°micos que pueden cambiar con el tiempo.\n\n\n\n\nComenzaremos con este bloque de c√≥digo:\nsize(600, 600);\n\n// Fondo blanco\nbackground(255);\n\n// Coordenadas desde el centro\nellipseMode(CENTER);\nrectMode(CENTER);\n\n// CUERPO\nstroke(0);\nfill(150);\nrect(200, 260, 50, 260);\n\n// CABEZA\nfill(255);\nellipse(200, 160, 130, 160);\n\n// OJOS\nfill(0);\nellipse(170, 160, 30, 60);\nellipse(230, 160, 30, 60);\n\n// PIERNAS\nstroke(0);\nline(175, 390, 150, 420);\nline(226, 390, 250, 420);\n\n\n\n\n\n\n\n\nFigura¬†11: Imagen del alien√≠gena Zoog.\n\n\n\n\n\n\n\n\n\nNotaüß† Ejercicio 10 - Dibuja a Zoog\n\n\n\nIntenta dibujar al alien√≠gena Zoog utilizando el bloque de c√≥digo anterior como referencia.\n\n\n\n\n\n\n\n5.1 Comentarios\nAprovechando que nuestro programa empieza a ser un poco m√°s largo, es recomendable a√±adir comentarios para explicar qu√© hace cada parte del c√≥digo. En Processing, los comentarios se indican con // para comentarios de una sola l√≠nea, o con /* y */ para comentarios multil√≠nea. Adem√°s de para indicar qu√© hace una parte de nuestro c√≥digo, tambi√©n se pueden usar para desactivar temporalmente l√≠neas de c√≥digo durante la depuraci√≥n. Por ejemplo, en el siguiente c√≥digo se han a√±adido comentarios para explicar qu√© parte del cuerpo de Zoog dibuja cada bloque de instrucciones, y para desactivar el dibujo de la cabeza temporalmente:\n// Dibuja el cuerpo de Zoog\nrect(200, 260, 50, 260);\n\n/* Dibuja la cabeza de Zoog en la posici√≥n (200, 140) con ancho y alto 120 */\n//ellipse(200, 160, 130, 160);        // Desactivado temporalmente\n\n// Dibuja los ojos de Zoog\n/*ellipse(170, 160, 30, 60);\nellipse(230, 160, 30, 60);*/          // Ojo derecho\n\n\n\n5.2 Funciones setup y draw\nCuando ejecutamos un programa en Processing, el c√≥digo no se ejecuta de arriba a abajo una sola vez, sino que utiliza un modelo de ejecuci√≥n basado en dos fases bien diferenciadas: setup() y draw().\n\n\n\n\n\nAl pulsar el bot√≥n ‚ñ∂Ô∏è, Processing inicia el programa y lo primero que hace es llamar a la funci√≥n setup().\nLa funci√≥n setup() se ejecuta una √∫nica vez al comienzo del programa. Su objetivo es preparar el entorno antes de empezar a dibujar. En esta funci√≥n se suele definir el tama√±o de la ventana, inicializar variables, configurar colores o modos de dibujo y cargar recursos como im√°genes o fuentes. Una vez que setup() termina, Processing no vuelve a ejecutarla.\nDespu√©s de setup(), Processing entra autom√°ticamente en la funci√≥n draw(). La funci√≥n draw() se ejecuta repetidamente, normalmente unas sesenta veces por segundo. En cada ejecuci√≥n se dibuja un nuevo fotograma y se actualizan posiciones o estados. Gracias a este bucle continuo es posible crear animaciones, juegos y visualizaciones interactivas.\n\n\n\n\n\n\n\nFigura¬†12: Analog√≠a del funcionamiento de Processing, y el proceso de animaci√≥n. El resultado final se compone de varias llamadas a draw, y en cada llamada, se dibujan m√∫ltiples tipos de geometr√≠a.\n\n\n\n\n\n\n\n\n\n\nflowchart TD\n    A[\"El programa comienza\"]\n    B[\"setup()\"]\n    C[\"Inicializa ventana y variables\"]\n    D[\"setup() termina\"]\n    E[\"draw()\"]\n    F[\"Dibuja un fotograma\"]\n    G[\"Actualiza estado\"]\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    D --&gt; E\n    E --&gt; F\n    F --&gt; G\n    G --&gt; E\n\n\n\n\n\n\n\n\n\n\nTanto setup como draw son funciones especiales que no requieren ser llamadas expl√≠citamente en el c√≥digo; Processing se encarga de ello autom√°ticamente. Por ahora, s√≥lo cabe destacar que el c√≥digo que se encuentra dentro de una funci√≥n debe estar sangrado (indentado) para indicar que pertenece a dicha funci√≥n. Adem√°s, ambas funciones devuelven void, lo que significa que no devuelven ning√∫n valor. Tambi√©n es importante abrir y cerrar llaves {} para definir el bloque de c√≥digo que pertenece a cada funci√≥n.\n\n\n\n\n\n\n\nNotaüß† Ejercicio 11 - Zoog, utilizando setup y draw\n\n\n\nReescribe el c√≥digo de Zoog utilizando las funciones setup y draw. ¬øNotas alguna diferencia en el resultado respecto al c√≥digo original?\nvoid setup() {\n  // Tama√±o del lienzo\n  size(600, 600);\n}\n\nvoid draw() {\n  // Fondo blanco\n  background(255);\n\n  // Coordenadas desde el centro\n  ellipseMode(CENTER);\n  rectMode(CENTER);\n\n  // CUERPO\n  stroke(0);\n  fill(150);\n  rect(200, 260, 50, 260);\n\n  // CABEZA\n  fill(255);\n  ellipse(200, 160, 130, 160);\n\n  // OJOS\n  fill(0);\n  ellipse(170, 160, 30, 60);\n  ellipse(230, 160, 30, 60);\n\n  // PIERNAS\n  stroke(0);\n  line(175, 390, 150, 420);\n  line(226, 390, 250, 420);\n}\n\n\n\n\n\n\n\n\n\nAdvertenciaüî¥ Color de fondo\n\n\n\nPrueba a mover la instrucci√≥n background(255); desde la funci√≥n draw a la funci√≥n setup. ¬øQu√© ocurre?\n\n\n\n\n\n5.3 Interacci√≥n con el rat√≥n\nEn Processing existen algunas palabras reservadas como width y height, que permiten acceder al ancho y alto de la ventana, respectivamente, y otras que permiten interactuar con el usuario, como mouseX y mouseY, que indican la posici√≥n actual del rat√≥n en la ventana.\n\n\n\n\n\n\n\n\n\n\nNotaüß† Ejercicio 12 - Sigue al rat√≥n\n\n\n\nModifica el programa de Zoog para que la esquina superior izquierda del cuerpo de Zoog sea la posici√≥n del rat√≥n, utilizando mouseX y mouseY.\n\n\n\n\n\n\n\n\nNotaüß† Ejercicio 13 - Sigue al rat√≥n II\n\n\n\nPosiciona la cabeza de Zoog sobre el cuerpo, de acuerdo tambi√©n a las coordenadas (mouseX, mouseY), de manera que la cabeza se mueva en funci√≥n de la posici√≥n del rat√≥n. Por supuesto, tendr√°s que ajustar tambi√©n la posici√≥n de los ojos.\n\n\n\n\n\n\n\n\nNotaüß† Ejercicio extra - Sigue al rat√≥n III\n\n\n\nIntenta que las piernas de Zoog tambi√©n sigan al rat√≥n, manteniendo la misma distancia relativa con el cuerpo.\n\n\n\n\n\n\n\n\n\n\nFigura¬†13: Algunas medidas de Zoog.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Pr√°cticas",
      "Pr√°ctica 1: Introducci√≥n a Processing"
    ]
  },
  {
    "objectID": "practicas/practica1.html#variables-condicionales-y-bucles",
    "href": "practicas/practica1.html#variables-condicionales-y-bucles",
    "title": "Pr√°ctica 1: Introducci√≥n a Processing",
    "section": "6 Variables, condicionales y bucles",
    "text": "6 Variables, condicionales y bucles\n\n6.1 Introducci√≥n a variables\nEn la secci√≥n anterior hemos descubierto que el m√©todo draw se ejecuta de manera repetitiva en un bucle infinito. Esto nos permite crear programas din√°micos que cambian con el tiempo. Sin embargo, para crear programas m√°s complejos, es necesario utilizar variables para almacenar datos que pueden cambiar durante la ejecuci√≥n del programa.\n\n\n\n\n\n\nNotaüß† Ejercicio 14 - Traslada una esfera\n\n\n\nCrea un programa que traslade una esfera de izquierda a derecha en la ventana. Utiliza una variable para almacenar la posici√≥n horizontal de la esfera, y actual√≠zala en cada iteraci√≥n del bucle draw.\n\n\nüí° Soluci√≥n\n\nint circleX = 100;\nint circleY = 100;\n\nvoid setup() {\n  size(400, 200);\n}\n\nvoid draw() {\n  background(255);\n  stroke(0);\n  fill(175);\n  ellipse(circleX, circleY, 50, 50);\n  circleX = circleX + 1;\n}\n\n\n\n\n\n\n6.2 Condicionales\nLos condicionales permiten ejecutar diferentes bloques de c√≥digo en funci√≥n de si se cumple o no una determinada condici√≥n. En Processing, los condicionales se implementan utilizando las palabras reservadas if, else if y else.\nLa sintaxis b√°sica de un condicional es la siguiente:\nif (condici√≥n) {\n  // bloque de c√≥digo si la condici√≥n es verdadera\n} else if (otra_condici√≥n) {\n  // bloque de c√≥digo si la otra condici√≥n es verdadera\n} else {\n  // bloque de c√≥digo si ninguna condici√≥n es verdadera\n}\nTen en cuenta que no siempre es necesario utilizar else if o else; un condicional puede consistir √∫nicamente en una instrucci√≥n if.\n\n\n\n\n\n\n\nNotaüß† Ejercicio 15 - Color de fondo interactivo\n\n\n\nModifica el programa de Zoog para que el color de fondo cambie en funci√≥n de la posici√≥n del rat√≥n. Por ejemplo, si el rat√≥n se encuentra en el primer tercio de la ventana, el fondo debe ser blanco; si est√° en el segundo tercio, el fondo debe ser gris; y si est√° en el tercer tercio, el fondo debe ser negro.\nüí° Pista: en el c√≥digo que hemos utilizado para dibujar a Zoog se define una ventana de tama√±o 600x600. Puedes comprobar si mouseX o mouseY se encuentran en un determinado tercio de la pantalla:\nif (mouseX &lt; 200) {\n    ...\n}\nelse if (...) {\n    ...\n}\nelse {\n    ...\n}\n\n\n\n\n\n6.3 Bucles\nExisten algunas palabras reservadas en Java para representar bucles, es decir, bloques de c√≥digo que se repiten durante un n√∫mero de iteraciones, o infinitamente hasta que no se cumpla alguna condici√≥n.\nEn esta sesi√≥n es suficiente con conocer el bucle for, que permite ejecutar un bloque de c√≥digo un n√∫mero determinado de veces. La sintaxis b√°sica de un bucle for es la siguiente:\nfor (int i = 1; i &lt;= N; i++) {\n  // bloque de c√≥digo a ejecutar N veces\n}\n\n\n\n\n\n\n\nNotaüß† Ejercicio 16 - M√∫ltiples Zoog\n\n\n\nEl objetivo es mostrar 2 Zoogs en la pantalla a partir del programa de un √∫nico Zoog. Ten en cuenta que tendr√°s que modificar la posici√≥n de al menos uno de ellos para que sea visible.\nA modo de inspiraci√≥n, el siguiente c√≥digo dibuja dos rect√°ngulos desplazados en el eje horizontal y vertical en funci√≥n de i:\nsize(500, 200);\n\nint N = 2;\nfloat offsetX = 0;\nfloat offsetY = 0;\n\nfor (int i = 1; i &lt;= N; i++) {\n  rect(50 + offsetX, 20 + offsetY, 80, 80);\n\n  offsetX += 100;\n  offsetY += 10;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nNotaüß† Ejercicio 17 - Z pares de brazos\n\n\n\nModifica el programa de Zoog para que dibuje Z pares de brazos, donde Z es una variable que puedes definir al principio del programa. Utiliza un bucle for para dibujar los brazos.\n\n\n\n\n\n\n\n\n\n\nFigura¬†14: Resultado de a√±adir 3 pares de brazos a Zoog.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Pr√°cticas",
      "Pr√°ctica 1: Introducci√≥n a Processing"
    ]
  },
  {
    "objectID": "practicas/practica1.html#ap√©ndice-instalaci√≥n-de-processing",
    "href": "practicas/practica1.html#ap√©ndice-instalaci√≥n-de-processing",
    "title": "Pr√°ctica 1: Introducci√≥n a Processing",
    "section": "Ap√©ndice: Instalaci√≥n de Processing",
    "text": "Ap√©ndice: Instalaci√≥n de Processing\n\n\n\n\n\n\nFigura¬†15: Banner de la p√°gina oficial de Processing; a la izquierda se muestra el bot√≥n de Download.\n\n\n\n\nAccede a la p√°gina oficial de Processing y selecciona Download.\nDescarga la versi√≥n correspondiente a tu sistema operativo.\nEjecuta el instalador descargado y sigue las instrucciones.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Pr√°cticas",
      "Pr√°ctica 1: Introducci√≥n a Processing"
    ]
  },
  {
    "objectID": "practicas/practica3.reveal.html#objetivos-de-la-pr√°ctica",
    "href": "practicas/practica3.reveal.html#objetivos-de-la-pr√°ctica",
    "title": "Pr√°ctica 3: Resoluci√≥n de problemas en Java (I)",
    "section": "Objetivos de la pr√°ctica",
    "text": "Objetivos de la pr√°ctica\n\nAlgoritmos para la resoluci√≥n de problemas.\nImplementar algoritmos en Java.\nEjecutar algoritmos en el entorno Eclipse."
  },
  {
    "objectID": "practicas/practica3.reveal.html#ra√≠ces-de-una-ecuaci√≥n-de-segundo-grado",
    "href": "practicas/practica3.reveal.html#ra√≠ces-de-una-ecuaci√≥n-de-segundo-grado",
    "title": "Pr√°ctica 3: Resoluci√≥n de problemas en Java (I)",
    "section": "Ra√≠ces de una ecuaci√≥n de segundo grado",
    "text": "Ra√≠ces de una ecuaci√≥n de segundo grado\nComo bien sabemos, una ecuaci√≥n de segundo grado tiene la forma:\n\\[\nax^2 + bx + c = 0\n\\]\ndonde \\(a\\), \\(b\\) y \\(c\\) son coeficientes reales, y \\(x\\) es la variable que queremos resolver.\nA diferencia de las ecuaciones de primer grado, las de segundo grado pueden tener 0, 1 o 2 soluciones reales dependiendo de los valores de los coeficientes (\\(a\\), \\(b\\), \\(c\\)).\nPor ejemplo, los siguientes coeficientes generan diferentes n√∫meros de soluciones:\n\n\\(a=1\\), \\(b=-3\\), \\(c=2\\) ‚Üí dos soluciones reales (\\(x=1\\) y \\(x=2\\)).\n\\(a=1\\), \\(b=-2\\), \\(c=1\\) ‚Üí una soluci√≥n real (\\(x=1\\)).\n\\(a=1\\), \\(b=0\\), \\(c=1\\) ‚Üí no soluciones reales.\n\n\n\n\nviewof params = {\n      const cleanSlider = (range, config) =&gt; {\n        const input = Inputs.range(range, config);\n        const numberBox = input.querySelector(\"input[type=number]\");\n        if (numberBox) numberBox.style.display = \"none\";\n        const rangeSlider = input.querySelector(\"input[type=range]\");\n        if (rangeSlider) rangeSlider.style.width = \"100%\";\n        input.style.width = \"100%\";\n        return input;\n      };\n\n      const ia = cleanSlider([-5, 5], { value: 1, step: 0.1 });\n      const ib = cleanSlider([-10, 10], { value: -2, step: 0.1 });\n      const ic = cleanSlider([-10, 10], { value: -3, step: 0.1 });\n\n      const col = (input, label) =&gt; {\n        const val = htl.html`&lt;div style=\"font-family: monospace; color: #555; margin-top: 4px;\"&gt;${input.value.toFixed(1)}&lt;/div&gt;`;\n        input.addEventListener(\"input\", () =&gt; val.textContent = input.value.toFixed(1));\n        \n        return htl.html`&lt;div style=\"display: flex; flex-direction: column; align-items: center; margin: 0 10px; flex: 1; min-width: 120px;\"&gt;\n          &lt;div style=\"font-weight: bold; font-size: 0.9rem; margin-bottom: 5px; white-space: nowrap;\"&gt;${label}&lt;/div&gt;\n          &lt;div style=\"width: 100%\"&gt;${input}&lt;/div&gt;\n          ${val}\n        &lt;/div&gt;`;\n      };\n\n      // Styles: Removed background/border here so it blends into the card\n      const form = htl.html`&lt;div style=\"display: flex; flex-wrap: wrap; justify-content: center; width: 100%; padding-bottom: 20px; border-bottom: 1px solid #eee; margin-bottom: 20px;\"&gt;\n        ${col(ia, \"a (curvatura)\")}\n        ${col(ib, \"b (pendiente)\")}\n        ${col(ic, \"c (desplazamiento ‚Üë‚Üì)\")}\n      &lt;/div&gt;`;\n\n      form.oninput = () =&gt; form.value = { a: ia.value, b: ib.value, c: ic.value };\n      form.value = { a: ia.value, b: ib.value, c: ic.value };\n      return form;\n    }\n\n    // Extract variables for reactivity\n    a = params.a\n    b = params.b\n    c = params.c\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\n      const curve = Array.from({ length: 401 }, (_, i) =&gt; {\n        const x = -10 + i * 0.05;\n        return { x, y: a * x * x + b * x + c };\n      });\n\n      const points = [];\n      const disc = b * b - 4 * a * c; \n      \n      if (a !== 0 && disc &gt;= 0) {\n        const r1 = (-b + Math.sqrt(disc)) / (2 * a);\n        const r2 = (-b - Math.sqrt(disc)) / (2 * a);\n        points.push({ x: r1, y: 0, type: \"Root\", label: `x=${r1.toFixed(2)}` });\n        if (disc &gt; 0) points.push({ x: r2, y: 0, type: \"Root\", label: `x=${r2.toFixed(2)}` });\n      } else if (a === 0 && b !== 0) {\n        const root = -c / b;\n        points.push({ x: root, y: 0, type: \"Root\", label: `x=${root.toFixed(2)}` });\n      }\n\n      const curve_plot = Plot.plot({\n        height: 400,\n        grid: true,\n        marginLeft: 40, \n        marginRight: 20,\n        x: { domain: [-10, 10], label: \"x axis\" },\n        y: { domain: [-10, 10], label: null }, // Removed Y label to save space\n        marks: [\n          Plot.ruleY([0], { stroke: \"#888\", strokeWidth: 1.5 }),\n          Plot.ruleX([0], { stroke: \"#888\", strokeWidth: 1.5 }),\n          Plot.line(curve, { x: \"x\", y: \"y\", stroke: \"steelblue\", strokeWidth: 3 }),\n          Plot.dot(points, { x: \"x\", y: \"y\", fill: d =&gt; d.type === \"Root\" ? \"#e63946\" : \"#457b9d\", r: 6, stroke: \"white\", strokeWidth: 2 }),\n          Plot.text(points, { x: \"x\", y: \"y\", text: \"label\", dy: -15, fill: \"currentColor\", stroke: \"white\", strokeWidth: 4, fontWeight: \"bold\", fontSize: 12 })\n        ]\n      });\n      \n      // Ensure the SVG fills the card width\n      curve_plot.style.width = \"100%\";\n      return curve_plot;\n    }"
  },
  {
    "objectID": "practicas/practica3.reveal.html#resoluci√≥n-de-la-pr√°ctica",
    "href": "practicas/practica3.reveal.html#resoluci√≥n-de-la-pr√°ctica",
    "title": "Pr√°ctica 3: Resoluci√≥n de problemas en Java (I)",
    "section": "Resoluci√≥n de la pr√°ctica",
    "text": "Resoluci√≥n de la pr√°ctica\nPara resolver esta pr√°ctica se propone implementar tres clases en Java que correspondan a cada uno de los casos de soluci√≥n de la ecuaci√≥n cuadr√°tica.\nDe manera general, ten en cuenta que la soluci√≥n √∫nica o doble de la ecuaci√≥n se calcula a trav√©s de la siguiente f√≥rmula, conocida como la f√≥rmula general: \\[\nx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} = \\frac{-b \\pm \\sqrt{\\Delta}}{2a}\n\\]\nEl valor dentro de la ra√≠z cuadrada, \\(b^2 - 4ac\\), se llama discriminante (\\(\\Delta\\)) y determina el n√∫mero de soluciones reales que tiene la ecuaci√≥n:\nClase 1: dos soluciones reales\nSi \\(\\Delta &gt; 0\\), la ecuaci√≥n tiene dos soluciones reales distintas, que se calculan con la f√≥rmula general utilizando el s√≠mbolo \\(+\\) para una ra√≠z y el s√≠mbolo \\(-\\) para la otra ra√≠z.\nVerifica que la soluci√≥n es correcta utilizando los siguientes coeficientes:\n\n\\(a=1, \\quad b=-3, \\quad c=2\\) ‚Üí dos soluciones reales (\\(x=1\\) y \\(x=2\\)).\n\n\n\n\n\n\n\nClases en Java\n\n\nRecuerda que, en Java, una clase toma el siguiente formato general:\npublic class NombreDeLaClase {\n    /*\n    * @author: Vuestros nombres\n    * @date: Fecha de entrega\n    */\n    public static void main(String[] args) {\n        // soluci√≥n del problema\n    }\n}\n\n\n\n\n\n\n\n\n\nImprimir resultados en Java\n\n\nUtiliza la impresi√≥n por consola para mostrar los resultados de las soluciones, por ejemplo:\nSystem.out.println(\"La soluci√≥n es: \" + x);\n\n\n\nClase 2: una soluci√≥n real\nSi \\(\\Delta = 0\\), la ecuaci√≥n tiene una √∫nica soluci√≥n real, que se calcula con la f√≥rmula general utilizando cualquiera de los s√≠mbolos \\(+\\) o \\(-\\), ya que ambos dar√°n el mismo resultado.\n\n\n\n\n\n\nSoluci√≥n √∫nica\n\n\nVerifica que la soluci√≥n es correcta utilizando los siguientes coeficientes:\n\n\\(a=1, \\quad b=-2, \\quad c=1\\) ‚Üí una soluci√≥n real (\\(x=1\\)).\n\n\n\n\nClase 3: no soluciones reales\nSi \\(\\Delta &lt; 0\\), la ecuaci√≥n no tiene soluciones reales, ya que la ra√≠z cuadrada de un n√∫mero negativo no es un n√∫mero real. En este caso, se pueden calcular las soluciones complejas utilizando n√∫meros imaginarios de la siguiente forma: \\[\nx = \\frac{-b \\pm i\\sqrt{-(b^2 - 4ac)}}{2a} = \\frac{-b \\pm i\\sqrt{4ac - b^2}}{2a}\n\\]\nde tal manera que el n√∫mero imaginario \\(i\\) se define como la ra√≠z cuadrada de \\(-1\\).\nPor tanto, las dos soluciones complejas conjugadas se pueden expresar como: \\[\nx_1 = \\frac{-b + i\\sqrt{4ac - b^2}}{2a} \\quad \\text{y} \\quad x_2 = \\frac{-b - i\\sqrt{4ac - b^2}}{2a}\n\\]\n\n\n\n\n\n\nSoluci√≥n compleja\n\n\nVerifica que la soluci√≥n es correcta utilizando los siguientes coeficientes:\n\\(a=1, \\quad b=0, \\quad c=1\\)\nLas soluciones son: \\[x_1 = 0 + 1i\\] \\[x_2 = 0 - 1i\\]"
  },
  {
    "objectID": "practicas/practica3.html",
    "href": "practicas/practica3.html",
    "title": "Pr√°ctica 3: Resoluci√≥n de problemas en Java (I)",
    "section": "",
    "text": "Algoritmos para la resoluci√≥n de problemas.\nImplementar algoritmos en Java.\nEjecutar algoritmos en el entorno Eclipse.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Pr√°cticas",
      "Pr√°ctica 3: Resoluci√≥n de problemas en Java (I)"
    ]
  },
  {
    "objectID": "practicas/practica3.html#objetivos-de-la-pr√°ctica",
    "href": "practicas/practica3.html#objetivos-de-la-pr√°ctica",
    "title": "Pr√°ctica 3: Resoluci√≥n de problemas en Java (I)",
    "section": "",
    "text": "Algoritmos para la resoluci√≥n de problemas.\nImplementar algoritmos en Java.\nEjecutar algoritmos en el entorno Eclipse.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Pr√°cticas",
      "Pr√°ctica 3: Resoluci√≥n de problemas en Java (I)"
    ]
  },
  {
    "objectID": "practicas/practica3.html#ra√≠ces-de-una-ecuaci√≥n-de-segundo-grado",
    "href": "practicas/practica3.html#ra√≠ces-de-una-ecuaci√≥n-de-segundo-grado",
    "title": "Pr√°ctica 3: Resoluci√≥n de problemas en Java (I)",
    "section": "2 Ra√≠ces de una ecuaci√≥n de segundo grado",
    "text": "2 Ra√≠ces de una ecuaci√≥n de segundo grado\nComo bien sabemos, una ecuaci√≥n de segundo grado tiene la forma:\n\\[\nax^2 + bx + c = 0\n\\]\ndonde \\(a\\), \\(b\\) y \\(c\\) son coeficientes reales, y \\(x\\) es la variable que queremos resolver.\nA diferencia de las ecuaciones de primer grado, las de segundo grado pueden tener 0, 1 o 2 soluciones reales dependiendo de los valores de los coeficientes (\\(a\\), \\(b\\), \\(c\\)).\nPor ejemplo, los siguientes coeficientes generan diferentes n√∫meros de soluciones:\n\n\\(a=1\\), \\(b=-3\\), \\(c=2\\) ‚Üí dos soluciones reales (\\(x=1\\) y \\(x=2\\)).\n\\(a=1\\), \\(b=-2\\), \\(c=1\\) ‚Üí una soluci√≥n real (\\(x=1\\)).\n\\(a=1\\), \\(b=0\\), \\(c=1\\) ‚Üí no soluciones reales.\n\n\n\n\nviewof params = {\n      const cleanSlider = (range, config) =&gt; {\n        const input = Inputs.range(range, config);\n        const numberBox = input.querySelector(\"input[type=number]\");\n        if (numberBox) numberBox.style.display = \"none\";\n        const rangeSlider = input.querySelector(\"input[type=range]\");\n        if (rangeSlider) rangeSlider.style.width = \"100%\";\n        input.style.width = \"100%\";\n        return input;\n      };\n\n      const ia = cleanSlider([-5, 5], { value: 1, step: 0.1 });\n      const ib = cleanSlider([-10, 10], { value: -2, step: 0.1 });\n      const ic = cleanSlider([-10, 10], { value: -3, step: 0.1 });\n\n      const col = (input, label) =&gt; {\n        const val = htl.html`&lt;div style=\"font-family: monospace; color: #555; margin-top: 4px;\"&gt;${input.value.toFixed(1)}&lt;/div&gt;`;\n        input.addEventListener(\"input\", () =&gt; val.textContent = input.value.toFixed(1));\n        \n        return htl.html`&lt;div style=\"display: flex; flex-direction: column; align-items: center; margin: 0 10px; flex: 1; min-width: 120px;\"&gt;\n          &lt;div style=\"font-weight: bold; font-size: 0.9rem; margin-bottom: 5px; white-space: nowrap;\"&gt;${label}&lt;/div&gt;\n          &lt;div style=\"width: 100%\"&gt;${input}&lt;/div&gt;\n          ${val}\n        &lt;/div&gt;`;\n      };\n\n      // Styles: Removed background/border here so it blends into the card\n      const form = htl.html`&lt;div style=\"display: flex; flex-wrap: wrap; justify-content: center; width: 100%; padding-bottom: 20px; border-bottom: 1px solid #eee; margin-bottom: 20px;\"&gt;\n        ${col(ia, \"a (curvatura)\")}\n        ${col(ib, \"b (pendiente)\")}\n        ${col(ic, \"c (desplazamiento ‚Üë‚Üì)\")}\n      &lt;/div&gt;`;\n\n      form.oninput = () =&gt; form.value = { a: ia.value, b: ib.value, c: ic.value };\n      form.value = { a: ia.value, b: ib.value, c: ic.value };\n      return form;\n    }\n\n    // Extract variables for reactivity\n    a = params.a\n    b = params.b\n    c = params.c\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\n      const curve = Array.from({ length: 401 }, (_, i) =&gt; {\n        const x = -10 + i * 0.05;\n        return { x, y: a * x * x + b * x + c };\n      });\n\n      const points = [];\n      const disc = b * b - 4 * a * c; \n      \n      if (a !== 0 && disc &gt;= 0) {\n        const r1 = (-b + Math.sqrt(disc)) / (2 * a);\n        const r2 = (-b - Math.sqrt(disc)) / (2 * a);\n        points.push({ x: r1, y: 0, type: \"Root\", label: `x=${r1.toFixed(2)}` });\n        if (disc &gt; 0) points.push({ x: r2, y: 0, type: \"Root\", label: `x=${r2.toFixed(2)}` });\n      } else if (a === 0 && b !== 0) {\n        const root = -c / b;\n        points.push({ x: root, y: 0, type: \"Root\", label: `x=${root.toFixed(2)}` });\n      }\n\n      const curve_plot = Plot.plot({\n        height: 400,\n        grid: true,\n        marginLeft: 40, \n        marginRight: 20,\n        x: { domain: [-10, 10], label: \"x axis\" },\n        y: { domain: [-10, 10], label: null }, // Removed Y label to save space\n        marks: [\n          Plot.ruleY([0], { stroke: \"#888\", strokeWidth: 1.5 }),\n          Plot.ruleX([0], { stroke: \"#888\", strokeWidth: 1.5 }),\n          Plot.line(curve, { x: \"x\", y: \"y\", stroke: \"steelblue\", strokeWidth: 3 }),\n          Plot.dot(points, { x: \"x\", y: \"y\", fill: d =&gt; d.type === \"Root\" ? \"#e63946\" : \"#457b9d\", r: 6, stroke: \"white\", strokeWidth: 2 }),\n          Plot.text(points, { x: \"x\", y: \"y\", text: \"label\", dy: -15, fill: \"currentColor\", stroke: \"white\", strokeWidth: 4, fontWeight: \"bold\", fontSize: 12 })\n        ]\n      });\n      \n      // Ensure the SVG fills the card width\n      curve_plot.style.width = \"100%\";\n      return curve_plot;\n    }",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Pr√°cticas",
      "Pr√°ctica 3: Resoluci√≥n de problemas en Java (I)"
    ]
  },
  {
    "objectID": "practicas/practica3.html#resoluci√≥n-de-la-pr√°ctica",
    "href": "practicas/practica3.html#resoluci√≥n-de-la-pr√°ctica",
    "title": "Pr√°ctica 3: Resoluci√≥n de problemas en Java (I)",
    "section": "3 Resoluci√≥n de la pr√°ctica",
    "text": "3 Resoluci√≥n de la pr√°ctica\nPara resolver esta pr√°ctica se propone implementar tres clases en Java que correspondan a cada uno de los casos de soluci√≥n de la ecuaci√≥n cuadr√°tica.\nDe manera general, ten en cuenta que la soluci√≥n √∫nica o doble de la ecuaci√≥n se calcula a trav√©s de la siguiente f√≥rmula, conocida como la f√≥rmula general: \\[\nx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} = \\frac{-b \\pm \\sqrt{\\Delta}}{2a}\n\\]\nEl valor dentro de la ra√≠z cuadrada, \\(b^2 - 4ac\\), se llama discriminante (\\(\\Delta\\)) y determina el n√∫mero de soluciones reales que tiene la ecuaci√≥n:\n\n3.1 Clase 1: dos soluciones reales\nSi \\(\\Delta &gt; 0\\), la ecuaci√≥n tiene dos soluciones reales distintas, que se calculan con la f√≥rmula general utilizando el s√≠mbolo \\(+\\) para una ra√≠z y el s√≠mbolo \\(-\\) para la otra ra√≠z.\nVerifica que la soluci√≥n es correcta utilizando los siguientes coeficientes:\n\n\\(a=1, \\quad b=-3, \\quad c=2\\) ‚Üí dos soluciones reales (\\(x=1\\) y \\(x=2\\)).\n\n\n\n\n\n\n\nTipClases en Java\n\n\n\nRecuerda que, en Java, una clase toma el siguiente formato general:\npublic class NombreDeLaClase {\n    /*\n    * @author: Vuestros nombres\n    * @date: Fecha de entrega\n    */\n    public static void main(String[] args) {\n        // soluci√≥n del problema\n    }\n}\n\n\n\n\n\n\n\n\nNotaImprimir resultados en Java\n\n\n\nUtiliza la impresi√≥n por consola para mostrar los resultados de las soluciones, por ejemplo:\nSystem.out.println(\"La soluci√≥n es: \" + x);\n\n\n\n\n3.2 Clase 2: una soluci√≥n real\nSi \\(\\Delta = 0\\), la ecuaci√≥n tiene una √∫nica soluci√≥n real, que se calcula con la f√≥rmula general utilizando cualquiera de los s√≠mbolos \\(+\\) o \\(-\\), ya que ambos dar√°n el mismo resultado.\n\n\n\n\n\n\nTipSoluci√≥n √∫nica\n\n\n\nVerifica que la soluci√≥n es correcta utilizando los siguientes coeficientes:\n\n\\(a=1, \\quad b=-2, \\quad c=1\\) ‚Üí una soluci√≥n real (\\(x=1\\)).\n\n\n\n\n\n3.3 Clase 3: no soluciones reales\nSi \\(\\Delta &lt; 0\\), la ecuaci√≥n no tiene soluciones reales, ya que la ra√≠z cuadrada de un n√∫mero negativo no es un n√∫mero real. En este caso, se pueden calcular las soluciones complejas utilizando n√∫meros imaginarios de la siguiente forma: \\[\nx = \\frac{-b \\pm i\\sqrt{-(b^2 - 4ac)}}{2a} = \\frac{-b \\pm i\\sqrt{4ac - b^2}}{2a}\n\\]\nde tal manera que el n√∫mero imaginario \\(i\\) se define como la ra√≠z cuadrada de \\(-1\\).\nPor tanto, las dos soluciones complejas conjugadas se pueden expresar como: \\[\nx_1 = \\frac{-b + i\\sqrt{4ac - b^2}}{2a} \\quad \\text{y} \\quad x_2 = \\frac{-b - i\\sqrt{4ac - b^2}}{2a}\n\\]\n\n\n\n\n\n\nTipSoluci√≥n compleja\n\n\n\nVerifica que la soluci√≥n es correcta utilizando los siguientes coeficientes:\n\\(a=1, \\quad b=0, \\quad c=1\\)\nLas soluciones son: \\[x_1 = 0 + 1i\\] \\[x_2 = 0 - 1i\\]",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Pr√°cticas",
      "Pr√°ctica 3: Resoluci√≥n de problemas en Java (I)"
    ]
  }
]