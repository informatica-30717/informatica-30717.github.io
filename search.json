[
  {
    "objectID": "practicas/practica8.html",
    "href": "practicas/practica8.html",
    "title": "Práctica 8: BIM semántico",
    "section": "",
    "text": "Conocer la representación de modelos BIM usando ontologías\nHacer consultas al modelo BIM usando un razonador semántico."
  },
  {
    "objectID": "practicas/practica8.html#objetivos-de-la-práctica",
    "href": "practicas/practica8.html#objetivos-de-la-práctica",
    "title": "Práctica 8: BIM semántico",
    "section": "",
    "text": "Conocer la representación de modelos BIM usando ontologías\nHacer consultas al modelo BIM usando un razonador semántico."
  },
  {
    "objectID": "practicas/practica8.html#uso-de-un-software-visualizador-bim",
    "href": "practicas/practica8.html#uso-de-un-software-visualizador-bim",
    "title": "Práctica 8: BIM semántico",
    "section": "2 Uso de un software visualizador BIM",
    "text": "2 Uso de un software visualizador BIM"
  },
  {
    "objectID": "practicas/practica8.html#conversión-a-modelo-semántico",
    "href": "practicas/practica8.html#conversión-a-modelo-semántico",
    "title": "Práctica 8: BIM semántico",
    "section": "3 Conversión a modelo semántico",
    "text": "3 Conversión a modelo semántico"
  },
  {
    "objectID": "practicas/practica8.html#uso-del-editor-de-ontologías-protégé",
    "href": "practicas/practica8.html#uso-del-editor-de-ontologías-protégé",
    "title": "Práctica 8: BIM semántico",
    "section": "4 Uso del editor de ontologías Protégé",
    "text": "4 Uso del editor de ontologías Protégé"
  },
  {
    "objectID": "practicas/practica8.reveal.html#objetivos-de-la-práctica",
    "href": "practicas/practica8.reveal.html#objetivos-de-la-práctica",
    "title": "Práctica 8: BIM semántico",
    "section": "Objetivos de la práctica",
    "text": "Objetivos de la práctica\n\nConocer la representación de modelos BIM usando ontologías\nHacer consultas al modelo BIM usando un razonador semántico."
  },
  {
    "objectID": "practicas/practica8.reveal.html#uso-de-un-software-visualizador-bim",
    "href": "practicas/practica8.reveal.html#uso-de-un-software-visualizador-bim",
    "title": "Práctica 8: BIM semántico",
    "section": "Uso de un software visualizador BIM",
    "text": "Uso de un software visualizador BIM"
  },
  {
    "objectID": "practicas/practica8.reveal.html#conversión-a-modelo-semántico",
    "href": "practicas/practica8.reveal.html#conversión-a-modelo-semántico",
    "title": "Práctica 8: BIM semántico",
    "section": "Conversión a modelo semántico",
    "text": "Conversión a modelo semántico"
  },
  {
    "objectID": "practicas/practica8.reveal.html#uso-del-editor-de-ontologías-protégé",
    "href": "practicas/practica8.reveal.html#uso-del-editor-de-ontologías-protégé",
    "title": "Práctica 8: BIM semántico",
    "section": "Uso del editor de ontologías Protégé",
    "text": "Uso del editor de ontologías Protégé"
  },
  {
    "objectID": "practicas/practica2.html",
    "href": "practicas/practica2.html",
    "title": "Práctica 2: Un entorno de programación en Java",
    "section": "",
    "text": "Los objetivos de la segunda práctica de la asignatura son los siguientes:\n\nFamiliarizarse con el ordenador y los elementos básicos de su sistema operativo.\nFamiliarizarse con el entorno de desarrollo Java Eclipse.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Prácticas",
      "Práctica 2: Un entorno de programación en Java"
    ]
  },
  {
    "objectID": "practicas/practica2.html#objetivos-de-la-práctica",
    "href": "practicas/practica2.html#objetivos-de-la-práctica",
    "title": "Práctica 2: Un entorno de programación en Java",
    "section": "",
    "text": "Los objetivos de la segunda práctica de la asignatura son los siguientes:\n\nFamiliarizarse con el ordenador y los elementos básicos de su sistema operativo.\nFamiliarizarse con el entorno de desarrollo Java Eclipse.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Prácticas",
      "Práctica 2: Un entorno de programación en Java"
    ]
  },
  {
    "objectID": "practicas/practica2.html#el-entorno-de-desarrollo-eclipse",
    "href": "practicas/practica2.html#el-entorno-de-desarrollo-eclipse",
    "title": "Práctica 2: Un entorno de programación en Java",
    "section": "2 El entorno de desarrollo Eclipse",
    "text": "2 El entorno de desarrollo Eclipse\nPara facilitar la tarea de desarrollo de programas existen entornos que permiten trabajar de una manera más cómoda. Algunos ejemplos son NetBeans, Eclipse o IntelliJ. Nosotros recomendamos el uso de Eclipse, un entorno de desarrollo de libre distribución.\nInicia la herramienta Eclipse haciendo doble clic sobre el ejecutable Eclipse en el escritorio de los laboratorios de prácticas, o bien buscando Eclipse en la barra de tareas. Para instalar esta aplicación en otros ordenadores puede consultarse el Apéndice. Al iniciar Eclipse aparecerá la pantalla de bienvenida que se muestra en la @fig:init_eclipse.\n\n\n\nPantalla de bienvenida.\n\n\nPara poder comenzar a trabajar con el entorno de desarrollo será necesario definir un espacio de trabajo (workspace), tal y como se muestra en la @fig:workspace_eclipse. Este workspace contendrá todos los ficheros creados con Eclipse. Por ejemplo, se puede establecer el directorio C:/PracticasARQ como directorio de trabajo.\n\n\n\nConfiguración del workspace.\n\n\nEn los siguientes subapartados aparecen solo algunas de las características de Eclipse, o recomendaciones acerca de su uso. Si tienes más dudas sobre cómo utilizar Eclipse, deberás consultar la ayuda en línea (opción de menú Help &gt; Help Contents), o bien accediendo a su página web, donde se encuentra también toda la documentación del programa.\n\n2.1 Pantalla de bienvenida\nLa primera vez que se utiliza Eclipse, aparecerá un mensaje preguntándonos si queremos excluir Eclipse del análisis del antivirus de Windows. Como aparece en la @fig:antivirus_eclipse, podemos indicar que se excluya Eclipse de dichos análisis para evitar ralentizar la aplicación.\n\n\n\nPregunta de exclusión de Eclipse IDE respecto del sistema antivirus de Windows.\n\n\nUna vez seleccionada una opción, nos aparecerá una ventana de bienvenida (@fig:welcome_eclipse) con varias opciones, de las cuales cabe destacar las siguientes:\n\n\n\nPantalla de bienvenida.\n\n\nSi cerramos la pestaña de bienvenida, nos conducirá al entorno de trabajo que se explica en la siguiente sección.\nEn esta pantalla de bienvenida, en la barra izquierda, se nos muestran algunas opciones, entre las que se incluye Create a Java project. Utilizaremos esta opción cada vez que queramos crear un nuevo proyecto, por ejemplo, para cada práctica de programación de este curso. Para esta práctica, podemos crear un nuevo proyecto al que llamaremos practica2.\n\n\n2.2 Entorno de trabajo\nEl entorno de trabajo o workbench nos proporciona una interfaz de usuario intuitiva, bien estructurada y sencilla de utilizar, donde están bien definidas las distintas zonas de trabajo. En la Figura 5 se puede observar la interfaz de usuario de Eclipse.\nLas diferentes partes en las que está dividida la interfaz son:\n\nEn la zona de la izquierda, se halla un menú (Package Explorer) que agrupa los componentes de cada uno de los proyectos abiertos.\nEn la zona central de la pantalla se encuentra un editor, que sirve para ver y modificar los ficheros Java con los que trabajamos.\nEn la zona de la derecha, hay un resumen (Outline) que nos indica la estructura del fichero activo en el editor (clases, métodos, variables, etc.).\nEn la parte inferior del editor se encuentran algunas utilidades que nos permiten conocer el estado del proyecto, incluyendo errores (Problems) y la salida obtenida en los programas ejecutados (Console).\n\n\n\n\nEspacio de trabajo de Eclipse IDE.\n\n\n\n\n2.3 1.3. Crear un proyecto\nPara la realización de cada práctica se recomienda crear un proyecto nuevo. De esta forma se pueden agrupar los ficheros correspondientes a una determinada práctica dentro de ese proyecto para compilar y ejecutar programas individuales que comparten una configuración común.\nLos proyectos se crean a través de la opción File &gt; New &gt; Java Project. Para crear el nuevo proyecto hay que dotarlo de un nombre identificativo (ej. practica2). Dicho proyecto corresponderá con un directorio dentro del equipo, y dentro del workspace seleccionado al lanzar Eclipse. Conviene seleccionar la opción Create separate source and output folders. En la Figura 6 se pueden observar todas las propiedades que se pueden definir en la creación del proyecto.\nEl nuevo proyecto que has creado se configurará sobre la carpeta:\nC:\\practicasARQ\\practica2\nObserva que en la carpeta practica2 se han creado dos subcarpetas. En src se almacenarán los ficheros con el código en lenguaje Java (source), mientras que en la carpeta bin se almacenan los ficheros binarios (binaries).\nIlustración . Propiedades que podemos configurar al crear un nuevo proyecto.\n\n\n2.4 1.4. Crear una aplicación\nLos lenguajes orientados a objetos, como Java, giran en torno al concepto de clase. Todas las variables y métodos de Java deben pertenecer a una clase. Una clase es una colección de datos (variables) y de métodos (funciones) que operan sobre dichos datos. Cada clase pública debe ir en un fichero con extensión .java, cuyo nombre es exactamente igual que el de la clase. Por ejemplo, en un fichero HolaMundo.java, definiremos una clase HolaMundo.\nPara añadir nuevas clases al proyecto utilizaremos la opción de menú File &gt; New &gt; Class. Selecciona src como subcarpeta e introduce HolaMundo como nombre del archivo que contendrá el programa (clase) que deberás escribir a continuación. La opción public static void main(String[] args) debe marcarse para que la clase sea ejecutable (ejecutándose por tanto el método main de la clase). La Ilustración 7 ilustra este proceso.\nIlustración . Creación de una nueva clase de Java.\nFijaos en que, además de la carpeta, hemos indicado el nombre de un paquete. Dicho nombre no se puede dejar en blanco, por lo que hemos nombrado practica2. En futuras sesiones de prácticas hablaremos de qué es un paquete, y cómo crearlo para estructurar las clases que creemos en cada proyecto.\nAl finalizar la creación, se creará automáticamente un pequeño esqueleto con el código inicial común a cada clase, que deberá completarse para contener el siguiente código:\nimport java.util.*;\n\n/**\n * La clase HolaMundo ejemplifica el uso de Eclipse para programar en Java.\n * @author Fernando Bobillo, Alfonso López, Ignacio Huitzil.\n */\npublic class HolaMundo\n{\n    /**\n     * El método main contiene el programa principal.\n     * @param args Puede recibir una lista de parámetros como argumento.\n     */\n    public static void main(String[] args)\n    {\n        System.out.print(\"Escribe tu nombre: \");\n        String nombre = (new Scanner(System.in)).nextLinea();\n        System.out.println(\"Hola \" + nom + \", mucho gusto.\");\n    }\n}\nEl código anterior contiene algunos errores introducidos voluntariamente para que se produzcan errores de compilación.\nEl editor de Eclipse es un editor típico del entorno Windows: se puede copiar, cortar, pegar, buscar y sustituir. Tiene un sistema de tabulación inteligente que facilita la tarea de escritura. Se puede conseguir aumentar o disminuir la tabulación de una porción de código seleccionando dicha porción y pulsando tabulador o mayúsculas-tabulador.\nGuarda los cambios que hemos introducido pulsando los iconos con disquetes que hay en la barra de herramientas superior ( ), pulsando Ctrl-S o bien con File &gt; Save.\n\n\n2.5 1.5. Compilación de aplicaciones\nPara compilar el programa deberás utilizar la opción de menú Project &gt; Build Project en el caso de que no esté marcada la compilación automática. En este último caso, será suficiente con guardar el fichero para que se compile.\nDentro de las herramientas que se muestran en la porción inferior, encontramos la subpestaña Problems. En esa subpestaña se nos informará sobre el proceso de compilación indicando los posibles errores (ver Ilustración 8). Puedes seleccionar cada error mediante doble click, y se indicará dentro del código dónde se encuentra el error.\nSi trabajásemos sin un entorno de desarrollo, sería equivalente a abrir una ventana de órdenes del sistema operativo y teclear:\njavac HolaMundo.java\nIlustración . Compilación con errores.\nEl primer error se produce porque el nombre correcto del método es nextLine; el segundo porque se ha escrito mal la variable nombre. Corrige ambos errores y recompila con Project &gt; Build project. Ahora no te deberá mostrar ningún error. El fichero compilado se llama HolaMundo.class y se habrá creado en la subcarpeta bin.\n\n\n2.6 1.6. Ejecución de aplicaciones\nFinalmente, hay que llamar al intérprete de la máquina virtual. En el entorno Eclipse esto se hace utilizando la opción de menú Run &gt; Run as: Java application, o mediante el icono de ejecutar en la barra de herramientas superior .\nSi trabajásemos directamente con el JDK deberíamos invocar al intérprete (comando java) pasándole como parámetro el fichero compilado sin poner la extensión .class. Así pues, en el intérprete de órdenes teclearíamos:\njava HolaMundo\n\n\n2.7 1.7. Depuración de errores\nPara depurar los errores de un proyecto, lo ejecutaremos paso a paso para comprender mejor el funcionamiento real del programa, tal y como se ilustra en la Ilustración 9.\nIlustración . Depuración de un programa.\nPara ello, seguimos los siguientes pasos:\nUtiliza la opción de menú Run &gt; Toggle line breakpoint para establecer (o eliminar) puntos de parada sobre el código que queremos ejecutar paso a paso. La ejecución paso a paso comenzará en la línea que contenga el punto de ruptura. También se puede utilizar el menú desplegable que aparece al pulsar el botón derecho del ratón sobre el margen izquierdo de la ventana que muestra el código de una clase Java.\nUtiliza la opción Run &gt; Debug, o Debug  en la barra de herramientas superior, para lanzar la ejecución en modo depuración de errores. Aparecerá una ventana de debugger (depurador) con el estado de todas las variables.\nUtiliza Run &gt; Step into (F5) y Run &gt; Step over (F6) para ejecutar el código instrucción a instrucción. Step over ejecuta las llamadas a métodos como sentencias simples (sin entrar a ejecutar paso a paso cada instrucción dentro del método).\nPara practicar todo lo visto hasta ahora, haz lo siguiente:\nCrea una nueva clase llamada Ejercicio (comenzando con una letra mayúscula).\nPega el siguiente código en la clase creada.\npackage practica2;\n\npublic class Ejercicio\n{\n        public static void main(String[] args)\n        {\n            int n, x, y, z;\n            n = 10;\n            x = 0;\n            y = 1;\n            z = 1;\n\n            if (n == 0) || (n == 1)\n            {\n                x = 1\n            }\n            else\n            {\n                for (i=2; i&lt;=n; i++)\n                {\n                    int s = y + z;\n                    x = s;\n                    z = y;\n                    y = x;\n                }\n            }\n\n            System.out.println(Programa terminado);\n        }\n}\nSoluciona todos los errores de compilación en el programa anterior.\nEjecuta el programa paso a paso para observar cuál es el valor que toma la variable x justo antes de finalizar el programa.\n\n\n2.8 1.8. Exportar e importar proyectos\nLas opciones de exportar e importar proyectos sirven para transferir proyectos de un ordenador a otro. Por ejemplo, podemos exportar un proyecto Eclipse a una carpeta de ficheros ubicada en una memoria USB y, en otro ordenador, importar la carpeta.\nPara exportar un proyecto de Eclipse a una carpeta de ficheros, haremos lo siguiente:\nUtiliza la opción de menú File &gt; Export y elegir General &gt; File system (ver Ilustración 10).\nIlustración . Exportar proyectos del workspace.\nMarcaremos el proyecto a exportar y todos sus elementos (carpetas en la parte izquierda, ficheros concretos en la parte izquierda). En general, sólo se suele exportar la carpeta src, dado que los ficheros binarios (bin) se generan a partir de la compilación.\nEn la zona To directory se indicará el nombre de la carpeta que vamos a crear.\nPulsa Finish para finalizar.\nSi ha ido todo bien, habrás generado una carpeta con la estructura de subcarpetas del proyecto actual. Existen otras maneras de exportar proyectos, pero esta es la más sencilla.\nPor otro lado, no es estrictamente necesario exportar el proyecto, sino que es suficiente con guardar los ficheros .java ubicados en la carpeta src.\nPara importar un proyecto tenemos varias alternativas:\nCopiamos la carpeta de ficheros exportada en el workspace del ordenador. Si existe otra carpeta con una versión previa del proyecto (por ejemplo, si estamos practicando la exportación y la importación en el mismo ordenador), deberemos borrar la versión previa para poder importarla correctamente.\nUtilizamos la opción File &gt; Import y a continuación seleccionamos General &gt; Existing projects into workspace (ver Ilustración 11).\nIlustración . Importar proyectos del workspace.\nCrear un nuevo proyecto a partir de clases Java existentes utilizando la opción Import  &gt; General &gt; File system. De esta manera, podríamos importar únicamente los ficheros .java sin necesidad de considerar el resto del proyecto.\nPor ahora recomendamos utilizar la opción General &gt; Existing projects into workspace.\n\n\n2.9 1.9. Crear y utilizar bibliotecas .jar\nCuando se quiere distribuir una aplicación desarrollada en Java que incluye un número considerable de clases y paquetes, conviene generar una biblioteca. Las bibliotecas en Java son archivos con extensión .jar que comprimen (al estilo de los ficheros .zip) un conjunto de clases compiladas (.class) organizadas en paquetes. Se puede explorar el contenido de un fichero .jar con programas de compresión de ficheros como WinZip.\nPara crear una biblioteca en el entorno Eclipse debemos seleccionar el proyecto que queremos exportar, utilizar la opción de menú File &gt; Export, seleccionar Java &gt; Runnable JAR File y seguir los siguientes pasos, ilustrados en la Ilustración 12:\nEn Launch configuration se elige la clase principal, es decir, la que tiene el método main que se ejecutará una vez que ejecutemos el fichero .jar.\nEn Export destination se indica el nombre del fichero que vamos a crear y la ruta donde se va a almacenar dicho fichero.\nPulsa Finish para finalizar. Si ha ido todo bien, se habrá generado un fichero .jar.\nIlustración . Construcción de una biblioteca .jar.\nSi el programa se llama HolaMundo.jar, podrás ejecutarlo escribiendo en una terminal del sistema operativo lo siguiente:\njava –jar HolaMundo.jar\nPara abrir una terminal en Windows, hay que utilizar la barra de búsqueda e introducir Símbolo del sistema. Antes de poder ejecutar el .jar con la instrucción anterior, debemos posicionarnos en la carpeta que lo contenga. Para simplificar, guarda el fichero .jar en la carpeta raíz del disco duro,  C:, y posteriormente escribe en la ventana de órdenes la siguiente instrucción:\ncd /\n\n\n2.10 1.10. Añadir bibliotecas a un proyecto\nSi queremos utilizar alguna de las clases ya definidas en Java, simplemente es necesario añadir una sentencia en nuestro programa para importar la biblioteca correspondiente. Por ejemplo, para utilizar las clases definidas en el paquete java.util, hemos añadido en nuestro programa la sentencia\nimport java.util.*;\nEl proceso de incluir bibliotecas diferentes a las incluidas por defecto en Java puede no ser sencillo, ya que hay varias opciones para hacerlo de una manera correcta. Entre las distintas opciones que tenemos para incluir bibliotecas están las siguientes:\nSi tenemos un fichero .jar con las clases compiladas, podemos añadirlo directamente.\nSi tenemos las clases compiladas pero no un fichero .jar, nos puede interesar incluir el directorio con clases compiladas.\nSi vamos a utilizar una biblioteca común, es recomendable crear una variable, e incluirla como biblioteca.\nEn este apartado vamos a describir el primer escenario. Para ello, vamos a importar a modo de ejemplo la biblioteca .jar incluida en Moodle, biblioteca.jar.\nAntes de ello, vamos a escribir en nuestro programa la siguiente instrucción:\nPracticas.escribeMensaje();\nAl compilar, se nos informa de un error: la clase Practicas no ha sido definida todavía. Para solucionarlo, vamos a importar una biblioteca donde se define dicha clase. Debemos hacer click derecho sobre el nombre del proyecto y seleccionar Properties &gt; Java Build Path. Obtendremos una ventana como la de la Ilustración 13.\nA continuación, hacemos click sobre Add External JARs y seleccionamos el fichero a importar.  Una vez hecho esto, podemos comprobar que es posible ejecutar nuestro programa sin ningún tipo de problemas, pues el código necesario se obtiene en el fichero importado.\nIlustración . Añadiendo una biblioteca .jar a un proyecto.\n\n\n2.11 1.11. Generar documentación\nPara generar la documentación de las clases y paquetes desarrollados se utiliza la herramienta javadoc, incluida en la JDK. Desde el entorno de Eclipse, se facilita la utilización de esta herramienta a través de la opción de menú Project &gt; Generate Javadoc (Ilustración 14).\nEn primer lugar, seleccionamos la ubicación del ejecutable javadoc con el botón Configure. Normalmente, Eclipse detecta automáticamente su ubicación y rellena este campo por nosotros, por lo que no necesitamos hacer nada.\nA continuación, se debe configurar el directorio de salida de la documentación utilizando la caja de texto Destination y el botón Browse asociado.\nPor último, se pulsará el botón Finish para finalizar y generar la documentación. La documentación podrá abrirse con cualquier navegador HTML.\nPruébalo para la clase HolaMundo.\nIlustración . Generación de documentación con la herramienta javadoc.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Prácticas",
      "Práctica 2: Un entorno de programación en Java"
    ]
  },
  {
    "objectID": "practicas/practica2.html#acceso-a-la-documentación-del-jdk",
    "href": "practicas/practica2.html#acceso-a-la-documentación-del-jdk",
    "title": "Práctica 2: Un entorno de programación en Java",
    "section": "3 1.12. Acceso a la documentación del JDK",
    "text": "3 1.12. Acceso a la documentación del JDK\nJava proporciona una amplia y detallada documentación acerca de las herramientas que incluye el JDK, así como la especificación de la API (Application Programming Interface), es decir, la documentación de las bibliotecas disponibles por defecto en Java. Esta documentación está accesible en la página oficial de Oracle (Ilustración 15), y lo mismo sucede para la documentación de la API (Ilustración 16). Esta documentación puede descargarse para poder consultarla sin necesidad de acceder a Internet; el material descargado puede visualizarse con cualquier navegador web.\nModifica la clase Ejercicio para que cada vez que se ejecute escriba por pantalla un número diferente. Para ello, modifica la instrucción x = 1 con métodos de la clase Math que permitan obtener un número enteros aleatorio: primero se obtendrá un número real aleatorio y luego se redondeará a un número entero. Puede buscarse dicho método en la documentación de la clase java.lang.Math.\nx = Math.???(Math.???());\nIlustración . Documentación del JDK.\nIlustración . Documentación de la API de Java.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Prácticas",
      "Práctica 2: Un entorno de programación en Java"
    ]
  },
  {
    "objectID": "practicas/practica2.html#apéndice.-instalación-de-eclipse-y-jdk",
    "href": "practicas/practica2.html#apéndice.-instalación-de-eclipse-y-jdk",
    "title": "Práctica 2: Un entorno de programación en Java",
    "section": "4 Apéndice. Instalación de Eclipse y JDK",
    "text": "4 Apéndice. Instalación de Eclipse y JDK\nEn este apéndice explicaremos el proceso de instalación del software necesario para realizar las prácticas de Informática en los ordenadores personales. Existen al menos dos maneras de instalar el software:\n\n4.1 Instalación de Eclipse mediante un instalador\nVisita la página web oficial de Eclipse.\nLocaliza el botón de Download. Nos llevará a la página de descargas.\nLocaliza el panel de Eclipse Installer (Ilustración 17). Debemos reconocer nuestro sistema operativo (Windows, Linux o macOS), y pulsar sobre x86_64.\nUna vez descargado el instalador, lo ejecutamos.\nEl instalador permite obtener múltiples herramientas de Eclipse, aunque nosotros sólo necesitamos el entorno de desarrollo para Java. La instalación es bastante automática, y simplemente tendremos que seleccionar Eclipse IDE for Java Developers (Ilustración 18).\nIlustración . Instalador de la suite de Eclipse.\nIlustración . Herramientas disponibles en la suite de Eclipse.\nUna vez seleccionada dicha opción, se nos dirige a una pantalla como la que se muestra en la Ilustración 19. El objetivo es configurar dos rutas: la localización de las herramientas de desarrollo para Java y la ruta de instalación de Eclipse. Podéis personalizar ambas rutas, pero no es recomendable hacerlo. En particular, la primera ruta apunta a un Java Development Kit (JDK), que, si no queremos descargar junto con Eclipse, deberá instalarse por separado. Esta última opción, aunque es menos sencilla, se describe en el siguiente punto y, entre otras ventajas, permite probar los comandos java y javac en la terminal del ordenador.\nIlustración . Instalación de Eclipse para Java, indicando que queremos descargar un JRE.\nUna opción alternativa consiste en indicar la ruta de un Java Runtime Environment (JRE) (versión 21 o superior) previamente instalado (ver Ilustración 20). Para la descarga e instalación del JDK de Java, por favor, dirígete a la sección B.1 del Apéndice. Por ejemplo, en la siguiente imagen, se ha detectado una instalación en la ruta C:/Program Files/Java/jdk-25, que es la ruta de instalación por defecto de un JDK.\nIlustración . Instalación de Eclipse para Java, indicando la ruta de un JDK previamente instalado.\n\n\n4.2 Instalación alternativa de Eclipse sin instalador\n\n4.2.1 Instalación del Java Software Development Kit (JDK)\nPara comenzar, debemos descargar la última versión del JDK de la página web de Oracle:\nDescargamos el JDK de Java de la página oficial de Oracle. En este momento, la última versión disponible es la 25.\nDebemos seleccionar el sistema operativo de nuestro ordenador personal (Linux, macOS o Windows) y descargar un instalador. En Windows, podemos descargar tanto x64 Installer como x64 MSI Installer.\nUna vez descargado, abrimos el archivo para comenzar el proceso de instalación. El proceso es completamente automático y no habrá que hacer nada, salvo utilizar el botón Next para avanzar entre pasos. La ruta de instalación por defecto en Windows es C:/Program Files/Java/jdk-25. Se recomienda no modificar esta ruta, salvo que no tengamos espacio en C:.\nIlustración . Paso intermedio de la instalación del JDK. Se muestra la ruta de instalación por defecto, la cual no modificaremos.\n\n\n4.2.2 Instalación de Eclipse\nVisita la página web oficial de Eclipse.\nLocaliza el botón de Download. Nos llevará a la página de descargas.\nPartiendo de un panel similar al de la Ilustración 22, reconocemos nuestro sistema operativo y pulsamos sobre x86_64. Se descargará un .zip con una carpeta dentro llamada eclipse (ver Ilustración 23). Podemos situar dicha carpeta en cualquier directorio de nuestra elección, por ejemplo, en la unidad C:. Ten en cuenta que esta opción no requiere instalación, y por tanto, accederemos siempre a dicha carpeta cuando queramos iniciar Eclipse haciendo click sobre eclipse.exe. En la Ilustración 23 se muestra el contenido del fichero .zip descomprimido.\nIlustración . Panel de descarga de Eclipse sin instalador.\nIlustración . Ficheros contenidos en el directorio eclipse, tras descomprimir el fichero .zip descargado de la página oficial de Eclipse.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Prácticas",
      "Práctica 2: Un entorno de programación en Java"
    ]
  },
  {
    "objectID": "practicas/practica2.reveal.html#objetivos-de-la-práctica",
    "href": "practicas/practica2.reveal.html#objetivos-de-la-práctica",
    "title": "Práctica 2: Un entorno de programación en Java",
    "section": "Objetivos de la práctica",
    "text": "Objetivos de la práctica\nLos objetivos de la segunda práctica de la asignatura son los siguientes:\n\nFamiliarizarse con el ordenador y los elementos básicos de su sistema operativo.\nFamiliarizarse con el entorno de desarrollo Java Eclipse."
  },
  {
    "objectID": "practicas/practica2.reveal.html#el-entorno-de-desarrollo-eclipse",
    "href": "practicas/practica2.reveal.html#el-entorno-de-desarrollo-eclipse",
    "title": "Práctica 2: Un entorno de programación en Java",
    "section": "El entorno de desarrollo Eclipse",
    "text": "El entorno de desarrollo Eclipse\nPara facilitar la tarea de desarrollo de programas existen entornos que permiten trabajar de una manera más cómoda. Algunos ejemplos son NetBeans, Eclipse o IntelliJ. Nosotros recomendamos el uso de Eclipse, un entorno de desarrollo de libre distribución.\nInicia la herramienta Eclipse haciendo doble clic sobre el ejecutable Eclipse en el escritorio de los laboratorios de prácticas, o bien buscando Eclipse en la barra de tareas. Para instalar esta aplicación en otros ordenadores puede consultarse el Apéndice. Al iniciar Eclipse aparecerá la pantalla de bienvenida que se muestra en la @fig:init_eclipse.\n\n\n\nPantalla de bienvenida.\n\n\nPara poder comenzar a trabajar con el entorno de desarrollo será necesario definir un espacio de trabajo (workspace), tal y como se muestra en la @fig:workspace_eclipse. Este workspace contendrá todos los ficheros creados con Eclipse. Por ejemplo, se puede establecer el directorio C:/PracticasARQ como directorio de trabajo.\n\n\n\nConfiguración del workspace.\n\n\nEn los siguientes subapartados aparecen solo algunas de las características de Eclipse, o recomendaciones acerca de su uso. Si tienes más dudas sobre cómo utilizar Eclipse, deberás consultar la ayuda en línea (opción de menú Help &gt; Help Contents), o bien accediendo a su página web, donde se encuentra también toda la documentación del programa.\nPantalla de bienvenida\nLa primera vez que se utiliza Eclipse, aparecerá un mensaje preguntándonos si queremos excluir Eclipse del análisis del antivirus de Windows. Como aparece en la @fig:antivirus_eclipse, podemos indicar que se excluya Eclipse de dichos análisis para evitar ralentizar la aplicación.\n\n\n\nPregunta de exclusión de Eclipse IDE respecto del sistema antivirus de Windows.\n\n\nUna vez seleccionada una opción, nos aparecerá una ventana de bienvenida (@fig:welcome_eclipse) con varias opciones, de las cuales cabe destacar las siguientes:\n\n\n\nPantalla de bienvenida.\n\n\nSi cerramos la pestaña de bienvenida, nos conducirá al entorno de trabajo que se explica en la siguiente sección.\nEn esta pantalla de bienvenida, en la barra izquierda, se nos muestran algunas opciones, entre las que se incluye Create a Java project. Utilizaremos esta opción cada vez que queramos crear un nuevo proyecto, por ejemplo, para cada práctica de programación de este curso. Para esta práctica, podemos crear un nuevo proyecto al que llamaremos practica2.\nEntorno de trabajo\nEl entorno de trabajo o workbench nos proporciona una interfaz de usuario intuitiva, bien estructurada y sencilla de utilizar, donde están bien definidas las distintas zonas de trabajo. En la Figura 5 se puede observar la interfaz de usuario de Eclipse.\nLas diferentes partes en las que está dividida la interfaz son:\n\nEn la zona de la izquierda, se halla un menú (Package Explorer) que agrupa los componentes de cada uno de los proyectos abiertos.\nEn la zona central de la pantalla se encuentra un editor, que sirve para ver y modificar los ficheros Java con los que trabajamos.\nEn la zona de la derecha, hay un resumen (Outline) que nos indica la estructura del fichero activo en el editor (clases, métodos, variables, etc.).\nEn la parte inferior del editor se encuentran algunas utilidades que nos permiten conocer el estado del proyecto, incluyendo errores (Problems) y la salida obtenida en los programas ejecutados (Console).\n\n\n\n\nEspacio de trabajo de Eclipse IDE.\n\n\n1.3. Crear un proyecto\nPara la realización de cada práctica se recomienda crear un proyecto nuevo. De esta forma se pueden agrupar los ficheros correspondientes a una determinada práctica dentro de ese proyecto para compilar y ejecutar programas individuales que comparten una configuración común.\nLos proyectos se crean a través de la opción File &gt; New &gt; Java Project. Para crear el nuevo proyecto hay que dotarlo de un nombre identificativo (ej. practica2). Dicho proyecto corresponderá con un directorio dentro del equipo, y dentro del workspace seleccionado al lanzar Eclipse. Conviene seleccionar la opción Create separate source and output folders. En la Figura 6 se pueden observar todas las propiedades que se pueden definir en la creación del proyecto.\nEl nuevo proyecto que has creado se configurará sobre la carpeta:\nC:\\practicasARQ\\practica2\nObserva que en la carpeta practica2 se han creado dos subcarpetas. En src se almacenarán los ficheros con el código en lenguaje Java (source), mientras que en la carpeta bin se almacenan los ficheros binarios (binaries).\nIlustración . Propiedades que podemos configurar al crear un nuevo proyecto.\n1.4. Crear una aplicación\nLos lenguajes orientados a objetos, como Java, giran en torno al concepto de clase. Todas las variables y métodos de Java deben pertenecer a una clase. Una clase es una colección de datos (variables) y de métodos (funciones) que operan sobre dichos datos. Cada clase pública debe ir en un fichero con extensión .java, cuyo nombre es exactamente igual que el de la clase. Por ejemplo, en un fichero HolaMundo.java, definiremos una clase HolaMundo.\nPara añadir nuevas clases al proyecto utilizaremos la opción de menú File &gt; New &gt; Class. Selecciona src como subcarpeta e introduce HolaMundo como nombre del archivo que contendrá el programa (clase) que deberás escribir a continuación. La opción public static void main(String[] args) debe marcarse para que la clase sea ejecutable (ejecutándose por tanto el método main de la clase). La Ilustración 7 ilustra este proceso.\nIlustración . Creación de una nueva clase de Java.\nFijaos en que, además de la carpeta, hemos indicado el nombre de un paquete. Dicho nombre no se puede dejar en blanco, por lo que hemos nombrado practica2. En futuras sesiones de prácticas hablaremos de qué es un paquete, y cómo crearlo para estructurar las clases que creemos en cada proyecto.\nAl finalizar la creación, se creará automáticamente un pequeño esqueleto con el código inicial común a cada clase, que deberá completarse para contener el siguiente código:\nimport java.util.*;\n\n/**\n * La clase HolaMundo ejemplifica el uso de Eclipse para programar en Java.\n * @author Fernando Bobillo, Alfonso López, Ignacio Huitzil.\n */\npublic class HolaMundo\n{\n    /**\n     * El método main contiene el programa principal.\n     * @param args Puede recibir una lista de parámetros como argumento.\n     */\n    public static void main(String[] args)\n    {\n        System.out.print(\"Escribe tu nombre: \");\n        String nombre = (new Scanner(System.in)).nextLinea();\n        System.out.println(\"Hola \" + nom + \", mucho gusto.\");\n    }\n}\nEl código anterior contiene algunos errores introducidos voluntariamente para que se produzcan errores de compilación.\nEl editor de Eclipse es un editor típico del entorno Windows: se puede copiar, cortar, pegar, buscar y sustituir. Tiene un sistema de tabulación inteligente que facilita la tarea de escritura. Se puede conseguir aumentar o disminuir la tabulación de una porción de código seleccionando dicha porción y pulsando tabulador o mayúsculas-tabulador.\nGuarda los cambios que hemos introducido pulsando los iconos con disquetes que hay en la barra de herramientas superior ( ), pulsando Ctrl-S o bien con File &gt; Save.\n1.5. Compilación de aplicaciones\nPara compilar el programa deberás utilizar la opción de menú Project &gt; Build Project en el caso de que no esté marcada la compilación automática. En este último caso, será suficiente con guardar el fichero para que se compile.\nDentro de las herramientas que se muestran en la porción inferior, encontramos la subpestaña Problems. En esa subpestaña se nos informará sobre el proceso de compilación indicando los posibles errores (ver Ilustración 8). Puedes seleccionar cada error mediante doble click, y se indicará dentro del código dónde se encuentra el error.\nSi trabajásemos sin un entorno de desarrollo, sería equivalente a abrir una ventana de órdenes del sistema operativo y teclear:\njavac HolaMundo.java\nIlustración . Compilación con errores.\nEl primer error se produce porque el nombre correcto del método es nextLine; el segundo porque se ha escrito mal la variable nombre. Corrige ambos errores y recompila con Project &gt; Build project. Ahora no te deberá mostrar ningún error. El fichero compilado se llama HolaMundo.class y se habrá creado en la subcarpeta bin.\n1.6. Ejecución de aplicaciones\nFinalmente, hay que llamar al intérprete de la máquina virtual. En el entorno Eclipse esto se hace utilizando la opción de menú Run &gt; Run as: Java application, o mediante el icono de ejecutar en la barra de herramientas superior .\nSi trabajásemos directamente con el JDK deberíamos invocar al intérprete (comando java) pasándole como parámetro el fichero compilado sin poner la extensión .class. Así pues, en el intérprete de órdenes teclearíamos:\njava HolaMundo\n1.7. Depuración de errores\nPara depurar los errores de un proyecto, lo ejecutaremos paso a paso para comprender mejor el funcionamiento real del programa, tal y como se ilustra en la Ilustración 9.\nIlustración . Depuración de un programa.\nPara ello, seguimos los siguientes pasos:\nUtiliza la opción de menú Run &gt; Toggle line breakpoint para establecer (o eliminar) puntos de parada sobre el código que queremos ejecutar paso a paso. La ejecución paso a paso comenzará en la línea que contenga el punto de ruptura. También se puede utilizar el menú desplegable que aparece al pulsar el botón derecho del ratón sobre el margen izquierdo de la ventana que muestra el código de una clase Java.\nUtiliza la opción Run &gt; Debug, o Debug  en la barra de herramientas superior, para lanzar la ejecución en modo depuración de errores. Aparecerá una ventana de debugger (depurador) con el estado de todas las variables.\nUtiliza Run &gt; Step into (F5) y Run &gt; Step over (F6) para ejecutar el código instrucción a instrucción. Step over ejecuta las llamadas a métodos como sentencias simples (sin entrar a ejecutar paso a paso cada instrucción dentro del método).\nPara practicar todo lo visto hasta ahora, haz lo siguiente:\nCrea una nueva clase llamada Ejercicio (comenzando con una letra mayúscula).\nPega el siguiente código en la clase creada.\npackage practica2;\n\npublic class Ejercicio\n{\n        public static void main(String[] args)\n        {\n            int n, x, y, z;\n            n = 10;\n            x = 0;\n            y = 1;\n            z = 1;\n\n            if (n == 0) || (n == 1)\n            {\n                x = 1\n            }\n            else\n            {\n                for (i=2; i&lt;=n; i++)\n                {\n                    int s = y + z;\n                    x = s;\n                    z = y;\n                    y = x;\n                }\n            }\n\n            System.out.println(Programa terminado);\n        }\n}\nSoluciona todos los errores de compilación en el programa anterior.\nEjecuta el programa paso a paso para observar cuál es el valor que toma la variable x justo antes de finalizar el programa.\n1.8. Exportar e importar proyectos\nLas opciones de exportar e importar proyectos sirven para transferir proyectos de un ordenador a otro. Por ejemplo, podemos exportar un proyecto Eclipse a una carpeta de ficheros ubicada en una memoria USB y, en otro ordenador, importar la carpeta.\nPara exportar un proyecto de Eclipse a una carpeta de ficheros, haremos lo siguiente:\nUtiliza la opción de menú File &gt; Export y elegir General &gt; File system (ver Ilustración 10).\nIlustración . Exportar proyectos del workspace.\nMarcaremos el proyecto a exportar y todos sus elementos (carpetas en la parte izquierda, ficheros concretos en la parte izquierda). En general, sólo se suele exportar la carpeta src, dado que los ficheros binarios (bin) se generan a partir de la compilación.\nEn la zona To directory se indicará el nombre de la carpeta que vamos a crear.\nPulsa Finish para finalizar.\nSi ha ido todo bien, habrás generado una carpeta con la estructura de subcarpetas del proyecto actual. Existen otras maneras de exportar proyectos, pero esta es la más sencilla.\nPor otro lado, no es estrictamente necesario exportar el proyecto, sino que es suficiente con guardar los ficheros .java ubicados en la carpeta src.\nPara importar un proyecto tenemos varias alternativas:\nCopiamos la carpeta de ficheros exportada en el workspace del ordenador. Si existe otra carpeta con una versión previa del proyecto (por ejemplo, si estamos practicando la exportación y la importación en el mismo ordenador), deberemos borrar la versión previa para poder importarla correctamente.\nUtilizamos la opción File &gt; Import y a continuación seleccionamos General &gt; Existing projects into workspace (ver Ilustración 11).\nIlustración . Importar proyectos del workspace.\nCrear un nuevo proyecto a partir de clases Java existentes utilizando la opción Import  &gt; General &gt; File system. De esta manera, podríamos importar únicamente los ficheros .java sin necesidad de considerar el resto del proyecto.\nPor ahora recomendamos utilizar la opción General &gt; Existing projects into workspace.\n1.9. Crear y utilizar bibliotecas .jar\nCuando se quiere distribuir una aplicación desarrollada en Java que incluye un número considerable de clases y paquetes, conviene generar una biblioteca. Las bibliotecas en Java son archivos con extensión .jar que comprimen (al estilo de los ficheros .zip) un conjunto de clases compiladas (.class) organizadas en paquetes. Se puede explorar el contenido de un fichero .jar con programas de compresión de ficheros como WinZip.\nPara crear una biblioteca en el entorno Eclipse debemos seleccionar el proyecto que queremos exportar, utilizar la opción de menú File &gt; Export, seleccionar Java &gt; Runnable JAR File y seguir los siguientes pasos, ilustrados en la Ilustración 12:\nEn Launch configuration se elige la clase principal, es decir, la que tiene el método main que se ejecutará una vez que ejecutemos el fichero .jar.\nEn Export destination se indica el nombre del fichero que vamos a crear y la ruta donde se va a almacenar dicho fichero.\nPulsa Finish para finalizar. Si ha ido todo bien, se habrá generado un fichero .jar.\nIlustración . Construcción de una biblioteca .jar.\nSi el programa se llama HolaMundo.jar, podrás ejecutarlo escribiendo en una terminal del sistema operativo lo siguiente:\njava –jar HolaMundo.jar\nPara abrir una terminal en Windows, hay que utilizar la barra de búsqueda e introducir Símbolo del sistema. Antes de poder ejecutar el .jar con la instrucción anterior, debemos posicionarnos en la carpeta que lo contenga. Para simplificar, guarda el fichero .jar en la carpeta raíz del disco duro,  C:, y posteriormente escribe en la ventana de órdenes la siguiente instrucción:\ncd /\n1.10. Añadir bibliotecas a un proyecto\nSi queremos utilizar alguna de las clases ya definidas en Java, simplemente es necesario añadir una sentencia en nuestro programa para importar la biblioteca correspondiente. Por ejemplo, para utilizar las clases definidas en el paquete java.util, hemos añadido en nuestro programa la sentencia\nimport java.util.*;\nEl proceso de incluir bibliotecas diferentes a las incluidas por defecto en Java puede no ser sencillo, ya que hay varias opciones para hacerlo de una manera correcta. Entre las distintas opciones que tenemos para incluir bibliotecas están las siguientes:\nSi tenemos un fichero .jar con las clases compiladas, podemos añadirlo directamente.\nSi tenemos las clases compiladas pero no un fichero .jar, nos puede interesar incluir el directorio con clases compiladas.\nSi vamos a utilizar una biblioteca común, es recomendable crear una variable, e incluirla como biblioteca.\nEn este apartado vamos a describir el primer escenario. Para ello, vamos a importar a modo de ejemplo la biblioteca .jar incluida en Moodle, biblioteca.jar.\nAntes de ello, vamos a escribir en nuestro programa la siguiente instrucción:\nPracticas.escribeMensaje();\nAl compilar, se nos informa de un error: la clase Practicas no ha sido definida todavía. Para solucionarlo, vamos a importar una biblioteca donde se define dicha clase. Debemos hacer click derecho sobre el nombre del proyecto y seleccionar Properties &gt; Java Build Path. Obtendremos una ventana como la de la Ilustración 13.\nA continuación, hacemos click sobre Add External JARs y seleccionamos el fichero a importar.  Una vez hecho esto, podemos comprobar que es posible ejecutar nuestro programa sin ningún tipo de problemas, pues el código necesario se obtiene en el fichero importado.\nIlustración . Añadiendo una biblioteca .jar a un proyecto.\n1.11. Generar documentación\nPara generar la documentación de las clases y paquetes desarrollados se utiliza la herramienta javadoc, incluida en la JDK. Desde el entorno de Eclipse, se facilita la utilización de esta herramienta a través de la opción de menú Project &gt; Generate Javadoc (Ilustración 14).\nEn primer lugar, seleccionamos la ubicación del ejecutable javadoc con el botón Configure. Normalmente, Eclipse detecta automáticamente su ubicación y rellena este campo por nosotros, por lo que no necesitamos hacer nada.\nA continuación, se debe configurar el directorio de salida de la documentación utilizando la caja de texto Destination y el botón Browse asociado.\nPor último, se pulsará el botón Finish para finalizar y generar la documentación. La documentación podrá abrirse con cualquier navegador HTML.\nPruébalo para la clase HolaMundo.\nIlustración . Generación de documentación con la herramienta javadoc."
  },
  {
    "objectID": "practicas/practica2.reveal.html#acceso-a-la-documentación-del-jdk",
    "href": "practicas/practica2.reveal.html#acceso-a-la-documentación-del-jdk",
    "title": "Práctica 2: Un entorno de programación en Java",
    "section": "1.12. Acceso a la documentación del JDK",
    "text": "1.12. Acceso a la documentación del JDK\nJava proporciona una amplia y detallada documentación acerca de las herramientas que incluye el JDK, así como la especificación de la API (Application Programming Interface), es decir, la documentación de las bibliotecas disponibles por defecto en Java. Esta documentación está accesible en la página oficial de Oracle (Ilustración 15), y lo mismo sucede para la documentación de la API (Ilustración 16). Esta documentación puede descargarse para poder consultarla sin necesidad de acceder a Internet; el material descargado puede visualizarse con cualquier navegador web.\nModifica la clase Ejercicio para que cada vez que se ejecute escriba por pantalla un número diferente. Para ello, modifica la instrucción x = 1 con métodos de la clase Math que permitan obtener un número enteros aleatorio: primero se obtendrá un número real aleatorio y luego se redondeará a un número entero. Puede buscarse dicho método en la documentación de la clase java.lang.Math.\nx = Math.???(Math.???());\nIlustración . Documentación del JDK.\nIlustración . Documentación de la API de Java."
  },
  {
    "objectID": "practicas/practica2.reveal.html#apéndice.-instalación-de-eclipse-y-jdk",
    "href": "practicas/practica2.reveal.html#apéndice.-instalación-de-eclipse-y-jdk",
    "title": "Práctica 2: Un entorno de programación en Java",
    "section": "Apéndice. Instalación de Eclipse y JDK",
    "text": "Apéndice. Instalación de Eclipse y JDK\nEn este apéndice explicaremos el proceso de instalación del software necesario para realizar las prácticas de Informática en los ordenadores personales. Existen al menos dos maneras de instalar el software:\nInstalación de Eclipse mediante un instalador\nVisita la página web oficial de Eclipse.\nLocaliza el botón de Download. Nos llevará a la página de descargas.\nLocaliza el panel de Eclipse Installer (Ilustración 17). Debemos reconocer nuestro sistema operativo (Windows, Linux o macOS), y pulsar sobre x86_64.\nUna vez descargado el instalador, lo ejecutamos.\nEl instalador permite obtener múltiples herramientas de Eclipse, aunque nosotros sólo necesitamos el entorno de desarrollo para Java. La instalación es bastante automática, y simplemente tendremos que seleccionar Eclipse IDE for Java Developers (Ilustración 18).\nIlustración . Instalador de la suite de Eclipse.\nIlustración . Herramientas disponibles en la suite de Eclipse.\nUna vez seleccionada dicha opción, se nos dirige a una pantalla como la que se muestra en la Ilustración 19. El objetivo es configurar dos rutas: la localización de las herramientas de desarrollo para Java y la ruta de instalación de Eclipse. Podéis personalizar ambas rutas, pero no es recomendable hacerlo. En particular, la primera ruta apunta a un Java Development Kit (JDK), que, si no queremos descargar junto con Eclipse, deberá instalarse por separado. Esta última opción, aunque es menos sencilla, se describe en el siguiente punto y, entre otras ventajas, permite probar los comandos java y javac en la terminal del ordenador.\nIlustración . Instalación de Eclipse para Java, indicando que queremos descargar un JRE.\nUna opción alternativa consiste en indicar la ruta de un Java Runtime Environment (JRE) (versión 21 o superior) previamente instalado (ver Ilustración 20). Para la descarga e instalación del JDK de Java, por favor, dirígete a la sección B.1 del Apéndice. Por ejemplo, en la siguiente imagen, se ha detectado una instalación en la ruta C:/Program Files/Java/jdk-25, que es la ruta de instalación por defecto de un JDK.\nIlustración . Instalación de Eclipse para Java, indicando la ruta de un JDK previamente instalado.\nInstalación alternativa de Eclipse sin instalador\nInstalación del Java Software Development Kit (JDK)\nPara comenzar, debemos descargar la última versión del JDK de la página web de Oracle:\nDescargamos el JDK de Java de la página oficial de Oracle. En este momento, la última versión disponible es la 25.\nDebemos seleccionar el sistema operativo de nuestro ordenador personal (Linux, macOS o Windows) y descargar un instalador. En Windows, podemos descargar tanto x64 Installer como x64 MSI Installer.\nUna vez descargado, abrimos el archivo para comenzar el proceso de instalación. El proceso es completamente automático y no habrá que hacer nada, salvo utilizar el botón Next para avanzar entre pasos. La ruta de instalación por defecto en Windows es C:/Program Files/Java/jdk-25. Se recomienda no modificar esta ruta, salvo que no tengamos espacio en C:.\nIlustración . Paso intermedio de la instalación del JDK. Se muestra la ruta de instalación por defecto, la cual no modificaremos.\nInstalación de Eclipse\nVisita la página web oficial de Eclipse.\nLocaliza el botón de Download. Nos llevará a la página de descargas.\nPartiendo de un panel similar al de la Ilustración 22, reconocemos nuestro sistema operativo y pulsamos sobre x86_64. Se descargará un .zip con una carpeta dentro llamada eclipse (ver Ilustración 23). Podemos situar dicha carpeta en cualquier directorio de nuestra elección, por ejemplo, en la unidad C:. Ten en cuenta que esta opción no requiere instalación, y por tanto, accederemos siempre a dicha carpeta cuando queramos iniciar Eclipse haciendo click sobre eclipse.exe. En la Ilustración 23 se muestra el contenido del fichero .zip descomprimido.\nIlustración . Panel de descarga de Eclipse sin instalador.\nIlustración . Ficheros contenidos en el directorio eclipse, tras descomprimir el fichero .zip descargado de la página oficial de Eclipse."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "📌 Información general",
    "section": "",
    "text": "En esta página web se irá publicando el material de prácticas actualizado de la asignatura.\nLas prácticas se resolverán utilizando herramientas tales como Processing, Eclipse (programación en Java), Grasshopper (Rhinoceros) o Protegé (ontologías).\nA tener en cuenta a la hora de resolver las prácticas:\n\nRepresentan el 30% de la nota final de la asignatura.\nSe resolverán organizándose en parejas.\nLa asistencia es obligatoria, y se evaluará al final de cada sesión el trabajo realizado.\nSe recomienda leer cada práctica antes de la sesión correspondiente para familiarizarse con los conceptos y herramientas que se van a utilizar.\n\nMás información sobre la asignatura en la documentación oficial de la universidad.\n\n\n\n\n\n\n\nNotaTutorías\n\n\n\nPuedes encontrar nuestro horario de tutorías en los siguientes enlaces:\n\nTutorías de Alfonso López Ruiz\nTutorías de Ignacio Huitzil Velasco\nTutorías de Yamilka Toca Díaz\n\n\n\n\n\n\n\n\n\n\nTipGet started\n\n\n\n¡Comienza leyendo la primera práctica!",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Información",
      "📌 Información general"
    ]
  },
  {
    "objectID": "calendar.html",
    "href": "calendar.html",
    "title": "📅 Calendario",
    "section": "",
    "text": "En esta sección se publicará el calendario de prácticas actualizado. Además:\n\nRecordad que la asistencia a las prácticas es obligatoria.\nAquellas prácticas con una fecha anómala se han marcado con una advertencia ⚠️.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Información",
      "📅 Calendario"
    ]
  },
  {
    "objectID": "practicas/practica1.reveal.html#objetivos-de-la-práctica",
    "href": "practicas/practica1.reveal.html#objetivos-de-la-práctica",
    "title": "Práctica 1: Introducción a Processing",
    "section": "Objetivos de la práctica",
    "text": "Objetivos de la práctica\nLos objetivos de esta práctica son los siguientes:\n\nFamiliarización con el ordenador y los elementos básicos de un sistema operativo.\nFamiliarización con el entorno de desarrollo Processing.\nFamiliarización con aspectos básicos de programación a través de programas en Processing."
  },
  {
    "objectID": "practicas/practica1.reveal.html#processing",
    "href": "practicas/practica1.reveal.html#processing",
    "title": "Práctica 1: Introducción a Processing",
    "section": "Processing",
    "text": "Processing\nIntroducción\n\n\n\nProcessing es un lenguaje de programación y un entorno de desarrollo (Integrated Development Environment, IDE).\n\nBasado en Java.\nProducción de proyectos multimedia e interactivos.\nCreado por científicos del MIT en 2001.\nDistribución gratuita y de código abierto."
  },
  {
    "objectID": "practicas/practica1.reveal.html#dibujando-figuras-geométricas",
    "href": "practicas/practica1.reveal.html#dibujando-figuras-geométricas",
    "title": "Práctica 1: Introducción a Processing",
    "section": "Dibujando figuras geométricas",
    "text": "Dibujando figuras geométricas\nLas figuras geométricas se dibujan en una ventana que está formada por una matriz de píxeles. Cada píxel es un pequeño punto de luz que puede tener un color diferente. La combinación de todos los píxeles forma la imagen que vemos en la pantalla."
  },
  {
    "objectID": "practicas/practica1.reveal.html#color-en-processing",
    "href": "practicas/practica1.reveal.html#color-en-processing",
    "title": "Práctica 1: Introducción a Processing",
    "section": "Color en Processing",
    "text": "Color en Processing\nEscala de grises\n\n\n\nHasta ahora, hemos dibujado figuras geométricas sin especificar ningún color. Por defecto, las figuras se dibujan en negro sobre un fondo blanco.\nA continuación, veremos cómo especificar colores en Processing. Por ahora, basta con componer colores en escala de grises. Para ello hay que tener en cuenta que la escala de un tono de gris va de 0 a 255; el valor 0 corresponde al negro y el valor 255 corresponde al blanco. Por ejemplo, la figura de la derecha se ha representado única y exclusivamente con diferentes valores de gris.\nEn Processing, las figuras tienen borde y relleno, que se definen mediante los métodos stroke y fill. Además, también puede controlarse el color de fondo de la ventana con background.\n\n\n\n\n\n\n\nFigura 8: Imagen representada únicamente con valores de gris."
  },
  {
    "objectID": "practicas/practica1.reveal.html#programas-dinámicos",
    "href": "practicas/practica1.reveal.html#programas-dinámicos",
    "title": "Práctica 1: Introducción a Processing",
    "section": "Programas dinámicos",
    "text": "Programas dinámicos\nHasta este momento, hemos escrito programas estáticos, es decir, programas que dibujan una imagen fija. A continuación, veremos cómo crear programas dinámicos que pueden cambiar con el tiempo."
  },
  {
    "objectID": "practicas/practica1.reveal.html#variables-condicionales-y-bucles",
    "href": "practicas/practica1.reveal.html#variables-condicionales-y-bucles",
    "title": "Práctica 1: Introducción a Processing",
    "section": "Variables, condicionales y bucles",
    "text": "Variables, condicionales y bucles\nIntroducción a variables\nEn la sección anterior hemos descubierto que el método draw se ejecuta de manera repetitiva en un bucle infinito. Esto nos permite crear programas dinámicos que cambian con el tiempo. Sin embargo, para crear programas más complejos, es necesario utilizar variables para almacenar datos que pueden cambiar durante la ejecución del programa.\n\n\n\n\n\n\n🧠 Ejercicio 14 - Traslada una esfera\n\n\nCrea un programa que traslade una esfera de izquierda a derecha en la ventana. Utiliza una variable para almacenar la posición horizontal de la esfera, y actualízala en cada iteración del bucle draw.\n\n\n💡 Solución\n\nint circleX = 100;\nint circleY = 100;\n\nvoid setup() {\n  size(400, 200);\n}\n\nvoid draw() {\n  background(255);\n  stroke(0);\n  fill(175);\n  ellipse(circleX, circleY, 50, 50);\n  circleX = circleX + 1;\n}"
  },
  {
    "objectID": "practicas/practica1.reveal.html#apéndice-instalación-de-processing",
    "href": "practicas/practica1.reveal.html#apéndice-instalación-de-processing",
    "title": "Práctica 1: Introducción a Processing",
    "section": "Apéndice: Instalación de Processing",
    "text": "Apéndice: Instalación de Processing\n\n\nFigura 15: Banner de la página oficial de Processing; a la izquierda se muestra el botón de Download.\n\nAccede a la página oficial de Processing y selecciona Download.\nDescarga la versión correspondiente a tu sistema operativo.\nEjecuta el instalador descargado y sigue las instrucciones."
  },
  {
    "objectID": "practicas/practica1.html",
    "href": "practicas/practica1.html",
    "title": "Práctica 1: Introducción a Processing",
    "section": "",
    "text": "Los objetivos de esta práctica son los siguientes:\n\nFamiliarización con el ordenador y los elementos básicos de un sistema operativo.\nFamiliarización con el entorno de desarrollo Processing.\nFamiliarización con aspectos básicos de programación a través de programas en Processing.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Prácticas",
      "Práctica 1: Introducción a Processing"
    ]
  },
  {
    "objectID": "practicas/practica1.html#objetivos-de-la-práctica",
    "href": "practicas/practica1.html#objetivos-de-la-práctica",
    "title": "Práctica 1: Introducción a Processing",
    "section": "",
    "text": "Los objetivos de esta práctica son los siguientes:\n\nFamiliarización con el ordenador y los elementos básicos de un sistema operativo.\nFamiliarización con el entorno de desarrollo Processing.\nFamiliarización con aspectos básicos de programación a través de programas en Processing.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Prácticas",
      "Práctica 1: Introducción a Processing"
    ]
  },
  {
    "objectID": "practicas/practica1.html#processing",
    "href": "practicas/practica1.html#processing",
    "title": "Práctica 1: Introducción a Processing",
    "section": "2 Processing",
    "text": "2 Processing\n\n2.1 Introducción\n\n\n\nProcessing es un lenguaje de programación y un entorno de desarrollo (Integrated Development Environment, IDE).\n\nBasado en Java.\nProducción de proyectos multimedia e interactivos.\nCreado por científicos del MIT en 2001.\nDistribución gratuita y de código abierto.\n\n\n\n\n\n\n\n\nLa propia página de Processing muestra numerosos ejemplos de proyectos realizados con este lenguaje. También hay muchos ejemplos en Youtube, en particular, en el canal de The Coding Train.\n\n\n\n\n\n\n\n\n\nFigura 1: Visualización del fractal de Mandelbrot.\n\n\n\n\n\n\n\n\n\n\n\nFigura 2: Canal de Youtube The Coding Train.\n\n\n\n\n\n\n\n\n\n2.2 El entorno de desarrollo\nEl entorno de desarrollo de Processing tiene un diseño minimalista que facilita su uso. La interfaz gráfica está compuesta por los siguientes elementos principales:\n\nUn menú de opciones (archivo, editar, sketch, depuración, herramientas y ayuda).\nDos botones para ejecutar y detener el programa.\nUn área central para escribir el código fuente (editor).\nUna ventana inferior donde se muestran dos pestañas:\n\nConsola: salida estándar del programa.\nErrores: mensajes de error generados durante la ejecución.\n\n\n\nAl ejecutar un programa se abrirá una nueva ventana donde se mostrará el resultado de la ejecución.\n\n\n\n\n\n\nFigura 3: Vista del entorno de desarrollo (derecha) y ventana pop-up (izquierda) que redirige a ejemplos disponibles en su página web.\n\n\n\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nEl primer archivo que se crea en un nuevo proyecto de Processing se denomina sketch_yymmdda. Es recomendable cambiar el nombre del archivo para que tenga sentido con el programa que se va a desarrollar. Además, al guardarlo nos preguntará el nombre del proyecto, que también es recomendable que tenga sentido.\nIndicad una ubicación de fácil acceso en vuestro ordenador para guardar los proyectos de Processing.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Prácticas",
      "Práctica 1: Introducción a Processing"
    ]
  },
  {
    "objectID": "practicas/practica1.html#dibujando-figuras-geométricas",
    "href": "practicas/practica1.html#dibujando-figuras-geométricas",
    "title": "Práctica 1: Introducción a Processing",
    "section": "3 Dibujando figuras geométricas",
    "text": "3 Dibujando figuras geométricas\nLas figuras geométricas se dibujan en una ventana que está formada por una matriz de píxeles. Cada píxel es un pequeño punto de luz que puede tener un color diferente. La combinación de todos los píxeles forma la imagen que vemos en la pantalla.\n\nUn píxel es la unidad más pequeña de una imagen digital. La resolución de una imagen se refiere a la cantidad de píxeles que contiene, y se expresa como el número de píxeles en el eje horizontal por el número de píxeles en el eje vertical (por ejemplo, 1920x1080 píxeles). Por ejemplo, la Figura 4 muestra una animación con una resolución alta, donde los píxeles no son visibles a simple vista. En cambio, en la Figura 5 se ha reducido la resolución de la animación, y comienzan a ser visibles los píxeles individuales.\n\n\n\n\n\n\nVideo\n\n\nFigura 4: Animación con una resolución de pantalla alta.\n\n\n\n\n\n\n\n\nVideo\n\n\nFigura 5: Animación con una resolución de pantalla más baja, donde comienzan a ser visibles los píxeles.\n\n\n\n\n\n\n\n\n\n\nPara dibujar cualquier figura geométrica, es necesario especificar una o varias posiciones en la ventana. Dichas posiciones se definen mediante un par de coordenadas (x, y), donde x indica la posición horizontal e y la posición vertical. En Processing, el origen de coordenadas (0,0) se encuentra en la esquina superior izquierda de la ventana, como se muestra en la Figura 6.\n\n\n\n\n\n\nNota🧠 Ejercicio 1 - Sistema de coordenadas\n\n\n\nDibuja una línea que va desde la posición (10, 0) hasta la posición (40, 50). Cuando se ejecute, os podréis dar cuenta de que el origen, (0,0), parte de la esquina superior izquierda.\nline(10, 0, 40, 50);\n\n\n\n\n\n\n\n\n\n\nFigura 6: Ilustración de una matriz de píxeles, indicando las coordenadas de algunos de ellos.\n\n\n\n\n\n\n\nEste concepto puede entenderse como darle un nombre a un conjunto de instrucciones para poder reutilizarlas fácilmente más adelante. En matemáticas, una función toma uno o varios valores de entrada y produce un valor de salida siguiendo una regla. Por ejemplo, la función \\(f(x) = x^2\\) toma un número \\(x\\) y devuelve su cuadrado.\nEn programación ocurre algo muy similar: una función recibe unos parámetros, ejecuta unas instrucciones con ellos y, opcionalmente, devuelve un resultado.\n\nPor ejemplo, podemos definir en Java una función que reciba un número entero y devuelva su cuadrado:\nint square(int x) {\n  return x * x;\n}\nUna vez definida, podemos usar la función tantas veces como queramos, simplemente indicando el valor de entrada:\nint result = square(5);  // result tendrá el valor 25\nDe este modo:\n\nsquare es el nombre de la función.\nx es el parámetro de entrada.\nreturn indica el valor que devuelve la función.\n\nEn Processing ocurre exactamente lo mismo. La función line, por ejemplo, recibe cuatro parámetros (las coordenadas de dos puntos) y ejecuta una acción: dibujar una línea en la ventana. La diferencia es que, en este caso, la función no devuelve un valor, sino que produce un efecto visual en pantalla.\n\n\n\n\n\n\n\nAdvertenciaEjercicio 2 - Errores comunes\n\n\n\nPrueba a copiar el siguiente código en el editor de Processing y ejecutarlo:\nLine(10, 0, 40, 50);\n\n\n💡 Solución\n\nProcessing es sensible al uso de mayúsculas y minúsculas. Por ejemplo, la función para dibujar una línea es line, no Line ni LINE.\nLas palabras reservadas se muestran resaltadas en el editor, por lo que esta es una manera de ver si el nombre de una función está bien escrito. Los errores se muestran en la pestaña Errores de la ventana inferior.\n\n\n\n\n\n\n\n\n\nNota🧠 Ejercicio 3 - Múltiples formas geométricas\n\n\n\nPrueba a dibujar varias líneas en diferentes posiciones de la pantalla, utilizando la instrucción line varias veces.\n\n\n\n\n3.1 Lienzo\nLas figuras geométricas se dibujan sobre un lienzo de tamaño predeterminado 100x100 píxeles. No obstante, es posible cambiar el tamaño del lienzo utilizando la función size, que recibe dos parámetros: el ancho y el alto del lienzo en píxeles.\n\n\n\n\n\n\nNota🧠 Ejercicio 4 - Tamaño del lienzo\n\n\n\nDibuja varias líneas en un lienzo de tamaño 300x200 píxeles.\n\n\n💡 Solución\n\nsize(300, 200);\nline(10, 0, 40, 50);\nline(100, 50, 200, 150);\nline(250, 0, 250, 200);\n\n\n\n\n\n\n3.2 Tipos de figuras geométricas\nAdemás de la línea utilizada en los ejercicios anteriores, Processing permite dibujar otras figuras geométricas básicas, tales como puntos, triángulos, cuadriláteros, rectángulos y elipses.\n\n\n\n\n\n\nNota🧠 Ejercicio 5 - Deducción de parámetros\n\n\n\n¿Puedes deducir qué parámetros son necesarios para dibujar algunas de las figuras geométricas mencionadas anteriormente? Puedes consultar la documentación oficial de Processing, y más concretamente, la sección 2d primitives en el apartado Shape.\n\n\n💡 Solución\n\n\npoint(x, y): un punto en la posición (x, y).\ntriangle(x1, y1, x2, y2, x3, y3): un triángulo con vértices en las posiciones (x1, y1), (x2, y2) y (x3, y3).\nquad(x1, y1, x2, y2, x3, y3, x4, y4): un cuadrilátero con vértices en las posiciones (x1, y1), (x2, y2), (x3, y3) y (x4, y4).\nrect(x, y, anchura, altura): un rectángulo con esquina superior izquierda en la posición (x, y), de anchura y altura especificadas.\nellipse(x, y, anchura, altura): una elipse centrada en la posición (x, y), con anchura y altura especificadas.\n\n\n\n\n\n\n3.2.1 Dibujando rectángulos y elipses\nTanto en la documentación oficial, como en la solución del ejercicio anterior, os habréis podido dar cuenta de que las funciones rect y ellipse requieren cuatro parámetros: dos para la posición y dos para el tamaño. Sin embargo, hemos asumido que la posición siempre corresponde a la esquina superior izquierda del rectángulo o al centro de la elipse. Esta suposición es correcta por defecto, pero es posible cambiarla utilizando las funciones rectMode y ellipseMode. Más concretamente, estas funciones permiten definir cómo se interpretan las posiciones pasadas como parámetros a las funciones rect y ellipse. Existen dos modos principales para cada una de estas funciones:\n\nCORNER: la posición corresponde a la esquina superior izquierda del rectángulo o elipse.\nCENTER: la posición corresponde al centro del rectángulo o elipse.\n\n\n\n\n\n\n\n\nFigura 7: Representación de cómo se interpretan las posiciones en ambos modos para rectángulos y elipses.\n\n\n\n\nPor defecto, Processing interpreta las posiciones de la siguiente manera:\nrectMode(CORNER);\nellipseMode(CENTER);\nTambién es posible cambiar esta interpretación usando:\nrectMode(CENTER);\nellipseMode(CORNER);\n\n\n\n\n\n\nNota🧠 Ejercicio 6 - Modo de dibujo\n\n\n\nIntenta dibujar un círculo centrado en (20, 30) con radio 10 utilizando ambos modos. En el siguiente código tienes todas las instrucciones necesarias para completar el ejercicio:\n// Modo por defecto\nellipseMode(CENTER);\nellipse( , , , );\n\n// Modo alternativo\nellipseMode(CORNER);\nellipse( , , , );",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Prácticas",
      "Práctica 1: Introducción a Processing"
    ]
  },
  {
    "objectID": "practicas/practica1.html#color-en-processing",
    "href": "practicas/practica1.html#color-en-processing",
    "title": "Práctica 1: Introducción a Processing",
    "section": "4 Color en Processing",
    "text": "4 Color en Processing\n\n4.1 Escala de grises\n\n\n\nHasta ahora, hemos dibujado figuras geométricas sin especificar ningún color. Por defecto, las figuras se dibujan en negro sobre un fondo blanco.\nA continuación, veremos cómo especificar colores en Processing. Por ahora, basta con componer colores en escala de grises. Para ello hay que tener en cuenta que la escala de un tono de gris va de 0 a 255; el valor 0 corresponde al negro y el valor 255 corresponde al blanco. Por ejemplo, la figura de la derecha se ha representado única y exclusivamente con diferentes valores de gris.\nEn Processing, las figuras tienen borde y relleno, que se definen mediante los métodos stroke y fill. Además, también puede controlarse el color de fondo de la ventana con background.\n\n\n\n\n\n\n\n\nFigura 8: Imagen representada únicamente con valores de gris.\n\n\n\n\n\n\n\nPor ejemplo, podemos definir el color del fondo, así como del borde y el relleno de un rectángulo de la siguiente manera:\nbackground(0);              // fondo \n\nstroke(200);                // borde\nfill(100);                  // relleno\nrect(50, 50, 100, 100);\nAdemás, cabe destacar que Processing funciona como una máquina de estados; es decir, una vez se indica el color de borde o de relleno, este se utilizará para todas las figuras que se dibujen a continuación. Por ejemplo, podemos dibujar dos rectángulos con el mismo color de borde, pero diferente color de relleno, de la siguiente manera:\nstroke(0);\nfill(150);\nrect(20, 20, 50, 50);       // borde negro, relleno gris\n\nfill(50);\nrect(80, 20, 50, 50);       // mismo borde, diferente relleno\n\n\n\n\n\n\n\n\n\n\nNota🧠 Ejercicio 7 - Círculo y colores\n\n\n\nDibuja un círculo negro con borde gris, centrado en (20, 30) y con radio 10.\n\n\n💡 Solución\n\nstroke(128);\nfill(0);\nellipse(20, 30, 20, 20);\n\n\n\nIntenta crear un lienzo de tamaño 30x30 y repite este ejercicio. ¿Qué sucede ahora?\n\n\n\n\n\n\n\n\nNota🧠 Ejercicio 8 - Dibuja una forma geométrica\n\n\n\nTrata de obtener algo parecido a la figura que se muestra debajo.\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.2 Colores RGB (red, green, blue)\n\n\n\n\n\n\n\n\n\nFigura 9: Representación de los colores primarios RGB.\n\n\n\n\n\nAdemás de diferentes tonos de gris, Processing permite definir colores a partir de los tres colores primarios: rojo, verde y azul (RGB). Cuando los tres componentes toman el valor máximo (255), el color resultante es el blanco. En una escala de grises, los tres valores RGB coinciden; por ejemplo, el color (0, 0, 0) corresponde al negro. Por otro lado, si sólo activamos un canal con 255, y dejamos el resto a 0, obtenemos rojo, verde o azul.\nfill(255, 0, 0);  // rojo\nfill(0, 255, 0);  // verde\nfill(0, 0, 255);  // azul\n\n\n\n\n\n\n\n\n\nNota🧠 Ejercicio 9 - Colores RGB\n\n\n\n¿Sabrías decir qué colores crearán las siguientes combinaciones de rojo, verde y azul?\n\nfill(255, 255, 0)\nfill(0, 255, 255)\nfill(255, 0, 255)\nfill(255, 255, 127)\nfill(127, 255, 255)\nfill(255, 127, 255)\n\nPista: fíjate en la Figura 9.\n\n\n\n\n\n\n\n\n\n\n\n\nFigura 10: Captura de pantalla del selector de color de Processing.\n\n\n\n\n\nComo habréis podido observar a partir del Ejercicio 9, no es sencillo imaginar qué color genera una mezcla concreta de valores RGB, ni determinar qué valores exactos u aproximados de rojo, verde y azul necesitamos para componer un color que tengamos en mente. Por esta razón, Processing dispone de una herramienta, Selector de color, que permite interactuar con una paleta de colores y obtener valores de rojo, verde y azul. Podéis acceder a esta herramienta desde el menú Herramientas &gt; Selector de color.\n\n\n\n\n\n\n4.3 Opacidad\nAdemás de los canales R, G y B, también podemos indicar un valor de opacidad. De esta manera, un valor de opacidad de 255 indica que elemento a dibujar es completamente opaco, y un valor de 0 indica que es completamente transparente. Para especificar la opacidad, bastante con indicar un cuarto valor en operaciones como stroke o fill.\nfill(255, 255, 127);\nrect(50, 50, 100, 100);     // rectángulo opaco     \n\nfill(255, 0, 127, 127);     \nrect(20, 20, 50, 50);       // rectángulo semitransparente",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Prácticas",
      "Práctica 1: Introducción a Processing"
    ]
  },
  {
    "objectID": "practicas/practica1.html#programas-dinámicos",
    "href": "practicas/practica1.html#programas-dinámicos",
    "title": "Práctica 1: Introducción a Processing",
    "section": "5 Programas dinámicos",
    "text": "5 Programas dinámicos\nHasta este momento, hemos escrito programas estáticos, es decir, programas que dibujan una imagen fija. A continuación, veremos cómo crear programas dinámicos que pueden cambiar con el tiempo.\n\n\n\n\nComenzaremos con este bloque de código:\nsize(600, 600);\n\n// Fondo blanco\nbackground(255);\n\n// Coordenadas desde el centro\nellipseMode(CENTER);\nrectMode(CENTER);\n\n// CUERPO\nstroke(0);\nfill(150);\nrect(200, 260, 50, 260);\n\n// CABEZA\nfill(255);\nellipse(200, 160, 130, 160);\n\n// OJOS\nfill(0);\nellipse(170, 160, 30, 60);\nellipse(230, 160, 30, 60);\n\n// PIERNAS\nstroke(0);\nline(175, 390, 150, 420);\nline(226, 390, 250, 420);\n\n\n\n\n\n\n\n\nFigura 11: Imagen del alienígena Zoog.\n\n\n\n\n\n\n\n\n\nNota🧠 Ejercicio 10 - Dibuja a Zoog\n\n\n\nIntenta dibujar al alienígena Zoog utilizando el bloque de código anterior como referencia.\n\n\n\n\n\n\n\n5.1 Comentarios\nAprovechando que nuestro programa empieza a ser un poco más largo, es recomendable añadir comentarios para explicar qué hace cada parte del código. En Processing, los comentarios se indican con // para comentarios de una sola línea, o con /* y */ para comentarios multilínea. Además de para indicar qué hace una parte de nuestro código, también se pueden usar para desactivar temporalmente líneas de código durante la depuración. Por ejemplo, en el siguiente código se han añadido comentarios para explicar qué parte del cuerpo de Zoog dibuja cada bloque de instrucciones, y para desactivar el dibujo de la cabeza temporalmente:\n// Dibuja el cuerpo de Zoog\nrect(200, 260, 50, 260);\n\n/* Dibuja la cabeza de Zoog en la posición (200, 140) con ancho y alto 120 */\n//ellipse(200, 160, 130, 160);        // Desactivado temporalmente\n\n// Dibuja los ojos de Zoog\n/*ellipse(170, 160, 30, 60);\nellipse(230, 160, 30, 60);*/          // Ojo derecho\n\n\n\n5.2 Funciones setup y draw\nCuando ejecutamos un programa en Processing, el código no se ejecuta de arriba a abajo una sola vez, sino que utiliza un modelo de ejecución basado en dos fases bien diferenciadas: setup() y draw().\n\n\n\n\n\nAl pulsar el botón ▶️, Processing inicia el programa y lo primero que hace es llamar a la función setup().\nLa función setup() se ejecuta una única vez al comienzo del programa. Su objetivo es preparar el entorno antes de empezar a dibujar. En esta función se suele definir el tamaño de la ventana, inicializar variables, configurar colores o modos de dibujo y cargar recursos como imágenes o fuentes. Una vez que setup() termina, Processing no vuelve a ejecutarla.\nDespués de setup(), Processing entra automáticamente en la función draw(). La función draw() se ejecuta repetidamente, normalmente unas sesenta veces por segundo. En cada ejecución se dibuja un nuevo fotograma y se actualizan posiciones o estados. Gracias a este bucle continuo es posible crear animaciones, juegos y visualizaciones interactivas.\n\n\n\n\n\n\n\nFigura 12: Analogía del funcionamiento de Processing, y el proceso de animación. El resultado final se compone de varias llamadas a draw, y en cada llamada, se dibujan múltiples tipos de geometría.\n\n\n\n\n\n\n\n\n\n\nflowchart TD\n    A[\"El programa comienza\"]\n    B[\"setup()\"]\n    C[\"Inicializa ventana y variables\"]\n    D[\"setup() termina\"]\n    E[\"draw()\"]\n    F[\"Dibuja un fotograma\"]\n    G[\"Actualiza estado\"]\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    D --&gt; E\n    E --&gt; F\n    F --&gt; G\n    G --&gt; E\n\n\n\n\n\n\n\n\n\n\nTanto setup como draw son funciones especiales que no requieren ser llamadas explícitamente en el código; Processing se encarga de ello automáticamente. Por ahora, sólo cabe destacar que el código que se encuentra dentro de una función debe estar sangrado (indentado) para indicar que pertenece a dicha función. Además, ambas funciones devuelven void, lo que significa que no devuelven ningún valor. También es importante abrir y cerrar llaves {} para definir el bloque de código que pertenece a cada función.\n\n\n\n\n\n\n\nNota🧠 Ejercicio 11 - Zoog, utilizando setup y draw\n\n\n\nReescribe el código de Zoog utilizando las funciones setup y draw. ¿Notas alguna diferencia en el resultado respecto al código original?\nvoid setup() {\n  // Tamaño del lienzo\n  size(600, 600);\n}\n\nvoid draw() {\n  // Fondo blanco\n  background(255);\n\n  // Coordenadas desde el centro\n  ellipseMode(CENTER);\n  rectMode(CENTER);\n\n  // CUERPO\n  stroke(0);\n  fill(150);\n  rect(200, 260, 50, 260);\n\n  // CABEZA\n  fill(255);\n  ellipse(200, 160, 130, 160);\n\n  // OJOS\n  fill(0);\n  ellipse(170, 160, 30, 60);\n  ellipse(230, 160, 30, 60);\n\n  // PIERNAS\n  stroke(0);\n  line(175, 390, 150, 420);\n  line(226, 390, 250, 420);\n}\n\n\n\n\n\n\n\n\n\nAdvertencia🔴 Color de fondo\n\n\n\nPrueba a mover la instrucción background(255); desde la función draw a la función setup. ¿Qué ocurre?\n\n\n\n\n\n5.3 Interacción con el ratón\nEn Processing existen algunas palabras reservadas como width y height, que permiten acceder al ancho y alto de la ventana, respectivamente, y otras que permiten interactuar con el usuario, como mouseX y mouseY, que indican la posición actual del ratón en la ventana.\n\n\n\n\n\n\n\n\n\n\nNota🧠 Ejercicio 12 - Sigue al ratón\n\n\n\nModifica el programa de Zoog para que la esquina superior izquierda del cuerpo de Zoog sea la posición del ratón, utilizando mouseX y mouseY.\n\n\n\n\n\n\n\n\nNota🧠 Ejercicio 13 - Sigue al ratón II\n\n\n\nPosiciona la cabeza de Zoog sobre el cuerpo, de acuerdo también a las coordenadas (mouseX, mouseY), de manera que la cabeza se mueva en función de la posición del ratón. Por supuesto, tendrás que ajustar también la posición de los ojos.\n\n\n\n\n\n\n\n\nNota🧠 Ejercicio extra - Sigue al ratón III\n\n\n\nIntenta que las piernas de Zoog también sigan al ratón, manteniendo la misma distancia relativa con el cuerpo.\n\n\n\n\n\n\n\n\n\n\nFigura 13: Algunas medidas de Zoog.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Prácticas",
      "Práctica 1: Introducción a Processing"
    ]
  },
  {
    "objectID": "practicas/practica1.html#variables-condicionales-y-bucles",
    "href": "practicas/practica1.html#variables-condicionales-y-bucles",
    "title": "Práctica 1: Introducción a Processing",
    "section": "6 Variables, condicionales y bucles",
    "text": "6 Variables, condicionales y bucles\n\n6.1 Introducción a variables\nEn la sección anterior hemos descubierto que el método draw se ejecuta de manera repetitiva en un bucle infinito. Esto nos permite crear programas dinámicos que cambian con el tiempo. Sin embargo, para crear programas más complejos, es necesario utilizar variables para almacenar datos que pueden cambiar durante la ejecución del programa.\n\n\n\n\n\n\nNota🧠 Ejercicio 14 - Traslada una esfera\n\n\n\nCrea un programa que traslade una esfera de izquierda a derecha en la ventana. Utiliza una variable para almacenar la posición horizontal de la esfera, y actualízala en cada iteración del bucle draw.\n\n\n💡 Solución\n\nint circleX = 100;\nint circleY = 100;\n\nvoid setup() {\n  size(400, 200);\n}\n\nvoid draw() {\n  background(255);\n  stroke(0);\n  fill(175);\n  ellipse(circleX, circleY, 50, 50);\n  circleX = circleX + 1;\n}\n\n\n\n\n\n\n6.2 Condicionales\nLos condicionales permiten ejecutar diferentes bloques de código en función de si se cumple o no una determinada condición. En Processing, los condicionales se implementan utilizando las palabras reservadas if, else if y else.\nLa sintaxis básica de un condicional es la siguiente:\nif (condición) {\n  // bloque de código si la condición es verdadera\n} else if (otra_condición) {\n  // bloque de código si la otra condición es verdadera\n} else {\n  // bloque de código si ninguna condición es verdadera\n}\nTen en cuenta que no siempre es necesario utilizar else if o else; un condicional puede consistir únicamente en una instrucción if.\n\n\n\n\n\n\n\nNota🧠 Ejercicio 15 - Color de fondo interactivo\n\n\n\nModifica el programa de Zoog para que el color de fondo cambie en función de la posición del ratón. Por ejemplo, si el ratón se encuentra en el primer tercio de la ventana, el fondo debe ser blanco; si está en el segundo tercio, el fondo debe ser gris; y si está en el tercer tercio, el fondo debe ser negro.\n💡 Pista: en el código que hemos utilizado para dibujar a Zoog se define una ventana de tamaño 600x600. Puedes comprobar si mouseX o mouseY se encuentran en un determinado tercio de la pantalla:\nif (mouseX &lt; 200) {\n    ...\n}\nelse if (...) {\n    ...\n}\nelse {\n    ...\n}\n\n\n\n\n\n6.3 Bucles\nExisten algunas palabras reservadas en Java para representar bucles, es decir, bloques de código que se repiten durante un número de iteraciones, o infinitamente hasta que no se cumpla alguna condición.\nEn esta sesión es suficiente con conocer el bucle for, que permite ejecutar un bloque de código un número determinado de veces. La sintaxis básica de un bucle for es la siguiente:\nfor (int i = 1; i &lt;= N; i++) {\n  // bloque de código a ejecutar N veces\n}\n\n\n\n\n\n\n\nNota🧠 Ejercicio 16 - Múltiples Zoog\n\n\n\nEl objetivo es mostrar 2 Zoogs en la pantalla a partir del programa de un único Zoog. Ten en cuenta que tendrás que modificar la posición de al menos uno de ellos para que sea visible.\nA modo de inspiración, el siguiente código dibuja dos rectángulos desplazados en el eje horizontal y vertical en función de i:\nsize(500, 200);\n\nint N = 2;\nfloat offsetX = 0;\nfloat offsetY = 0;\n\nfor (int i = 1; i &lt;= N; i++) {\n  rect(50 + offsetX, 20 + offsetY, 80, 80);\n\n  offsetX += 100;\n  offsetY += 10;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nNota🧠 Ejercicio 17 - Z pares de brazos\n\n\n\nModifica el programa de Zoog para que dibuje Z pares de brazos, donde Z es una variable que puedes definir al principio del programa. Utiliza un bucle for para dibujar los brazos.\n\n\n\n\n\n\n\n\n\n\nFigura 14: Resultado de añadir 3 pares de brazos a Zoog.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Prácticas",
      "Práctica 1: Introducción a Processing"
    ]
  },
  {
    "objectID": "practicas/practica1.html#apéndice-instalación-de-processing",
    "href": "practicas/practica1.html#apéndice-instalación-de-processing",
    "title": "Práctica 1: Introducción a Processing",
    "section": "Apéndice: Instalación de Processing",
    "text": "Apéndice: Instalación de Processing\n\n\n\n\n\n\nFigura 15: Banner de la página oficial de Processing; a la izquierda se muestra el botón de Download.\n\n\n\n\nAccede a la página oficial de Processing y selecciona Download.\nDescarga la versión correspondiente a tu sistema operativo.\nEjecuta el instalador descargado y sigue las instrucciones.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Prácticas",
      "Práctica 1: Introducción a Processing"
    ]
  },
  {
    "objectID": "practicas/practica3.reveal.html#objetivos-de-la-práctica",
    "href": "practicas/practica3.reveal.html#objetivos-de-la-práctica",
    "title": "Práctica 3: Resolución de problemas en Java (I)",
    "section": "Objetivos de la práctica",
    "text": "Objetivos de la práctica\n\nAlgoritmos para la resolución de problemas.\nImplementar algoritmos en Java.\nEjecutar algoritmos en el entorno Eclipse."
  },
  {
    "objectID": "practicas/practica3.reveal.html#raíces-de-una-ecuación-de-segundo-grado",
    "href": "practicas/practica3.reveal.html#raíces-de-una-ecuación-de-segundo-grado",
    "title": "Práctica 3: Resolución de problemas en Java (I)",
    "section": "Raíces de una ecuación de segundo grado",
    "text": "Raíces de una ecuación de segundo grado\nComo bien sabemos, una ecuación de segundo grado tiene la forma:\n\\[\nax^2 + bx + c = 0\n\\]\ndonde \\(a\\), \\(b\\) y \\(c\\) son coeficientes reales, y \\(x\\) es la variable que queremos resolver.\nA diferencia de las ecuaciones de primer grado, las de segundo grado pueden tener 0, 1 o 2 soluciones reales dependiendo de los valores de los coeficientes (\\(a\\), \\(b\\), \\(c\\)).\nPor ejemplo, los siguientes coeficientes generan diferentes números de soluciones:\n\n\\(a=1\\), \\(b=-3\\), \\(c=2\\) → dos soluciones reales (\\(x=1\\) y \\(x=2\\)).\n\\(a=1\\), \\(b=-2\\), \\(c=1\\) → una solución real (\\(x=1\\)).\n\\(a=1\\), \\(b=0\\), \\(c=1\\) → no soluciones reales.\n\n\n\n\nviewof params = {\n      const cleanSlider = (range, config) =&gt; {\n        const input = Inputs.range(range, config);\n        const numberBox = input.querySelector(\"input[type=number]\");\n        if (numberBox) numberBox.style.display = \"none\";\n        const rangeSlider = input.querySelector(\"input[type=range]\");\n        if (rangeSlider) rangeSlider.style.width = \"100%\";\n        input.style.width = \"100%\";\n        return input;\n      };\n\n      const ia = cleanSlider([-5, 5], { value: 1, step: 0.1 });\n      const ib = cleanSlider([-10, 10], { value: -2, step: 0.1 });\n      const ic = cleanSlider([-10, 10], { value: -3, step: 0.1 });\n\n      const col = (input, label) =&gt; {\n        const val = htl.html`&lt;div style=\"font-family: monospace; color: #555; margin-top: 4px;\"&gt;${input.value.toFixed(1)}&lt;/div&gt;`;\n        input.addEventListener(\"input\", () =&gt; val.textContent = input.value.toFixed(1));\n        \n        return htl.html`&lt;div style=\"display: flex; flex-direction: column; align-items: center; margin: 0 10px; flex: 1; min-width: 120px;\"&gt;\n          &lt;div style=\"font-weight: bold; font-size: 0.9rem; margin-bottom: 5px; white-space: nowrap;\"&gt;${label}&lt;/div&gt;\n          &lt;div style=\"width: 100%\"&gt;${input}&lt;/div&gt;\n          ${val}\n        &lt;/div&gt;`;\n      };\n\n      // Styles: Removed background/border here so it blends into the card\n      const form = htl.html`&lt;div style=\"display: flex; flex-wrap: wrap; justify-content: center; width: 100%; padding-bottom: 20px; border-bottom: 1px solid #eee; margin-bottom: 20px;\"&gt;\n        ${col(ia, \"a (curvatura)\")}\n        ${col(ib, \"b (pendiente)\")}\n        ${col(ic, \"c (desplazamiento ↑↓)\")}\n      &lt;/div&gt;`;\n\n      form.oninput = () =&gt; form.value = { a: ia.value, b: ib.value, c: ic.value };\n      form.value = { a: ia.value, b: ib.value, c: ic.value };\n      return form;\n    }\n\n    // Extract variables for reactivity\n    a = params.a\n    b = params.b\n    c = params.c\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\n      const curve = Array.from({ length: 401 }, (_, i) =&gt; {\n        const x = -10 + i * 0.05;\n        return { x, y: a * x * x + b * x + c };\n      });\n\n      const points = [];\n      const disc = b * b - 4 * a * c; \n      \n      if (a !== 0 && disc &gt;= 0) {\n        const r1 = (-b + Math.sqrt(disc)) / (2 * a);\n        const r2 = (-b - Math.sqrt(disc)) / (2 * a);\n        points.push({ x: r1, y: 0, type: \"Root\", label: `x=${r1.toFixed(2)}` });\n        if (disc &gt; 0) points.push({ x: r2, y: 0, type: \"Root\", label: `x=${r2.toFixed(2)}` });\n      } else if (a === 0 && b !== 0) {\n        const root = -c / b;\n        points.push({ x: root, y: 0, type: \"Root\", label: `x=${root.toFixed(2)}` });\n      }\n\n      const curve_plot = Plot.plot({\n        height: 400,\n        grid: true,\n        marginLeft: 40, \n        marginRight: 20,\n        x: { domain: [-10, 10], label: \"x axis\" },\n        y: { domain: [-10, 10], label: null }, // Removed Y label to save space\n        marks: [\n          Plot.ruleY([0], { stroke: \"#888\", strokeWidth: 1.5 }),\n          Plot.ruleX([0], { stroke: \"#888\", strokeWidth: 1.5 }),\n          Plot.line(curve, { x: \"x\", y: \"y\", stroke: \"steelblue\", strokeWidth: 3 }),\n          Plot.dot(points, { x: \"x\", y: \"y\", fill: d =&gt; d.type === \"Root\" ? \"#e63946\" : \"#457b9d\", r: 6, stroke: \"white\", strokeWidth: 2 }),\n          Plot.text(points, { x: \"x\", y: \"y\", text: \"label\", dy: -15, fill: \"currentColor\", stroke: \"white\", strokeWidth: 4, fontWeight: \"bold\", fontSize: 12 })\n        ]\n      });\n      \n      // Ensure the SVG fills the card width\n      curve_plot.style.width = \"100%\";\n      return curve_plot;\n    }"
  },
  {
    "objectID": "practicas/practica3.reveal.html#resolución-de-la-práctica",
    "href": "practicas/practica3.reveal.html#resolución-de-la-práctica",
    "title": "Práctica 3: Resolución de problemas en Java (I)",
    "section": "Resolución de la práctica",
    "text": "Resolución de la práctica\nPara resolver esta práctica se propone implementar tres clases en Java que correspondan a cada uno de los casos de solución de la ecuación cuadrática.\nDe manera general, ten en cuenta que la solución única o doble de la ecuación se calcula a través de la siguiente fórmula, conocida como la fórmula general: \\[\nx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} = \\frac{-b \\pm \\sqrt{\\Delta}}{2a}\n\\]\nEl valor dentro de la raíz cuadrada, \\(b^2 - 4ac\\), se llama discriminante (\\(\\Delta\\)) y determina el número de soluciones reales que tiene la ecuación:\nClase 1: dos soluciones reales\nSi \\(\\Delta &gt; 0\\), la ecuación tiene dos soluciones reales distintas, que se calculan con la fórmula general utilizando el símbolo \\(+\\) para una raíz y el símbolo \\(-\\) para la otra raíz.\nVerifica que la solución es correcta utilizando los siguientes coeficientes:\n\n\\(a=1, \\quad b=-3, \\quad c=2\\) → dos soluciones reales (\\(x=1\\) y \\(x=2\\)).\n\n\n\n\n\n\n\nClases en Java\n\n\nRecuerda que, en Java, una clase toma el siguiente formato general:\npublic class NombreDeLaClase {\n    /*\n    * @author: Vuestros nombres\n    * @date: Fecha de entrega\n    */\n    public static void main(String[] args) {\n        // solución del problema\n    }\n}\n\n\n\n\n\n\n\n\n\nImprimir resultados en Java\n\n\nUtiliza la impresión por consola para mostrar los resultados de las soluciones, por ejemplo:\nSystem.out.println(\"La solución es: \" + x);\n\n\n\nClase 2: una solución real\nSi \\(\\Delta = 0\\), la ecuación tiene una única solución real, que se calcula con la fórmula general utilizando cualquiera de los símbolos \\(+\\) o \\(-\\), ya que ambos darán el mismo resultado.\n\n\n\n\n\n\nSolución única\n\n\nVerifica que la solución es correcta utilizando los siguientes coeficientes:\n\n\\(a=1, \\quad b=-2, \\quad c=1\\) → una solución real (\\(x=1\\)).\n\n\n\n\nClase 3: no soluciones reales\nSi \\(\\Delta &lt; 0\\), la ecuación no tiene soluciones reales, ya que la raíz cuadrada de un número negativo no es un número real. En este caso, se pueden calcular las soluciones complejas utilizando números imaginarios de la siguiente forma: \\[\nx = \\frac{-b \\pm i\\sqrt{-(b^2 - 4ac)}}{2a} = \\frac{-b \\pm i\\sqrt{4ac - b^2}}{2a}\n\\]\nde tal manera que el número imaginario \\(i\\) se define como la raíz cuadrada de \\(-1\\).\nPor tanto, las dos soluciones complejas conjugadas se pueden expresar como: \\[\nx_1 = \\frac{-b + i\\sqrt{4ac - b^2}}{2a} \\quad \\text{y} \\quad x_2 = \\frac{-b - i\\sqrt{4ac - b^2}}{2a}\n\\]\n\n\n\n\n\n\nSolución compleja\n\n\nVerifica que la solución es correcta utilizando los siguientes coeficientes:\n\\(a=1, \\quad b=0, \\quad c=1\\)\nLas soluciones son: \\[x_1 = 0 + 1i\\] \\[x_2 = 0 - 1i\\]"
  },
  {
    "objectID": "practicas/practica3.html",
    "href": "practicas/practica3.html",
    "title": "Práctica 3: Resolución de problemas en Java (I)",
    "section": "",
    "text": "Algoritmos para la resolución de problemas.\nImplementar algoritmos en Java.\nEjecutar algoritmos en el entorno Eclipse.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Prácticas",
      "Práctica 3: Resolución de problemas en Java (I)"
    ]
  },
  {
    "objectID": "practicas/practica3.html#objetivos-de-la-práctica",
    "href": "practicas/practica3.html#objetivos-de-la-práctica",
    "title": "Práctica 3: Resolución de problemas en Java (I)",
    "section": "",
    "text": "Algoritmos para la resolución de problemas.\nImplementar algoritmos en Java.\nEjecutar algoritmos en el entorno Eclipse.",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Prácticas",
      "Práctica 3: Resolución de problemas en Java (I)"
    ]
  },
  {
    "objectID": "practicas/practica3.html#raíces-de-una-ecuación-de-segundo-grado",
    "href": "practicas/practica3.html#raíces-de-una-ecuación-de-segundo-grado",
    "title": "Práctica 3: Resolución de problemas en Java (I)",
    "section": "2 Raíces de una ecuación de segundo grado",
    "text": "2 Raíces de una ecuación de segundo grado\nComo bien sabemos, una ecuación de segundo grado tiene la forma:\n\\[\nax^2 + bx + c = 0\n\\]\ndonde \\(a\\), \\(b\\) y \\(c\\) son coeficientes reales, y \\(x\\) es la variable que queremos resolver.\nA diferencia de las ecuaciones de primer grado, las de segundo grado pueden tener 0, 1 o 2 soluciones reales dependiendo de los valores de los coeficientes (\\(a\\), \\(b\\), \\(c\\)).\nPor ejemplo, los siguientes coeficientes generan diferentes números de soluciones:\n\n\\(a=1\\), \\(b=-3\\), \\(c=2\\) → dos soluciones reales (\\(x=1\\) y \\(x=2\\)).\n\\(a=1\\), \\(b=-2\\), \\(c=1\\) → una solución real (\\(x=1\\)).\n\\(a=1\\), \\(b=0\\), \\(c=1\\) → no soluciones reales.\n\n\n\n\nviewof params = {\n      const cleanSlider = (range, config) =&gt; {\n        const input = Inputs.range(range, config);\n        const numberBox = input.querySelector(\"input[type=number]\");\n        if (numberBox) numberBox.style.display = \"none\";\n        const rangeSlider = input.querySelector(\"input[type=range]\");\n        if (rangeSlider) rangeSlider.style.width = \"100%\";\n        input.style.width = \"100%\";\n        return input;\n      };\n\n      const ia = cleanSlider([-5, 5], { value: 1, step: 0.1 });\n      const ib = cleanSlider([-10, 10], { value: -2, step: 0.1 });\n      const ic = cleanSlider([-10, 10], { value: -3, step: 0.1 });\n\n      const col = (input, label) =&gt; {\n        const val = htl.html`&lt;div style=\"font-family: monospace; color: #555; margin-top: 4px;\"&gt;${input.value.toFixed(1)}&lt;/div&gt;`;\n        input.addEventListener(\"input\", () =&gt; val.textContent = input.value.toFixed(1));\n        \n        return htl.html`&lt;div style=\"display: flex; flex-direction: column; align-items: center; margin: 0 10px; flex: 1; min-width: 120px;\"&gt;\n          &lt;div style=\"font-weight: bold; font-size: 0.9rem; margin-bottom: 5px; white-space: nowrap;\"&gt;${label}&lt;/div&gt;\n          &lt;div style=\"width: 100%\"&gt;${input}&lt;/div&gt;\n          ${val}\n        &lt;/div&gt;`;\n      };\n\n      // Styles: Removed background/border here so it blends into the card\n      const form = htl.html`&lt;div style=\"display: flex; flex-wrap: wrap; justify-content: center; width: 100%; padding-bottom: 20px; border-bottom: 1px solid #eee; margin-bottom: 20px;\"&gt;\n        ${col(ia, \"a (curvatura)\")}\n        ${col(ib, \"b (pendiente)\")}\n        ${col(ic, \"c (desplazamiento ↑↓)\")}\n      &lt;/div&gt;`;\n\n      form.oninput = () =&gt; form.value = { a: ia.value, b: ib.value, c: ic.value };\n      form.value = { a: ia.value, b: ib.value, c: ic.value };\n      return form;\n    }\n\n    // Extract variables for reactivity\n    a = params.a\n    b = params.b\n    c = params.c\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\n      const curve = Array.from({ length: 401 }, (_, i) =&gt; {\n        const x = -10 + i * 0.05;\n        return { x, y: a * x * x + b * x + c };\n      });\n\n      const points = [];\n      const disc = b * b - 4 * a * c; \n      \n      if (a !== 0 && disc &gt;= 0) {\n        const r1 = (-b + Math.sqrt(disc)) / (2 * a);\n        const r2 = (-b - Math.sqrt(disc)) / (2 * a);\n        points.push({ x: r1, y: 0, type: \"Root\", label: `x=${r1.toFixed(2)}` });\n        if (disc &gt; 0) points.push({ x: r2, y: 0, type: \"Root\", label: `x=${r2.toFixed(2)}` });\n      } else if (a === 0 && b !== 0) {\n        const root = -c / b;\n        points.push({ x: root, y: 0, type: \"Root\", label: `x=${root.toFixed(2)}` });\n      }\n\n      const curve_plot = Plot.plot({\n        height: 400,\n        grid: true,\n        marginLeft: 40, \n        marginRight: 20,\n        x: { domain: [-10, 10], label: \"x axis\" },\n        y: { domain: [-10, 10], label: null }, // Removed Y label to save space\n        marks: [\n          Plot.ruleY([0], { stroke: \"#888\", strokeWidth: 1.5 }),\n          Plot.ruleX([0], { stroke: \"#888\", strokeWidth: 1.5 }),\n          Plot.line(curve, { x: \"x\", y: \"y\", stroke: \"steelblue\", strokeWidth: 3 }),\n          Plot.dot(points, { x: \"x\", y: \"y\", fill: d =&gt; d.type === \"Root\" ? \"#e63946\" : \"#457b9d\", r: 6, stroke: \"white\", strokeWidth: 2 }),\n          Plot.text(points, { x: \"x\", y: \"y\", text: \"label\", dy: -15, fill: \"currentColor\", stroke: \"white\", strokeWidth: 4, fontWeight: \"bold\", fontSize: 12 })\n        ]\n      });\n      \n      // Ensure the SVG fills the card width\n      curve_plot.style.width = \"100%\";\n      return curve_plot;\n    }",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Prácticas",
      "Práctica 3: Resolución de problemas en Java (I)"
    ]
  },
  {
    "objectID": "practicas/practica3.html#resolución-de-la-práctica",
    "href": "practicas/practica3.html#resolución-de-la-práctica",
    "title": "Práctica 3: Resolución de problemas en Java (I)",
    "section": "3 Resolución de la práctica",
    "text": "3 Resolución de la práctica\nPara resolver esta práctica se propone implementar tres clases en Java que correspondan a cada uno de los casos de solución de la ecuación cuadrática.\nDe manera general, ten en cuenta que la solución única o doble de la ecuación se calcula a través de la siguiente fórmula, conocida como la fórmula general: \\[\nx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} = \\frac{-b \\pm \\sqrt{\\Delta}}{2a}\n\\]\nEl valor dentro de la raíz cuadrada, \\(b^2 - 4ac\\), se llama discriminante (\\(\\Delta\\)) y determina el número de soluciones reales que tiene la ecuación:\n\n3.1 Clase 1: dos soluciones reales\nSi \\(\\Delta &gt; 0\\), la ecuación tiene dos soluciones reales distintas, que se calculan con la fórmula general utilizando el símbolo \\(+\\) para una raíz y el símbolo \\(-\\) para la otra raíz.\nVerifica que la solución es correcta utilizando los siguientes coeficientes:\n\n\\(a=1, \\quad b=-3, \\quad c=2\\) → dos soluciones reales (\\(x=1\\) y \\(x=2\\)).\n\n\n\n\n\n\n\nTipClases en Java\n\n\n\nRecuerda que, en Java, una clase toma el siguiente formato general:\npublic class NombreDeLaClase {\n    /*\n    * @author: Vuestros nombres\n    * @date: Fecha de entrega\n    */\n    public static void main(String[] args) {\n        // solución del problema\n    }\n}\n\n\n\n\n\n\n\n\nNotaImprimir resultados en Java\n\n\n\nUtiliza la impresión por consola para mostrar los resultados de las soluciones, por ejemplo:\nSystem.out.println(\"La solución es: \" + x);\n\n\n\n\n3.2 Clase 2: una solución real\nSi \\(\\Delta = 0\\), la ecuación tiene una única solución real, que se calcula con la fórmula general utilizando cualquiera de los símbolos \\(+\\) o \\(-\\), ya que ambos darán el mismo resultado.\n\n\n\n\n\n\nTipSolución única\n\n\n\nVerifica que la solución es correcta utilizando los siguientes coeficientes:\n\n\\(a=1, \\quad b=-2, \\quad c=1\\) → una solución real (\\(x=1\\)).\n\n\n\n\n\n3.3 Clase 3: no soluciones reales\nSi \\(\\Delta &lt; 0\\), la ecuación no tiene soluciones reales, ya que la raíz cuadrada de un número negativo no es un número real. En este caso, se pueden calcular las soluciones complejas utilizando números imaginarios de la siguiente forma: \\[\nx = \\frac{-b \\pm i\\sqrt{-(b^2 - 4ac)}}{2a} = \\frac{-b \\pm i\\sqrt{4ac - b^2}}{2a}\n\\]\nde tal manera que el número imaginario \\(i\\) se define como la raíz cuadrada de \\(-1\\).\nPor tanto, las dos soluciones complejas conjugadas se pueden expresar como: \\[\nx_1 = \\frac{-b + i\\sqrt{4ac - b^2}}{2a} \\quad \\text{y} \\quad x_2 = \\frac{-b - i\\sqrt{4ac - b^2}}{2a}\n\\]\n\n\n\n\n\n\nTipSolución compleja\n\n\n\nVerifica que la solución es correcta utilizando los siguientes coeficientes:\n\\(a=1, \\quad b=0, \\quad c=1\\)\nLas soluciones son: \\[x_1 = 0 + 1i\\] \\[x_2 = 0 - 1i\\]",
    "crumbs": [
      "![](../resources/unizar_white.png){width=95px}",
      "Prácticas",
      "Práctica 3: Resolución de problemas en Java (I)"
    ]
  }
]