---
title: "Lecci√≥n 1: Introducci√≥n a Processing"
format:
  revealjs:
    slide-level: 3
    theme: simple
    smaller: true
    code-overflow: scroll
    scrollable: true
    footer: "Informatica (30717) - Estudios en Arquitectura (UNIZAR)"
    auto-animate: true
    incremental: true
    show-slide-number: all
    code-line-numbers: true
---

## Objetivos de la pr√°ctica

Los objetivos de esta pr√°ctica son los siguientes:

- Familiarizaci√≥n con el ordenador y los elementos b√°sicos de un sistema operativo.
- Familiarizaci√≥n con el entorno de desarrollo Processing.
- Familiarizaci√≥n con aspectos b√°sicos de programaci√≥n a trav√©s de programas en Processing.

---

## Processing

### Introducci√≥n

::: {layout="[70,30]"}
::: {.column}
Processing es un lenguaje de programaci√≥n y un entorno de desarrollo (*Integrated Development Environment*, IDE).

- **Basado en Java**
- **Producci√≥n de proyectos multimedia e interactivos**
- Creado por cient√≠ficos del MIT en 2001
- Distribuci√≥n gratuita y de c√≥digo abierto
:::
::: {.column}
![](../resources/lesson1/processing.svg)
:::
:::

---

La propia [p√°gina de Processing](https://processing.org/examples/) muestra numerosos ejemplos de proyectos realizados con este lenguaje. Tambi√©n hay muchos ejemplos en Youtube, en particular, en el canal de [The Coding Train](https://www.youtube.com/c/TheCodingTrain).

::: {layout="[50,50]"}
::: {.column}
![Visualizaci√≥n del [fractal de Mandelbrot](https://processing.org/examples/mandelbrot.html).](../resources/lesson1/processing-example.png){#fig-mandelbrot}
:::
::: {.column}
![Canal de Youtube [The Coding Train](https://www.youtube.com/c/TheCodingTrain).](../resources/lesson1/thecodetrain.gif){#fig-thecodetrain}
:::
:::

### El entorno de desarrollo

El entorno de desarrollo de Processing tiene un dise√±o minimalista que facilita su uso. La interfaz gr√°fica posee las siguientes partes:

- **Un men√∫ de opciones** (archivo, editar, sketch, depuraci√≥n, herramientas y ayuda).
- **Dos botones para ejecutar y detener el programa.**
- Un √°rea central para escribir el c√≥digo fuente (**editor**).
- Una ventana inferior donde se muestran dos pesta√±as:
  - **Consola**: salida est√°ndar del programa.
  - **Errores**: mensajes de error generados durante la ejecuci√≥n.
  
Al ejecutar un programa se abrir√° una **nueva ventana donde se mostrar√° el resultado de la ejecuci√≥n**.

![Vista del entorno de desarrollo (derecha) y ventana *pop-up* (izquierda) que redirige a ejemplos disponibles en su p√°gina web.](../resources/lesson1/ide.png){#fig-ide}

::: {.callout-warning}
El primer archivo que se crea en un nuevo proyecto de *Processing* se denomina `sketch_XXXXXX`. Es recomendable cambiar el nombre del archivo para que tenga sentido con el programa que se va a desarrollar. Adem√°s, al guardarlo nos preguntar√° por el nombre del proyecto, que tambi√©n es recomendable que tenga sentido. 

Indicad una ubicaci√≥n de f√°cil acceso en vuestro ordenador para guardar los proyectos de *Processing*.
:::

## Dibujando figuras geom√©tricas

Las figuras geom√©tricas se dibujan en una ventana que est√° formada por una **matriz de p√≠xeles**. Cada p√≠xel es un peque√±o punto de luz que puede tener un color diferente. La combinaci√≥n de todos los p√≠xeles forma la imagen que vemos en la pantalla.

Un p√≠xel es la **unidad m√°s peque√±a de una imagen digital**. La resoluci√≥n de una imagen se refiere a la cantidad de p√≠xeles que contiene, y se expresa como el n√∫mero de p√≠xeles en el eje horizontal por el n√∫mero de p√≠xeles en el eje vertical (por ejemplo, 1920x1080 p√≠xeles). Por ejemplo, la @fig-highres muestra una animaci√≥n con una resoluci√≥n alta, donde los p√≠xeles no son visibles a simple vista. En cambio, en la @fig-lowres se ha reducido la resoluci√≥n de la animaci√≥n, y comienzan a ser visibles los p√≠xeles individuales.

::: {layout="[50,50]"}
::: {.column}
![Animaci√≥n con una resoluci√≥n de pantalla alta.](../resources/lesson1/animation_pixels.webm){#fig-highres}
:::

::: {.column}
![Animaci√≥n con una resoluci√≥n de pantalla m√°s baja, donde comienzan a ser visibles los p√≠xeles.](../resources/lesson1/animation_pixels_lowerres.webm){#fig-lowres}
:::
:::

::: {layout="[70,30]"}
::: {.column}
Para dibujar cualquier figura geom√©trica, es necesario especificar una o varias posiciones en la ventana. Dichas posiciones se definen mediante un par de coordenadas **(x, y)**, donde ***x*** indica la **posici√≥n horizontal** e ***y*** la **posici√≥n vertical**. En *Processing*, el origen de coordenadas (0,0) se encuentra en la esquina superior izquierda de la ventana, como se muestra en la figura de la derecha.

::: {.callout-note}
## üß™ Ejercicio 1 - Sistema de coordenadas

Dibuja una l√≠nea que va desde la posici√≥n (10, 0) hasta la posici√≥n (40, 50).
```java
line(10, 0, 40, 50);
```
:::
:::
::: {.column}
![Ilustraci√≥n de una matriz de p√≠xeles, indicando las coordenadas de algunos de ellos.](../resources/lesson1/pixel-matrix.svg){#fig-pixels}
:::
:::

::: {.callout-warning}
## üìù Ejercicio 2 ‚Äî Errores comunes

Prueba a copiar el siguiente c√≥digo en el editor de *Processing* y ejecutarlo:
```java
Line(10, 0, 40, 50);
```

<details>
<summary>üí° Soluci√≥n</summary>
Processing es sensible al uso de may√∫sculas y min√∫sculas. Por ejemplo, la funci√≥n para dibujar una l√≠nea es `line`, no `Line` ni `LINE`.

Las palabras reservadas se muestran <span style="color:#1f77ff; font-weight:600;">resaltadas</span> en el editor, por lo que esta es una manera de ver si el nombre de una funci√≥n est√° bien escrito. Los <span style="color:#FF0000; font-weight:600;">errores</span> se muestran en la pesta√±a *Errores* de la ventana inferior.
</details>
:::

::: {.callout-note}
## üß™ Ejercicio 3 - M√∫ltiples formas geom√©tricas

Prueba a dibujar varias l√≠neas en diferentes posiciones de la pantalla, utilizando la instrucci√≥n `line` varias veces. 
:::

### Lienzo

Las figuras geom√©tricas se dibujan sobre un lienzo de tama√±o predeterminado 100x100 p√≠xeles. No obstante, es posible cambiar el tama√±o del lienzo utilizando la funci√≥n `size`, que recibe dos par√°metros: el ancho y el alto del lienzo en p√≠xeles.

::: {.callout-note}
## üß™ Ejercicio 4 - Tama√±o del lienzo 

Dibuja varias l√≠neas en un lienzo de tama√±o 300x200 p√≠xeles.

<details>
<summary>üí° Soluci√≥n</summary>
```java
size(300, 200);
line(10, 0, 40, 50);
line(100, 50, 200, 150);
line(250, 0, 250, 200);
```
</details>
:::

### Tipos de figuras geom√©tricas

Adem√°s de la l√≠nea utilizada en los ejercicios anteriores, *Processing* permite dibujar otras figuras geom√©tricas b√°sicas, tales como **puntos**, **tri√°ngulos**, **cuadril√°teros**, **rect√°ngulos** y **elipses**. 

::: {.callout-note}
## üß™ Ejercicio 5 - Deducci√≥n de par√°metros

¬øPuedes deducir qu√© par√°metros son necesarios para dibujar algunas de las figuras geom√©tricas mencionadas anteriormente?
Puedes consultar la [documentaci√≥n oficial de *Processing*](https://processing.org/reference#shape), y m√°s concretamente, la secci√≥n *2d primitives* en el apartado *Shape*.

<details>
<summary>üí° Soluci√≥n</summary>
- `point(x, y)`: un punto en la posici√≥n (x, y).
- `triangle(x1, y1, x2, y2, x3, y3)`: un tri√°ngulo con v√©rtices en las posiciones (x1, y1), (x2, y2) y (x3, y3).
- `quad(x1, y1, x2, y2, x3, y3, x4, y4)`: un cuadril√°tero con v√©rtices en las posiciones (x1, y1), (x2, y2), (x3, y3) y (x4, y4).
- `rect(x, y, anchura, altura)`: un rect√°ngulo con esquina superior izquierda en la posici√≥n (x, y), de anchura y altura especificadas.
- `ellipse(x, y, anchura, altura)`: una elipse centrada en la posici√≥n (x, y), con anchura y altura especificadas.
</details>
:::

#### Dibujando rect√°ngulos y elipses

Tanto en la documentaci√≥n oficial, como en la soluci√≥n del ejercicio anterior, os habr√©is podido dar cuenta de que las funciones `rect` y `ellipse` requieren cuatro par√°metros: dos para la posici√≥n y dos para el tama√±o. Sin embargo, hemos asumido que la posici√≥n siempre corresponde a la esquina superior izquierda del rect√°ngulo o al centro de la elipse. Esta suposici√≥n es correcta por defecto, pero es posible cambiarla utilizando las funciones `rectMode` y `ellipseMode`. M√°s concretamente, estas funciones permiten definir c√≥mo se interpretan las posiciones pasadas como par√°metros a las funciones `rect` y `ellipse`. Existen dos modos principales para cada una de estas funciones:

- `CORNER`: la posici√≥n corresponde a la esquina superior izquierda del rect√°ngulo o elipse.
- `CENTER`: la posici√≥n corresponde al centro del rect√°ngulo o elipse.

![Representaci√≥n de c√≥mo se interpretan las posiciones en ambos modos para rect√°ngulos y elipses.](../resources/lesson1/rect-mode.svg){#fig-rectmodes}

Por defecto, *Processing* interpreta las posiciones de la siguiente manera:
```java
rectMode(CORNER);
ellipseMode(CENTER);
```

Tambi√©n es posible cambiar esta interpretaci√≥n usando:

```java
rectMode(CENTER);
ellipseMode(CORNER);
```

::: {.callout-note}
## üß™ Ejercicio 6 - Modo de dibujo

Intenta dibujar un c√≠rculo centrado en (20, 30) con radio 10 utilizando ambos modos. En el siguiente c√≥digo tienes todas las instrucciones necesarias para completar el ejercicio:
```java
// Modo por defecto
ellipseMode(CENTER);
ellipse( , , , );

// Modo alternativo
ellipseMode(CORNER);
ellipse( , , , );
```
:::

## Color en *Processing*

### Escala de grises

::: {layout="[60,30]"}
::: {.column}
Hasta ahora, hemos dibujado figuras geom√©tricas sin especificar ning√∫n color. Por defecto, las figuras se dibujan en negro sobre un fondo blanco.

A continuaci√≥n, veremos c√≥mo especificar colores en *Processing*. Por ahora, basta con componer colores en escala de grises. Para ello hay que tener en cuenta que la escala de un tono de gris va de 0 a 255; el valor 0 corresponde al negro y el valor 255 corresponde al blanco. Por ejemplo, la figura de la derecha se ha representado √∫nica y exclusivamente con diferentes valores de gris.

En *Processing*, las figuras tienen **borde** y **relleno**, que se definen mediante los m√©todos `stroke` y `fill`. Adem√°s, tambi√©n puede controlarse el color de fondo de la ventana con `background`.
:::

::: {.column}
![Imagen representada √∫nicamente con valores de gris.](../resources/lesson1/grayscale.svg){#fig-grayscale}
:::
:::

Por ejemplo, podemos definir el color del fondo, as√≠ como del borde y el relleno de un rect√°ngulo de la siguiente manera:
```java
background(0);              // fondo 

stroke(200);                // borde
fill(100);                  // relleno
rect(50, 50, 100, 100);
```

Adem√°s, cabe destacar que *Processing* funciona como una **m√°quina de estados**; es decir, **una vez se indica el color de borde o de relleno, este se utilizar√° para todas las figuras que se dibujen a continuaci√≥n**. Por ejemplo, podemos dibujar dos rect√°ngulos con el mismo color de borde, pero diferente color de relleno, de la siguiente manera:
```java
stroke(0);
fill(150);
rect(20, 20, 50, 50);       // borde negro, relleno gris

fill(50);
rect(80, 20, 50, 50);       // mismo borde, diferente relleno
```

::: {layout="[50, 50]"}

::: {.column}
::: {.callout-note}
## üß™ Ejercicio 7 - C√≠rculo y colores

Dibuja un c√≠rculo negro con borde gris, centrado en (20, 30) y con radio 10.

<details>
<summary>üí° Soluci√≥n</summary>
```java
stroke(128);
fill(0);
ellipse(20, 30, 20, 20);
```
</details>
:::
:::

::: {.column}
::: {.callout-note}
## üß™ Ejercicio 8 - Dibuja una forma geom√©trica

Trata de obtener algo parecido a la figura que se muestra debajo.

![](../resources/lesson1/render.png){width="40%" fig-align="center"}
:::
:::
:::


### Colores RGB (red, green, blue)

::: {layout="[30,70]"}
::: {.column}
![Representaci√≥n de los colores primarios RGB.](../resources/lesson1/primary-colors.png){#fig-rgb}
:::

::: {.column}
Adem√°s de diferentes tonos de gris, *Processing* permite definir colores a partir de los tres colores primarios: rojo, verde y azul (RGB). Cuando los tres componentes toman el valor m√°ximo (255), el color resultante es el blanco. En una escala de grises, los tres valores RGB coinciden; por ejemplo, el color (0, 0, 0) corresponde al negro. Por otro lado, si s√≥lo activamos un canal con 255, y dejamos el resto a 0, obtenemos rojo, verde o azul.

```java
fill(255, 0, 0);  // rojo
fill(0, 255, 0);  // verde
fill(0, 0, 255);  // azul
```
:::
:::

::: {.callout-note}
## üß™ Ejercicio 9 - Colores RGB

¬øSabr√≠as decir qu√© colores crear√°n las siguientes combinaciones de rojo, verde y azul?

- `fill(255, 255, 0)`
- `fill(0, 255, 255)`
- `fill(255, 0, 255)`
- `fill(255, 255, 127)`
- `fill(127, 255, 255)`
- `fill(255, 127, 255)`

**Pista**: f√≠jate en la @fig-rgb.
:::

::: {layout="[40, 50]"}
::: {.column}
![Captura de pantalla del selector de color de *Processing*.](../resources/lesson1/hsv-picker.png){#fig-colorpicker}
:::

::: {.column}
Como habr√©is podido observar a partir del Ejercicio 9, no es sencillo imaginar qu√© color genera una mezcla concreta de valores RGB, ni determinar qu√© valores exactos u aproximados de rojo, verde y azul necesitamos para componer un color que tengamos en mente. Por esta raz√≥n, *Processing* dispone de una herramienta, *Selector de color*, que permite interactuar con una paleta de colores y obtener valores de rojo, verde y azul. Pod√©is acceder a esta herramienta desde el men√∫ **Herramientas > Selector de color**.
:::
:::

### Opacidad

Adem√°s de los canales R, G y B, tambi√©n podemos indicar un valor de **opacidad**. De esta manera, un valor de opacidad de 255 indica que elemento a dibujar es completamente opaco, y un valor de 0 indica que es completamente transparente. Para especificar la opacidad, bastante con indicar un cuarto valor en operaciones como `stroke` o `fill`.

```java
fill(255, 255, 127);
rect(50, 50, 100, 100);     // rect√°ngulo opaco     

fill(255, 0, 127, 127);     
rect(20, 20, 50, 50);       // rect√°ngulo semitransparente
```

## Programas din√°micos

Hasta este momento, hemos escrito programas est√°ticos, es decir, programas que dibujan una imagen fija. A continuaci√≥n, veremos c√≥mo crear programas din√°micos que pueden cambiar con el tiempo.

::: {layout="[60,40]"}
::: {.column}
Comenzaremos con este bloque de c√≥digo:
```java
size(800, 800);

// Pinta un fondo blanco
background(255);

// Fija las coordenadas basadas en el centro
ellipseMode(CENTER);
rectMode(CENTER);

// Dibuja el cuerpo
stroke(0);
fill(150);
rect(400, 400, 80, 400);

// Dibuja la cabeza
fill(255);
ellipse(400, 280, 200, 240);

// Dibuja los ojos
fill(0);
ellipse(350, 280, 50, 100);
ellipse(450, 280, 50, 100);

// Dibuja las piernas
stroke(0);
line(360, 600, 320, 640);
line(440, 600, 480, 640);
```
:::

::: {.column}
![Imagen del alien√≠gena Zoog.](../resources/lesson1/zoog.png){#fig-zoog}

::: {.callout-note}
## üß™ Ejercicio 10 - Dibuja a Zoog
Intenta dibujar al alien√≠gena Zoog utilizando el bloque de c√≥digo anterior como referencia.
:::
:::
:::

### Comentarios

Aprovechando que nuestro programa empieza a ser un poco m√°s largo, es recomendable a√±adir comentarios para explicar qu√© hace cada parte del c√≥digo. En *Processing*, los comentarios se indican con `//` para comentarios de una sola l√≠nea, o con `/*` y `*/` para comentarios multil√≠nea. Por ejemplo, en el siguiente c√≥digo se han a√±adido comentarios para explicar qu√© parte del cuerpo de Zoog dibuja cada bloque de instrucciones:

```java
// Dibuja el cuerpo de Zoog
rect(200, 200, 40, 200);

/* Dibuja la cabeza de Zoog en la posici√≥n (200, 140) con ancho y alto 120 */
ellipse(200, 140, 100, 120);
```

### Funciones `setup` y `draw`

*Processing* utiliza dos funciones especiales para organizar el c√≥digo: `setup` y `draw`. 

- La funci√≥n `setup` se ejecuta una √∫nica vez al inicio del programa, y es el lugar adecuado para inicializar variables, definir el tama√±o de la ventana, etc. 
- Por otro lado, la funci√≥n `draw` se ejecuta de manera repetitiva en un bucle infinito, y es el lugar adecuado para dibujar figuras que cambian con el tiempo.

Tanto `setup` como `draw` son funciones especiales que no requieren ser llamadas expl√≠citamente en el c√≥digo; *Processing* se encarga de ello autom√°ticamente. Aunque no entraremos en detalles sobre la sintaxis de las funciones en este momento, es importante destacar que el c√≥digo que se encuentra dentro de una funci√≥n debe estar **sangrado** (indentado) para indicar que pertenece a dicha funci√≥n. Adem√°s, ambas funciones devuelven `void`, lo que significa que no devuelven ning√∫n valor. Tambi√©n es importante abrir y cerrar llaves `{}` para definir el bloque de c√≥digo que pertenece a cada funci√≥n.

::: {layout="[50.5,49.5]"}
::: {.column}
Por ejemplo, el siguiente programa dibuja una pelota que rebota dentro de la ventana:
```java
int x = 50;
int y = 50;
int speedX = 3;
int speedY = 2;

void setup() {
  size(400, 400);
} 

void draw() {
  background(255);
  
  // Dibuja la pelota
  fill(0);
  ellipse(x, y, 30, 30);
  
  // Actualiza la posici√≥n de la pelota
  x += speedX;
  y += speedY;
  
  // Rebote en los bordes
  if (x <= 15 || x >= width - 15) {
    speedX = -speedX;
  }
  if (y <= 15 || y >= height - 15) {
    speedY = -speedY;
  }
}
```
::: 

::: {.column .centered}
![](../resources/lesson1/bouncing_ball.gif)
:::
:::

::: {.callout-note}
## üß™ Ejercicio 11 - Zoog, utilizando `setup` y `draw`

Reescribe el c√≥digo de Zoog utilizando las funciones `setup` y `draw`. **¬øNotas alguna diferencia en el resultado respecto al c√≥digo original?**

```java
void draw() {
    // Pinta un fondo blanco
    background(255);

    // Fija las coordenadas basadas en el centro
    ellipseMode(CENTER);
    rectMode(CENTER);

    // Dibuja el cuerpo
    stroke(0);
    fill(150);
    rect(400, 400, 80, 400);

    // Dibuja la cabeza
    fill(255);
    ellipse(400, 280, 200, 240);

    // Dibuja los ojos
    fill(0);
    ellipse(350, 280, 50, 100);
    ellipse(450, 280, 50, 100);

    // Dibuja las piernas
    stroke(0);
    line(360, 600, 320, 640);
    line(440, 600, 480, 640);
}

void setup() {
  // Tama√±o del lienzo
  size(800, 800);
}
```
:::

::: {.callout-warning}
## üî¥ Color de fondo 

Prueba a mover la instrucci√≥n `background(255);` desde la funci√≥n `draw` a la funci√≥n `setup`. **¬øQu√© ocurre?**
:::

### Transformaciones geom√©tricas

Aunque no entraremos en detalles sobre las transformaciones geom√©tricas en este momento, es importante mencionar que *Processing* proporciona varias funciones para trasladar, rotar y escalar las figuras geom√©tricas. Por ejemplo, la funci√≥n `translate(x, y)` permite trasladar el origen de coordenadas a la posici√≥n (x, y), de manera que todas las figuras que se dibujen a continuaci√≥n se posicionar√°n en funci√≥n de este nuevo origen.

Por ejemplo, los siguientes dos bloques de c√≥digo dibujan un rect√°ngulo en la misma posici√≥n, pero utilizando diferentes transformaciones geom√©tricas:
```java
size(150, 200);

// Sin transformaciones geom√©tricas
rect(50, 50, 50, 100);

// Con transformaciones geom√©tricas
translate(50, 50);
rect(0, 0, 50, 100);
```

Las transformaciones geom√©tricas m√°s comunes son:

- `translate(x, y)`: traslada el origen de coordenadas a la posici√≥n (x, y).
- `rotate(angle)`: rota el sistema de coordenadas en un √°ngulo especificado (en radianes).
    - Por ejemplo, para rotar 45 grados, se puede utilizar `rotate(PI/4)`, ya que œÄ radianes equivalen a 180 grados.
    - Dados dos puntos (x1, y1) y (x2, y2), el √°ngulo entre ellos puede calcularse con la funci√≥n `atan2(y2 - y1, x2 - x1)`.
- `scale(s)`: escala el sistema de coordenadas por un factor *s*.

Por otro lado, cuando aplicamos transformaciones geom√©tricas, es importante tener en cuenta que estas se **acumulan**. Por ejemplo, si definimos en el c√≥digo una traslaci√≥n seguida de una rotaci√≥n, todas las figuras que se dibujen a continuaci√≥n se ver√°n afectadas por ambas transformaciones; primero se aplicar√° la rotaci√≥n y luego la traslaci√≥n.

Para evitar este comportamiento acumulativo, *Processing* proporciona las funciones `pushMatrix()` y `popMatrix()`, que permiten **guardar y restaurar el estado del sistema de coordenadas**, respectivamente. De esta manera, podemos aplicar transformaciones geom√©tricas a un bloque espec√≠fico de c√≥digo sin afectar al resto del programa.

Por ejemplo, el siguiente bloque de c√≥digo dibuja dos rect√°ngulos: el primero se dibuja con una traslaci√≥n y una rotaci√≥n, mientras que el segundo se dibuja sin ninguna transformaci√≥n geom√©trica, gracias al uso de `pushMatrix()` y `popMatrix()`.
```java
size(400, 200);

pushMatrix();           // Introducimos un nuevo bloque de transformaciones

translate(150, 50);     // Trasladamos el origen
rotate(PI/4);           // Rotamos 45 grados
rect(0, 0, 50, 100);

popMatrix();            // Restauramos el sistema de coordenadas original

rect(300, 50, 50, 100); // No se ve afectado por las transformaciones anteriores
```

A modo de ejemplo, la @fig-transformations ilustra la importancia de ordenar correctamente las transformaciones geom√©tricas. En la imagen de la izquierda, primero se traslada el origen de coordenadas y luego se rota, mientras que en la imagen de la derecha, primero se rota y luego se traslada. Como resultado, los rect√°ngulos aparecen en posiciones diferentes.

![A la izquierda, una rotaci√≥n respecto del origen de coordenadas, seguida por una traslaci√≥n; a la derecha, una traslaci√≥n seguida por una rotaci√≥n](../resources/lesson1/transformations.svg){#fig-transformations}

### Interacci√≥n con el rat√≥n

Como habr√°s podido observar, en el programa de la pelota que rebota, se utilizan algunas **palabras reservadas** como `width` y `height`. Estas palabras reservadas permiten acceder al ancho y alto de la ventana, respectivamente. De manera similar, *Processing* proporciona otras palabras reservadas que permiten interactuar con el rat√≥n, como `mouseX` y `mouseY`, que indican la **posici√≥n actual del rat√≥n en la ventana**.

::: {.callout-note}
## üß™ Ejercicio 12 - Sigue al rat√≥n

Modifica el programa de Zoog para que la esquina superior izquierda, es decir, desde donde se dibuja el cuerpo, siga la posici√≥n del rat√≥n, utilizando `mouseX` y `mouseY`.

üí°**Pista**: se puede trasladar toda la geometr√≠a con una de las transformaciones geom√©tricas antes mencionadas.
:::

::: {.callout-note}
## üß™ Ejercicio 13 - Reacci√≥n del cuerpo al movimiento del rat√≥n

Modifica el programa de Zoog para que la cabeza gire en funci√≥n de la posici√≥n del rat√≥n. Por ejemplo, si el rat√≥n est√° a la izquierda de Zoog, la cabeza debe girar hacia la izquierda, y viceversa.

üí°**Pista**: se puede rotar toda la cabeza, incluyendo los ojos, con una de las transformaciones geom√©tricas antes mencionadas. Para calcular el √°ngulo de rotaci√≥n, puedes utilizar la funci√≥n `atan2(dy, dx)`, donde `dy` y `dx` son las diferencias en las coordenadas y y x entre la posici√≥n del rat√≥n y la posici√≥n de la cabeza de Zoog.
:::

## Variables, condicionales y bucles

### Introducci√≥n a variables

En la secci√≥n anterior hemos descubierto que el m√©todo `draw` se ejecuta de manera repetitiva en un bucle infinito. Esto nos permite crear programas din√°micos que cambian con el tiempo. Sin embargo, para crear programas m√°s complejos, es necesario utilizar **variables** para almacenar datos que pueden cambiar durante la ejecuci√≥n del programa.

::: {.callout-note}
## üß™ Ejercicio 14 - Traslada una esfera

Crea un programa que traslade una esfera de izquierda a derecha en la ventana. Utiliza una variable para almacenar la posici√≥n horizontal de la esfera, y actual√≠zala en cada iteraci√≥n del bucle `draw`.

<details>
<summary>üí° Soluci√≥n</summary>
```java
// Variables globales
int circleX = 100;
int circleY = 100;

// Se ejecuta al inicio del programa
void setup() {
  size(200, 200);
}

// Se ejecuta repetidamente
void draw() {
  background(255);
  stroke(0);
  fill(175);
  ellipse(circleX, circleY, 50, 50);
  circleX = circleX + 1;
}
```
</details>
:::

### Condicionales

Los **condicionales** permiten ejecutar **diferentes bloques de c√≥digo** en funci√≥n de **si se cumple o no una determinada condici√≥n**. En *Processing*, los condicionales se implementan utilizando las palabras reservadas `if`, `else if` y `else`.

La sintaxis b√°sica de un condicional es la siguiente:
```java
if (condici√≥n) {
  // bloque de c√≥digo si la condici√≥n es verdadera
} else if (otra_condici√≥n) {
  // bloque de c√≥digo si la otra condici√≥n es verdadera
} else {
  // bloque de c√≥digo si ninguna condici√≥n es verdadera
}
```

Ten en cuenta que no siempre es necesario utilizar `else if` o `else`; **un condicional puede consistir √∫nicamente en una instrucci√≥n `if`**.

::: {.callout-note}
## üß™ Ejercicio 15 - Color de fondo interactivo

Modifica el programa de Zoog para que el color de fondo cambie en funci√≥n de la posici√≥n del rat√≥n. Por ejemplo, si el rat√≥n se encuentra en el primer tercio de la ventana, el fondo debe ser blanco; si est√° en el segundo tercio, el fondo debe ser gris; y si est√° en el tercer tercio, el fondo debe ser negro.

:::

### Bucles

Existen algunas palabras reservadas en *Java* para representar **bucles**, es decir, **bloques de c√≥digo que se repiten durante un n√∫mero de iteraciones, o infinitamente hasta que no se cumpla alguna condici√≥n**. 

En esta sesi√≥n es suficiente con conocer el bucle `for`, que permite ejecutar un bloque de c√≥digo un n√∫mero determinado de veces. La sintaxis b√°sica de un bucle `for` es la siguiente:
```java
for (int i = 1; i <= N; i++) {
  // bloque de c√≥digo a ejecutar N veces
}
```

---

::: {.callout-note}
## üß™ Ejercicio 16 - M√∫ltiples Zoog

El objetivo es mostrar 2 Zoogs en la pantalla a partir del programa de un √∫nico Zoog. Ten en cuenta que tendr√°s que modificar la posici√≥n de al menos uno de ellos para que sea visible.

**A modo de inspiraci√≥n**, el siguiente c√≥digo dibuja dos rect√°ngulos desplazados en el eje horizontal y vertical en funci√≥n de *i*:
```java
size(500, 200);

int N = 2;
for (int i = 1; i <= N; i++) {
  rect(i * 150, 50 + i * 10, 80, 80);
}
```


:::

## Ap√©ndice: Instalaci√≥n de Processing {.unnumbered}

![Banner de la p√°gina oficial de *Processing*; a la izquierda se muestra el bot√≥n de *Download*.](../resources/lesson1/web-teaser.png){#fig-installation}

- Accede a [la p√°gina oficial de *Processing*](http://processing.org) y selecciona **Download**.
- Descarga la versi√≥n correspondiente a tu sistema operativo.
- Ejecuta el instalador descargado y sigue las instrucciones.
